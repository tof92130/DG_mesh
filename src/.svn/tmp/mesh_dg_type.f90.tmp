module moduleMesh
  use omp_lib

  implicit none ; private

  type mesh_dg
    private
    !-------
    integer               :: nlog
    !-------
    character(256)        :: mesh_name
    integer               :: geo
    integer               :: prec
    integer               :: nvert
    real(8), allocatable  :: vertx(:,:)
    integer, allocatable  :: mark(:)
    integer               :: nH6
    integer, allocatable  :: hexas(:,:)
    integer               :: nT4
    integer, allocatable  :: tetra(:,:)
    integer               :: nQ4
    integer, allocatable  :: quadr(:,:)
    integer               :: nT3
    integer, allocatable  :: trian(:,:)
    integer               :: nL2
    integer, allocatable  :: edges(:,:)
    real(8), allocatable  :: norms(:,:)
    real(8), allocatable  :: metri(:,:)
    real(8)               :: xmin,xmax
    real(8)               :: ymin,ymax
    real(8)               :: zmin,zmax
    !-------
    logical               :: solution
    character(256)        :: solu_name
    integer               :: nsol,nfld
    real(8), allocatable  :: solu(:,:)
    integer               :: kind(20)
    integer               :: ker
    !-------
  end type mesh_dg

  type, public :: T3
    private
    ! nodes
    integer :: n1
    integer :: n2
    integer :: n3
    ! mark
    integer :: m
    ! coordonates
    real(8) :: x(3)
    real(8) :: y(3)
    real(8) :: z(3)
    ! flow
    real(8) :: vx(3)
    real(8) :: vy(3)
    real(8) :: vz(3)
    real(8) :: r0(3)
    real(8) :: a0(3)
    ! Jacobien
    real(8) :: nx
    real(8) :: ny
    real(8) :: nz
    real(8) :: jac
    real(8) :: inv(2,2)
  end type T3

  type jacob2D
    private
    real(8):: mat(2,2)
    real(8):: inv(2,2)
    real(8):: det
  end type jacob2D

  type jacob3D
    private
    real(8):: mat(3,3)
    real(8):: inv(3,3)
    real(8):: det
  end type jacob3D


  interface get_geo           ; module procedure mesh_dg_geo_get          ; end interface
  interface set_geo           ; module procedure mesh_dg_geo_set          ; end interface
 
  interface get_name_mesh     ; module procedure mesh_dg_mesh_name_get    ; end interface
  interface set_name_mesh     ; module procedure mesh_dg_mesh_name_set    ; end interface
  interface get_name_solu     ; module procedure mesh_dg_solu_name_get    ; end interface
  interface set_name_solu     ; module procedure mesh_dg_solu_name_set    ; end interface

  interface get_nL2           ; module procedure mesh_dg_nL2_get          ; end interface
  interface set_nL2           ; module procedure mesh_dg_nL2_set          ; end interface
  interface get_nlog          ; module procedure mesh_dg_nlog_get         ; end interface
  interface set_nlog          ; module procedure mesh_dg_nlog_set         ; end interface
  interface get_nT3           ; module procedure mesh_dg_nT3_get          ; end interface
  interface set_nT3           ; module procedure mesh_dg_nT3_set          ; end interface
  interface get_nT4           ; module procedure mesh_dg_nT4_get          ; end interface
  interface set_nT4           ; module procedure mesh_dg_nT4_set          ; end interface

  interface build_skin        ; module procedure mesh_dg_skin_create      ; end interface
  interface connected_mesh    ; module procedure mesh_dg_connected_mesh   ; end interface
  interface connected_solu    ; module procedure mesh_dg_connected_solu   ; end interface
  interface control_cells     ; module procedure mesh_dg_control_cells    ; end interface
  interface compare_meshes    ; module procedure mesh_dg_compare_meshes   ; end interface
  interface create_box        ; module procedure mesh_dg_create_box       ; end interface
  interface cut_mesh          ; module procedure mesh_dg_cut_mesh         ; end interface
  interface cut_solu          ; module procedure mesh_dg_cut_solu         ; end interface
  interface cylindric         ; module procedure mesh_dg_cylindric        ; end interface 
  interface delete_skin       ; module procedure mesh_dg_skin_delete      ; end interface
  interface display           ; module procedure mesh_dg_display          ; end interface
  interface extract_skin      ; module procedure mesh_dg_extract_skin     ; end interface
  interface interpolate       ; module procedure mesh_dg_interpolate      ; end interface
  interface interpolate       ; module procedure mesh_dg_interpolate_vert ; end interface
  interface hexa2tetra_mesh   ; module procedure mesh_dg_hexa2tetra_mesh  ; end interface
  interface hexa2tetra_solu   ; module procedure mesh_dg_hexa2tetra_solu  ; end interface
  interface inverse_triangles ; module procedure mesh_dg_inverse_triangles; end interface
  interface mesh_skin3D       ; module procedure mesh_dg_skin3D           ; end interface
  interface keep_skin_marked  ; module procedure mesh_dg_skin_marked      ; end interface
  interface keep_vertices     ; module procedure mesh_dg_vert             ; end interface
  interface localize          ; module procedure mesh_dg_localize         ; end interface
  interface mesh_mark         ; module procedure mesh_dg_mesh_mark        ; end interface
  interface metric_mesh       ; module procedure mesh_dg_metric_mesh      ; end interface
  interface merge_meshes      ; module procedure mesh_dg_merge_meshes     ; end interface
  interface normal_mesh       ; module procedure mesh_dg_nomal_set        ; end interface
  interface quadr2tria_mesh   ; module procedure mesh_dg_quadr2tria_mesh  ; end interface
  interface read_mesh_ensight ; module procedure mesh_dg_read_mesh_ensight; end interface
  interface read_mesh_actran  ; module procedure mesh_dg_read_mesh_actran ; end interface
  interface read_mesh         ; module procedure mesh_dg_read_mesh        ; end interface
  interface read_solu         ; module procedure mesh_dg_read_solu        ; end interface
  interface replace_mark      ; module procedure mesh_dg_replace_mark     ; end interface
  interface rotate_mesh       ; module procedure mesh_dg_rotate_mesh      ; end interface
  interface rotate_solu       ; module procedure mesh_dg_rotate_solu      ; end interface
  interface scale_mesh        ; module procedure mesh_dg_scale_mesh       ; end interface
  interface project_mesh      ; module procedure mesh_dg_project_mesh     ; end interface
  interface get_suffix        ; module procedure mesh_dg_suffix_get       ; end interface
  interface smouth_solu       ; module procedure mesh_dg_smouth_solu      ; end interface
  interface symetric_mesh     ; module procedure mesh_dg_symetric_mesh    ; end interface
  interface symetric_solu     ; module procedure mesh_dg_symetric_solu    ; end interface
  interface translate_mesh    ; module procedure mesh_dg_translate_mesh   ; end interface
  interface trim_mesh         ; module procedure mesh_dg_trim_mesh        ; end interface
  interface trim_solu         ; module procedure mesh_dg_trim_solu        ; end interface
  interface write_gradient    ; module procedure mesh_dg_gradient_set     ; end interface
  interface write_mesh        ; module procedure mesh_dg_write_mesh       ; end interface
  interface write_solu        ; module procedure mesh_dg_write_solu       ; end interface

  interface cut2DTocut3D      ; module procedure mesh_dg_Cut2D_To_Cut3D   ; end interface
  public :: cut2DTocut3D

  public :: mesh_dg
  public :: build_skin
  public :: compare_meshes
  public :: connected_mesh,connected_solu
  public :: control_cells
  public :: create_box
  public :: cut_mesh,cut_solu
  public :: cylindric
  public :: delete_skin
  public :: display
  public :: get_geo,set_geo
  public :: get_nL2,set_nL2
  public :: get_nlog,set_nlog
  public :: get_nT3,set_nT3
  public :: get_nT4,set_nT4
  public :: get_name_mesh,set_name_mesh
  public :: get_name_solu,set_name_solu
  public :: get_suffix

  public :: extract_skin

  public :: hexa2tetra_mesh,hexa2tetra_solu
  public :: interpolate
  public :: inverse_triangles
  public :: keep_skin_marked
  public :: keep_vertices
  public :: localize
  public :: mesh_mark
  public :: metric_mesh
  public :: merge_meshes
  public :: normal_mesh
  public :: quadr2tria_mesh
  public :: read_mesh,write_mesh
  public :: read_mesh_actran
  public :: read_mesh_ensight
  public :: read_solu,write_solu
  public :: replace_mark
  public :: rotate_mesh,rotate_solu
  public :: project_mesh
  public :: scale_mesh
  public :: smouth_solu
  public :: mesh_skin3D
  public :: symetric_mesh,symetric_solu
  public :: translate_mesh
  public :: trim_mesh,trim_solu
  public :: write_gradient

  ! v3d

  type mesh_v3d
    private
    integer        :: nfields
    character(256) :: input_mesh
    character(256) :: input_solu
    character(256) :: output_mesh
  end type mesh_v3d
  
  interface init_mesh_v3d     ; module procedure mesh_v3d_init         ; end interface
  interface read_mesh_v3d     ; module procedure mesh_dg_read_mesh_v3d ; end interface

  public :: mesh_v3d
  public :: init_mesh_v3d
  public :: read_mesh_v3d

  
contains


  subroutine mesh_dg_Cut2D_To_Cut3D(ob2D)
    !-----------------------------------
    type(mesh_dg)               :: ob2D
    !-----------------------------------
    type(mesh_dg)               :: ob3D
    integer                     :: iAxis
    integer                     :: jAxis
    !-----------------------------------
    print '("Plane Mesh2D To Plane Mesh3D")'
    !    
    select case(ob2D%geo)
    case(2)
      ob3D%geo=3
      ob3D%mesh_name=trim(ob2D%mesh_name)//"3D.mesh"
      ob3D%prec=ob3D%prec
      ob3D%nvert=ob2D%nvert
      allocate(ob3D%vertx(3,ob3D%nvert)) ; ob3D%vertx(:,:)=0d0
      allocate(ob3D%mark (  ob3D%nvert)) ; ob3D%mark (  :)=ob2D%mark(:)

      iAxis=0
      do while( .not.(iAxis==1 .or. iAxis==2 .or. iAxis==3) )
        print '(3x,"Press 1 -> 2Dx -> 3Dx")'
        print '(3x,"Press 2 -> 2Dx -> 3Dy")'
        print '(3x,"Press 3 -> 2Dx -> 3Dz")'
        write(*,'(3x,"")',advance='no')
        read(*,*)iAxis
      enddo
      ob3D%vertx(iAxis,:)=ob2D%vertx(1,:)
      
      jAxis=0
      do while( .not.(jAxis==1 .or. jAxis==2 .or. jAxis==3) .or. jAxis==iAxis )
        print '(3x,"Press 1 -> 2Dy -> 3Dx")'
        print '(3x,"Press 2 -> 2Dy -> 3Dy")'
        print '(3x,"Press 3 -> 2Dy -> 3Dz")'
        write(*,'(3x,"")',advance='no')
        read(*,*)jAxis
      enddo
      ob3D%vertx(jAxis,:)=ob2D%vertx(2,:)
      !
      ob3D%nT4=0
      ob3D%nT3=ob2D%nT3 ; allocate(ob3D%trian(4,ob3D%nT3)) ; ob3D%trian(:,:)=ob2D%trian(:,:)
      ob3D%nL2=ob2D%nL2 ; allocate(ob3D%edges(3,ob3D%nL2)) ; ob3D%edges(:,:)=ob2D%edges(:,:)
      !
      call mesh_dg_write_mesh(ob=ob3D,skin=.true.)
      !
    case(3)
      print '("Treatment is not compatible with 3D Geometry")'
      stop
    end select

    return
  end subroutine mesh_dg_Cut2D_To_Cut3D


  subroutine mesh_dg_cylindric(ob)
    !-----------------------------------
    use M_libmesh5_api
    !-----------------------------------
    type(mesh_dg)               :: ob
    !-----------------------------------
    integer                     :: i
    integer                     :: iAxis
    
    type(mesh_dg)               :: mesh0
    type(mesh_dg)               :: mesh1

    real(8)     , allocatable   :: vertx(:,:)
    real(8)                     :: t0,t1
    character(256)              :: command
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Passing 3D-Carthesian to Cylindric Coordinates")')
    if( ob%geo==3 )then
      !
      write(*,'(3x,"1 -> Longitudinal axis is (xx'')")')
      write(*,'(3x,"2 -> Longitudinal axis is (yy'')")')
      write(*,'(3x,"3 -> Longitudinal axis is (zz'')")')
      write(*,'(3x,"")',advance='no')
      read(*,*)iAxis
      !
      mesh1%geo=2
      mesh1%nvert=ob%nvert
      allocate(mesh1%vertx(2,mesh1%nvert))
      allocate(mesh1%mark (  mesh1%nvert))
      mesh1%nH6=0
      mesh1%nT4=0
      mesh1%nQ4=0
      mesh1%nT3=0
      mesh1%nL2=0
      !
      allocate(vertx(3,ob%nvert))
      !
      !
      select case( iAxis )
      case(1) ; write(*,'(3x,"Mesh (xyz) -> (xr) ")')
        mesh1%mesh_name=trim(ob%mesh_name)//"_xr.mesh"
        mesh1%solu_name=trim(ob%mesh_name)//"_xr"

        !omp do
        do i=1,ob%nvert
          vertx(1,i)=sqrt(ob%vertx(2,i)*ob%vertx(2,i)+ob%vertx(3,i)*ob%vertx(3,i)) ! r
          vertx(2,i)=atan2(ob%vertx(2,i),ob%vertx(3,i))                            ! theta
          vertx(3,i)=ob%vertx(1,i)                                                 ! z
          !
          mesh1%vertx(1,i)=vertx(3,i)
          mesh1%vertx(2,i)=vertx(1,i)
        enddo
        !omp enddo  
      case(2) ; write(*,'(3x,"Mesh (xyz) -> (yr) ")')
        mesh1%mesh_name=trim(ob%mesh_name)//"_yr.mesh"
        mesh1%solu_name=trim(ob%mesh_name)//"_yr"

        !omp do
        do i=1,ob%nvert
          vertx(1,i)=sqrt(ob%vertx(3,i)*ob%vertx(3,i)+ob%vertx(1,i)*ob%vertx(1,i)) ! r
          vertx(2,i)=atan2(ob%vertx(3,i),ob%vertx(1,i))                            ! theta
          vertx(3,i)=ob%vertx(2,i)                                                 ! z
          !
          mesh1%vertx(1,i)=vertx(3,i)
          mesh1%vertx(2,i)=vertx(1,i)
        enddo
        !omp enddo  
      
      case(3) ; write(*,'(3x,"Mesh (xyz) -> (zr) ")')
        mesh1%mesh_name=trim(ob%mesh_name)//"_zr.mesh"
        mesh1%solu_name=trim(ob%mesh_name)//"_zr"

        !omp do
        do i=1,ob%nvert
          vertx(1,i)=sqrt(ob%vertx(1,i)*ob%vertx(1,i)+ob%vertx(2,i)*ob%vertx(2,i)) ! r
          vertx(2,i)=atan2(ob%vertx(1,i),ob%vertx(2,i))                            ! theta
          vertx(3,i)=ob%vertx(3,i)                                                 ! z
          !
          mesh1%vertx(1,i)=vertx(3,i)
          mesh1%vertx(2,i)=vertx(1,i)
        enddo
        !omp enddo        
      case default
      
      end select

      call write_mesh(mesh1,skin=.false.)
!exhaust_axi_flow_approachmm
      mesh0%mesh_name='../exhaust_axi/maillage4' ; call read_mesh(mesh0)
      mesh0%solu_name='../exhaust_axi/maillage4' ; call read_solu(mesh0)

      mesh1%nsol=mesh1%nvert
      mesh1%ker =mesh0%ker
      allocate(mesh1%solu(mesh1%ker,mesh1%nsol))

      call mesh_dg_interpolate_vert(mesh0,mesh1%vertx,mesh1%solu)

      ob%solu_name=trim(ob%mesh_name)//'.sol'
      ob%kind(1:3)=[1,1,2]
      ob%nsol=ob%nvert ; ob%nfld=3 ; ob%ker =mesh1%ker+1
      allocate(ob%solu(ob%ker,ob%nsol))    
      !
      !
      select case( iAxis )
      case(1) ; write(*,'(3x,"Solu (xr) -> (xyz)")')
        !omp do
        do i=1,ob%nvert
          ob%solu(1,i)=mesh1%solu(1,i)                         ! a0
          ob%solu(2,i)=mesh1%solu(2,i)                         ! rho0
          ob%solu(3,i)=mesh1%solu(3,i)                         ! u0
          ob%solu(4,i)=mesh1%solu(4,i)*sin( vertx(2,i) )       ! v0
          ob%solu(5,i)=mesh1%solu(4,i)*cos( vertx(2,i) )       ! w0
        enddo
        !omp enddo        
      case(2) ; write(*,'(3x,"Solu (yr) -> (xyz)")')
      case(3) ; write(*,'(3x,"Solu (zr) -> (xyz)")')
      end select
      !
      ! ecriture de la solution interpolŽe    
      
      call write_solu(ob)
    endif
    
    call cpu_time(t1)
    write(ob%nlog,'(/"End Passing 3D-Carthesian to Cylindric Coordinates - CPU",e12.5," s")')t1-t0

  end subroutine mesh_dg_cylindric

  subroutine mesh_dg_connected_mesh(ob,nCell)
    !-----------------------------------
    type(mesh_dg)         :: ob
    integer , allocatable :: nCell(:)
    !-----------------------------------
    real(8)               :: t0,t1
    integer               :: i,j,k,n
    integer               :: nvert
    real(8), allocatable  :: vertx(:,:)
    integer, allocatable  :: mark(:)
    integer               :: nH6
    integer, allocatable  :: hexas(:,:)
    integer               :: nT4
    integer, allocatable  :: tetra(:,:)
    integer               :: nQ4
    integer, allocatable  :: quadr(:,:)
    integer               :: nT3
    integer, allocatable  :: trian(:,:)
    integer               :: nL2
    integer, allocatable  :: edges(:,:)
    integer, allocatable  :: idx(:)
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Supressing unconnected Vertices")')
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    !
    allocate(nCell(10*ob%nvert)) ; nCell=0
    !
    if( ob%nH6/=0 )then
      write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
      !omp do
      forall(i=1:8,j=1:ob%nH6)nCell(ob%hexas(i,j))=nCell(ob%hexas(i,j))+1
      !omp enddo
    endif

    if( ob%nT4/=0 )then
      write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
      do j=1,ob%nT4
        do i=1,4
          k=ob%tetra(i,j)
          nCell(k)=nCell(k)+1
        enddo
      enddo

    endif

    if( ob%nQ4/=0 )then
      write(*,'(3x,"Initial Number of quads      ",i10 )')ob%nQ4
      !omp do
      forall(i=1:4,j=1:ob%nQ4)nCell(ob%quadr(i,j))=nCell(ob%quadr(i,j))+1
      !omp enddo
    endif

    if( ob%nT3/=0 )then
      write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
      !omp do
      forall(i=1:3,j=1:ob%nT3)nCell(ob%trian(i,j))=nCell(ob%trian(i,j))+1
      !omp enddo
    endif

    if( ob%nL2/=0 )then
      write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
      !omp do
      forall(i=1:2,j=1:ob%nL2)nCell(ob%edges(i,j))=nCell(ob%edges(i,j))+1
      !omp enddo
    endif

    write(*,'()')

    nvert=count(nCell/=0)
    if( nvert/=ob%nvert )then
      write(*,'(3x,"Supressing Vertices without any Cell=",i10)')count(nCell==0)
      allocate(idx(ob%nvert)) ; idx=0
      allocate(vertx(size(ob%vertx,1),nvert))
      allocate(mark (                 nvert))

      j=0
      do i=1,ob%nvert
        if(nCell(i)/=0 )then
          j=j+1
          idx(i)=j
          vertx(:,j)=ob%vertx(:,i)
          mark (  j)=ob%mark (  i)
        endif
      enddo

      ob%nvert=nvert
      call move_alloc(vertx, ob%vertx)
      call move_alloc(mark , ob%mark )

      if( ob%nH6/=0 )then
        allocate(hexas(8,ob%nH6))
        forall(i=1:8,j=1:ob%nH6)hexas(i,j)=idx(ob%hexas(i,j))
        hexas(9,:)=ob%hexas(9,:)
        call move_alloc(hexas, ob%hexas)
      endif

      if( ob%nT4/=0 )then
        allocate(tetra(5,ob%nT4))
        forall(i=1:4,j=1:ob%nT4)tetra(i,j)=idx(ob%tetra(i,j))
        tetra(5,:)=ob%tetra(5,:)
        call move_alloc(tetra, ob%tetra)
      endif

      if( ob%nQ4/=0 )then
        allocate(quadr(5,ob%nQ4))
        forall(i=1:4,j=1:ob%nQ4)quadr(i,j)=idx(ob%quadr(i,j))
        quadr(5,:)=ob%quadr(5,:)
        call move_alloc(quadr, ob%quadr)
      endif

      if( ob%nT3/=0 )then
        allocate(trian(4,ob%nT3))
        forall(i=1:3,j=1:ob%nT3)trian(i,j)=idx(ob%trian(i,j))
        trian(4,:)=ob%trian(4,:)
        call move_alloc(trian, ob%trian)
      endif

      if( ob%nL2/=0 )then
        allocate(edges(3,ob%nL2))
        forall(i=1:2,j=1:ob%nL2)edges(i,j)=idx(ob%edges(i,j))
        edges(3,:)=ob%edges(3,:)
        call move_alloc(edges, ob%edges)
      endif

    endif

    deallocate(idx)

    write(*,'(/3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob%nH6

    if( ob%nT4/=0 )then
      write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
      do i=1,100
        n=count(ob%tetra(5,:)==i)
        if( n/=0 )write(*,'(6x,"Tetra marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob%nQ4

    if( ob%nT3/=0 )then
      write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
      do i=1,100
        n=count(ob%trian(4,:)==i)
        if( n/=0 )write(*,'(6x,"Trian marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10/)')ob%nL2

    call cpu_time(t1)
    write(ob%nlog,'("End Supressing unconnected Vertices - CPU =",e12.5," s")')t1-t0
    
  end subroutine mesh_dg_connected_mesh

  subroutine mesh_dg_connected_solu(ob,nCell)
    !-----------------------------------
    type(mesh_dg)         :: ob
    integer, allocatable  :: nCell(:)
    !-----------------------------------
    real(8)               :: t0,t1
    integer               :: i,j,n
    integer               :: nsol
    real(8), allocatable  :: solu(:,:)
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Supressing unconnected Solutions")')
    write(*,'(3x,"Initial Number of solutions: ",i10 )')ob%nsol

    write(*,'()')

    nsol=ob%nvert
    if( nsol/=ob%nsol )then
      allocate(solu(size(ob%solu,1),nsol))

      j=0
      do i=1,ob%nsol
        if(nCell(i)/=0 )then
          j=j+1
          solu (:,j)=ob%solu (:,i)
        endif
      enddo

      ob%nsol=nsol
      call move_alloc(solu,ob%solu)
    endif

    write(*,'( 3x,"Final   Number of solutions: ",i10 )')ob%nsol

    call cpu_time(t1)
    write(ob%nlog,'("End Supressing unconnected Solutions - CPU =",e12.5," s")')t1-t0
    
  end subroutine mesh_dg_connected_solu

  subroutine mesh_dg_control_cells(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    select case(ob%geo)
    case(2) ; call mesh_dg_control_trian(ob)
    case(3) ; call mesh_dg_control_tetra2(ob)
    end select
  end subroutine mesh_dg_control_cells

  subroutine mesh_dg_control_tetra(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    real(8)               :: t0,t1
    integer               :: i,n1,n2,n3
    real(8)               :: vec12(3),vec13(3),vec14(3)
    real(8) , allocatable :: det(:)
    integer               :: nT4
    integer , allocatable :: tetra(:,:)
    !------------------------------------------------
    if( ob%nT4/=0 )then
      call cpu_time(t0)
      write(ob%nlog,'(/"Controling Tetrahedra")')
      write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
      allocate(det(ob%nT4))
      !omp do
      do i=1,ob%nT4
        vec12=[ ob%vertx(1,ob%tetra(2,i))-ob%vertx(1,ob%tetra(1,i)),&
        &       ob%vertx(2,ob%tetra(2,i))-ob%vertx(2,ob%tetra(1,i)),&
        &       ob%vertx(3,ob%tetra(2,i))-ob%vertx(3,ob%tetra(1,i)) ]

        vec13=[ ob%vertx(1,ob%tetra(3,i))-ob%vertx(1,ob%tetra(1,i)),&
        &       ob%vertx(2,ob%tetra(3,i))-ob%vertx(2,ob%tetra(1,i)),&
        &       ob%vertx(3,ob%tetra(3,i))-ob%vertx(3,ob%tetra(1,i)) ]

        vec14=[ ob%vertx(1,ob%tetra(4,i))-ob%vertx(1,ob%tetra(1,i)),&
        &       ob%vertx(2,ob%tetra(4,i))-ob%vertx(2,ob%tetra(1,i)),&
        &       ob%vertx(3,ob%tetra(4,i))-ob%vertx(3,ob%tetra(1,i)) ]

        det(i)= vec12(1)*(vec13(2)*vec14(3)-vec14(2)*vec13(3)) &
        &      -vec12(2)*(vec13(1)*vec14(3)-vec14(1)*vec13(3)) &
        &      +vec12(3)*(vec13(1)*vec14(2)-vec14(1)*vec13(2))
      enddo
      !omp enddo
      !
      n1=count(det==0.)
      n2=count(det>0.)
      n3=ob%nT4-n1-n2

      write(*,'(6x,"Tetrahedra with jacobian=0 (to eliminate):     ",i10 )')n1
      write(*,'(6x,"Tetrahedra with jacobian>0 (good orientation): ",i10 )')n2
      write(*,'(6x,"Tetrahedra with jacobian<0 (bad orientation):  ",i10 )')n3
      allocate(tetra(5,ob%nT4-n1))    
      !
      nT4=0
      do i=1,ob%nT4
        if( det(i)>0. )then
          nT4=nT4+1
          tetra(:,nT4)=ob%tetra(:,i)
        elseif( det(i)<0. )then
          nT4=nT4+1
          tetra(1,nT4)=ob%tetra(1,i)
          tetra(2,nT4)=ob%tetra(3,i)
          tetra(3,nT4)=ob%tetra(2,i)
          tetra(4,nT4)=ob%tetra(4,i)
          tetra(5,nT4)=ob%tetra(5,i)
        endif
      enddo

      deallocate(det)
      ob%nT4=nT4 ; call move_alloc(tetra, ob%tetra) 
      call cpu_time(t1)
      if( ob%nT4/=0 )write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
      write(ob%nlog,'("End Controling Tetrahedra - CPU =",e12.5," s")')t1-t0
    endif
  end subroutine mesh_dg_control_tetra


  subroutine mesh_dg_control_tetra2(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    real(8)               :: t0,t1
    integer               :: i,j,n1,n2,n3
    real(8)               :: vec12(3),vec13(3),vec14(3)
    real(8) , allocatable :: det(:)
    integer               :: nT4
    integer , allocatable :: tetra(:,:)

    logical , allocatable :: ins(:)
    integer , allocatable :: idx(:)
    integer               :: nvert
    real(8) , allocatable :: vertx(:,:)
    integer , allocatable :: mark(:)
    integer , allocatable :: tetra1(:,:)
    !------------------------------------------------
    if( ob%nT4/=0 )then
      call cpu_time(t0)
      write(ob%nlog,'(/"Controling Tetrahedra")')
      write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
      if( ob%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4

      allocate(det(ob%nT4))
      !omp do
      do i=1,ob%nT4
        vec12=[ ob%vertx(1,ob%tetra(2,i))-ob%vertx(1,ob%tetra(1,i)),&
        &       ob%vertx(2,ob%tetra(2,i))-ob%vertx(2,ob%tetra(1,i)),&
        &       ob%vertx(3,ob%tetra(2,i))-ob%vertx(3,ob%tetra(1,i)) ]

        vec13=[ ob%vertx(1,ob%tetra(3,i))-ob%vertx(1,ob%tetra(1,i)),&
        &       ob%vertx(2,ob%tetra(3,i))-ob%vertx(2,ob%tetra(1,i)),&
        &       ob%vertx(3,ob%tetra(3,i))-ob%vertx(3,ob%tetra(1,i)) ]

        vec14=[ ob%vertx(1,ob%tetra(4,i))-ob%vertx(1,ob%tetra(1,i)),&
        &       ob%vertx(2,ob%tetra(4,i))-ob%vertx(2,ob%tetra(1,i)),&
        &       ob%vertx(3,ob%tetra(4,i))-ob%vertx(3,ob%tetra(1,i)) ]

        det(i)= vec12(1)*(vec13(2)*vec14(3)-vec14(2)*vec13(3)) &
        &      -vec12(2)*(vec13(1)*vec14(3)-vec14(1)*vec13(3)) &
        &      +vec12(3)*(vec13(1)*vec14(2)-vec14(1)*vec13(2))
      enddo
      !omp enddo
      !
      n1=count(det==0.)
      n2=count(det> 0.)
      n3=ob%nT4-n1-n2
      write(*,'(6x,"Tetrahedra with jacobian=0 (to eliminate): ",i10 )')n1
      write(*,'(6x,"Tetrahedra with jacobian>0 (good tetra):   ",i10 )')n2
      write(*,'(6x,"Tetrahedra with jacobian<0 (bad tetra):    ",i10 )')n3

     !allocate(tetra(5,ob%nT4-n1))    
     !allocate(tetra(5,n2))    
      !

      if( ob%nT4==n3 )then
        nT4=ob%nT4
        allocate(tetra(5,nT4))    
        do i=1,ob%nT4
          tetra(1,i)=ob%tetra(1,i)
          tetra(2,i)=ob%tetra(3,i)
          tetra(3,i)=ob%tetra(2,i)
          tetra(4,i)=ob%tetra(4,i)
          tetra(5,i)=ob%tetra(5,i)
        enddo
      else
        allocate(tetra(5,n2))    
        nT4=0
        do i=1,ob%nT4
          if( det(i)>0. )then
            nT4=nT4+1
            tetra(:,nT4)=ob%tetra(:,i)
          !elseif( det(i)<0. )then
          !  nT4=nT4+1
          !  tetra(1,nT4)=ob%tetra(1,i)
          !  tetra(2,nT4)=ob%tetra(3,i)
          !  tetra(3,nT4)=ob%tetra(2,i)
          !  tetra(4,nT4)=ob%tetra(4,i)
          !  tetra(5,nT4)=ob%tetra(5,i)
          endif
        enddo
      endif
      deallocate(det)
      ob%nT4=nT4 ; call move_alloc(tetra, ob%tetra) 

      allocate(ins(ob%nvert))
      ins=.false.
      !
      !omp do
      do i=1,ob%nT4
        do j=1,4
          ins(ob%tetra(j,i))=.true.
        enddo
      enddo
      !omp enddo

      nvert=count(ins)

      allocate(vertx(3,nvert))
      allocate(mark (  nvert))
      allocate(idx(ob%nvert))

      nvert=0
      do i=1,ob%nvert
        if( ins(i) )then
          nvert=nvert+1
          vertx(:,nvert)=ob%vertx(:,i)
          mark (  nvert)=ob%mark (  i)
          idx  (  i)=nvert
        endif
      enddo

      ob%nvert=nvert
      call move_alloc(vertx, ob%vertx) 
      call move_alloc(mark , ob%mark ) 
      deallocate(ins)

      nT4=ob%nT4 ; allocate(tetra(5,nT4))
      do i=1,nT4
        tetra(1:5,i)=[ idx(ob%tetra(1,i)),&
        &              idx(ob%tetra(2,i)),&
        &              idx(ob%tetra(3,i)),&
        &              idx(ob%tetra(4,i)),&
        &                  ob%tetra(5,i)  ]     
      enddo

      ob%nT4=nT4 ; call move_alloc(tetra, ob%tetra) 

      call cpu_time(t1)
      write(*,'( 3x,"Final   Number of vertices:  ",i10 )')ob%nvert
      if( ob%nT4/=0 )write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
      write(ob%nlog,'("End Controling Tetrahedra - CPU =",e12.5," s")')t1-t0
    endif
  end subroutine mesh_dg_control_tetra2


  subroutine mesh_dg_control_trian(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    real(8)               :: t0,t1
    integer               :: i,j,n1,n2,n3
    real(8)               :: vec12(2),vec13(2)
    real(8) , allocatable :: det(:)
    integer               :: nvert
    real(8) , allocatable :: vertx(:,:)
    integer , allocatable :: idx0(:),idx1(:)
    integer               :: nT3
    integer , allocatable :: trian(:,:)
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Controling Triangles")')
    write(*,'( 3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    if( ob%nT3/=0 )write(*,'(3x,"Initial Number of triangles ",i10 )')ob%nT3

    allocate(det(ob%nT3))
    !omp do
    do i=1,ob%nT3
      vec12=[ ob%vertx(1,ob%trian(2,i))-ob%vertx(1,ob%trian(1,i)),&
      &       ob%vertx(2,ob%trian(2,i))-ob%vertx(2,ob%trian(1,i)) ]
      !
      vec13=[ ob%vertx(1,ob%trian(3,i))-ob%vertx(1,ob%trian(1,i)),&
      &       ob%vertx(2,ob%trian(3,i))-ob%vertx(2,ob%trian(1,i)) ]
      !
      det(i)=vec12(1)*vec13(2)-vec13(1)*vec12(2)
    enddo
    !omp enddo
    !
    n1=count(det==0.)
    n2=count(det>0.)
    n3=ob%nT3-n1-n2

    write(*,'(6x,"Triangles with jacobian=0 (to eliminate):     ",i10 )')n1
    write(*,'(6x,"Triangles with jacobian>0 (good orientation): ",i10 )')n2
    write(*,'(6x,"Triangles with jacobian<0 (bad orientation):  ",i10 )')n3
    allocate(trian(4,ob%nT3-n1))
    !
    nT3=0
    do i=1,ob%nT3
      if( det(i)>0. )then
        nT3=nT3+1
        trian(:,nT3)=ob%trian(:,i)
      elseif( det(i)<0. )then
        nT3=nT3+1
        trian(1,nT3)=ob%trian(1,i)
        trian(2,nT3)=ob%trian(3,i)
        trian(3,nT3)=ob%trian(2,i)
        trian(4,nT3)=ob%trian(4,i)
      endif
    enddo
    deallocate(det)
    ob%nT3=nT3 ; call move_alloc(trian, ob%trian) 

    nvert=0
    allocate(idx0(ob%nvert)) ; idx0=0
    allocate(idx1(ob%nvert))

    do i=1,ob%nT3
      do j=1,3
        if( idx0(ob%trian(j,i))==0 )then
          nvert=nvert+1
          idx0(ob%trian(j,i))=nvert
          idx1(nvert)=ob%trian(j,i)
        endif
      enddo
    enddo
    
    allocate(vertx(ob%geo,nvert))
    do i=1,nvert
      vertx(:,i)=ob%vertx(:,idx1(i))
    enddo
    ob%nvert=nvert ; call move_alloc(vertx, ob%vertx) 


    nT3=ob%nT3
    allocate(trian(4,ob%nT3))
    do i=1,ob%nT3
      do j=1,3
        trian(j,i)=idx0(ob%trian(j,i))
      enddo
      trian(4,i)=ob%trian(4,i)
    enddo
    ob%nT3=nT3 ; call move_alloc(trian, ob%trian) 
        
        
    deallocate(idx0,idx1)

    call cpu_time(t1)
    write(*,'( 3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    if( ob%nT3/=0 )write(*,'(3x,"Final   Number of triangles ",i10 )')ob%nT3
    write(ob%nlog,'("End Controling Triangles - CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_control_trian

  subroutine mesh_dg_compare_meshes(ob1,ob2,same)
    !-----------------------------------
    type(mesh_dg), intent(in)        :: ob1,ob2
    logical      , intent(out)       :: same
    !-----------------------------------
    real(8)                          :: t0,t1
    integer                          :: i,j
    real(8)                          :: dx
    real(8)      , allocatable       :: min(:),av0(:),av1(:),av2(:),max(:)
    real(8)      , parameter         :: eps=1d-4
    !-----------------------------------
    call cpu_time(t0)
    write(ob1%nlog,'(/"comparing Mesh")')

    same=(ob1%geo==ob2%geo .and. ob1%nvert==ob2%nvert)
    if( same )then
      loop_mesh : do i=1,ob1%nvert
        do j=1,ob1%geo
          if( .not.(ob1%vertx(j,i)==ob2%vertx(j,i)) )then
            same=.false.
            return
          endif
        enddo
      enddo loop_mesh
    endif
    
    same=(ob1%ker==ob2%ker)
    if( same .and. allocated(ob1%solu) .and. allocated(ob2%solu) )then
      allocate(av0(ob1%ker)) ; av0= 0d00
      allocate(av1(ob1%ker)) ; av1= 0d00
      allocate(av2(ob1%ker)) ; av2= 0d00
      allocate(min(ob1%ker)) ; min= 1d10
      allocate(max(ob1%ker)) ; max=-1d10
      !omp do
      loop_solu : do i=1,ob1%nvert
        do j=1,ob1%ker
          dx=abs(ob1%solu(j,i)-ob2%solu(j,i))
          av0(j)=av0(j)+abs(ob1%solu(j,i))
          av1(j)=av1(j)+dx
          av2(j)=av2(j)+dx*dx
          if( dx<min(j) )min(j)=dx
          if( dx>max(j) )max(j)=dx
        enddo      
      enddo loop_solu
      !omp enddo

      av0=av0/ob1%nvert
      av1=av1/ob1%nvert
      av2=av2/ob1%nvert
 
      do j=1,ob1%ker
        write(ob1%nlog,'(3x,"Component=",i3," - Sum( |sol1| )/n =",e12.5)')j,av0(j)
        write(ob1%nlog,'(6x,"min( |sol1-sol2|  )   =",e12.5)')min(j)
        write(ob1%nlog,'(6x,"max( |sol1-sol2|  )   =",e12.5)')max(j)
        write(ob1%nlog,'(6x,"Sum( |sol1-sol2|  )/n =",e12.5)')av1(j)
        write(ob1%nlog,'(6x,"Sum( |sol1-sol2|^2)/n =",e12.5)')av2(j)
        if( abs(min(j))/abs(av0(j)) >eps ) same=.false.
        if( abs(max(j))/abs(av0(j)) >eps ) same=.false.
      enddo
      !
      if( same )then
        write(ob1%nlog,'(/6x,"Good Agreement !"/)')
      endif
      !
      deallocate(av0)
      deallocate(av1)
      deallocate(av2)
      deallocate(min)
      deallocate(max)
    endif
    !
    call cpu_time(t1)
    write(ob1%nlog,'("End comparing Mesh - CPU =",e12.5,"s"/)')t1-t0    
  end subroutine mesh_dg_compare_meshes

  subroutine mesh_dg_create_box(ob)
    !------------------------------------------------
   !use m_libmesh4
    use M_libmesh5_api
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    real(8)               :: t0,t1
    integer               :: geo
    real(8)               :: xmin,ymin,zmin
    real(8)               :: xmax,ymax,zmax
    character(256)        :: name
    integer               :: i
    integer               :: nvert
    real(8), allocatable  :: vertx(:,:)
    integer, allocatable  :: mark (:)
    integer               :: nL2
    integer, allocatable  :: edges(:,:)
    integer               :: nT3
    integer, allocatable  :: trian(:,:)
    integer               :: nQ4
    integer, allocatable  :: quadr(:,:)
    integer               :: out
    integer               :: res
    integer               :: ver
    integer , allocatable :: TypTab(:)
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Creating Box")')

    write(ob%nlog,'(3x,"Enter 2 for 2D Box")')
    write(ob%nlog,'(3x,"Enter 3 for 3D Box")')
    write(*,'(3x,"")',advance='no')
    read(*,*)geo
    
    select case( geo )
    case(2)
      write(ob%nlog,'(3x,"Enter xmin,ymin,xmax,ymax")')
      write(*,'(3x,"")',advance='no')
      read(*,*)xmin,ymin,xmax,ymax

      nvert=4
      allocate(vertx(geo,nvert),mark(nvert))
      vertx(1:2,1)=[xmin,ymin] ; mark(1)=0
      vertx(1:2,2)=[xmin,ymax] ; mark(2)=0
      vertx(1:2,3)=[xmax,ymax] ; mark(3)=0
      vertx(1:2,4)=[xmax,ymin] ; mark(4)=0

      nT3=2
      allocate(trian(4,nT3))
      trian(1:4,1)=[1,2,3, 0]
      trian(1:4,2)=[3,4,1, 0]

      nL2=4
      allocate(edges(3,nL2))
      edges(1:3,1)=[1,2, 11]
      edges(1:3,2)=[2,3, 12]
      edges(1:3,3)=[3,4, 13]
      edges(1:3,4)=[4,1, 14]

      ! >>> libmesh5 >>>
      name="box.mesh" ; ver=2
      out=GmfOpenMeshF77(trim(name),GmfWrite,ver,geo)
      if( nvert/=0 )then
        !
        res=gmfsetkwdf77(        &
        &   MshIdx=out          ,&
        &   KwdIdx=GmfVertices  ,&
        &   NmbLin=nvert        ,&
        &   NmbTyp=0            ,&
        &   TypTab=TypTab        )
        !
        do i=1,nvert
          call GmfSetVertex2Dr8(out,vertx(1,i),vertx(2,i),mark(i))
        enddo
      endif
      if( nT3/=0 )then
        res=GmfSetKwdF77(out,GmfTriangles,nT3,ver,TypTab)
        do i=1,nT3
          call GmfSetTriangle(out,trian(1,i),trian(2,i),trian(3,i),trian(4,i))
        enddo      
      endif
      if( nL2/=0 )then
        res=GmfSetKwdF77(out,GmfEdges,nL2,ver,TypTab)
        do i=1,nL2
          call GmfSetEdge(out,edges(1,i),edges(2,i),edges(3,i))
        enddo      
      endif
      res=GmfCloseMeshf77(out)


      deallocate(vertx,trian,edges,mark)

    case(3)
      write(ob%nlog,'(3x,"Enter xmin,ymin,zmin,xmax,ymax,zmax")')
      write(*,'(3x,"")',advance='no')
      read(*,*)xmin,ymin,zmin,xmax,ymax,zmax

      nvert=8
      allocate(vertx(geo,nvert),mark(nvert))
      vertx(1:3,1)=[xmin,ymin,zmin] ; mark(1)=0
      vertx(1:3,2)=[xmin,ymax,zmin] ; mark(2)=0
      vertx(1:3,3)=[xmax,ymax,zmin] ; mark(3)=0
      vertx(1:3,4)=[xmax,ymin,zmin] ; mark(4)=0
      vertx(1:3,5)=[xmin,ymin,zmax] ; mark(5)=0
      vertx(1:3,6)=[xmin,ymax,zmax] ; mark(6)=0
      vertx(1:3,7)=[xmax,ymax,zmax] ; mark(7)=0
      vertx(1:3,8)=[xmax,ymin,zmax] ; mark(8)=0

      nQ4=6
      allocate(quadr(5,nQ4))
      quadr(1:5,1)=[1,2,3,4, 11]
      quadr(1:5,2)=[5,8,7,6, 12]
      quadr(1:5,3)=[1,4,8,5, 13]
      quadr(1:5,4)=[2,6,7,3, 14]
      quadr(1:5,5)=[3,7,8,4, 15]
      quadr(1:5,6)=[1,2,6,5, 16]

      ! >>> libmesh5 >>>
      name="box.mesh" ; ver=2
      out=GmfOpenMeshF77(trim(name),GmfWrite,ver,geo)
      res=GmfSetKwdF77(out,GmfVertices,nvert,0,TypTab)
      if( nvert/=0 )then
        do i=1,nvert
          call gmfSetVertex3Dr8(out,vertx(1,i),vertx(2,i),vertx(3,i),mark(i))
        enddo
      endif
      if( nQ4/=0 )then
        res=GmfSetKwdF77(out,GmfQuadrilaterals,nQ4,ver,TypTab)
        do i=1,nQ4
          call GmfSetQuadrilateral(out,quadr(1,i),quadr(2,i),quadr(3,i),quadr(4,i),quadr(5,i))
        enddo      
      endif
      if( nT3/=0 )then
        res=GmfSetKwdF77(out,GmfTriangles,nT3,ver,TypTab)
        do i=1,nT3
          call GmfSetTriangle(out,trian(1,i),trian(2,i),trian(3,i),trian(4,i))
        enddo      
      endif
      res = GmfCloseMeshf77(out)
      ! <<< libmesh5 <<<

      deallocate(vertx,quadr,mark)

    case default
    
      write(*,'(3x,"Choice ",i2," Not possible - Box Not Created")')geo
    
    end select
    !
    call cpu_time(t1)
    write(ob%nlog,'("End Creating Box - CPU =",e12.5," s")')t1-t0

  end subroutine mesh_dg_create_box

  subroutine mesh_dg_cut_mesh(ob,inside)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    logical , allocatable :: inside(:)
    !------------------------------------------------
    real(8)               :: t0,t1
    integer               :: i,j,mem,n
    integer               :: nt,nv
    real(8)               :: xmin,xmax
    real(8)               :: ymin,ymax
    real(8)               :: zmin,zmax
    integer, allocatable  :: idx(:)
    real(8), allocatable  :: vertx(:,:)
    integer, allocatable  :: trian(:,:)
    integer, allocatable  :: tetra(:,:)
    integer, allocatable  :: mark (:)
    logical               :: test
    integer               :: nd(3)
    real(8)               :: x(3),y(3)
    logical , allocatable :: cell_inside(:)
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Cutting ",i1,"D Mesh")'),ob%geo
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
    !
    if( ob%nQ4/=0 .or. ob%nH6/=0 )then
      write(*,*)"cut not implement for quadr or hexa"
      write(*,*)"stop @ mesh_dg_cut_mesh"
      stop 
    endif
    !
    write(*,'(3x,"New BoundingBox")')

    select case(ob%geo)
    case(2)
      write(*,'(3x,"xmin,ymin,xmax,ymax")')
      write(*,'(3x,"")',advance='no')
      read(*,*)xmin,ymin,xmax,ymax
      !
!      !omp do
!      do i=1,ob%nvert
!        if( ob%vertx(1,i)<xmin )ob%vertx(1,i)=xmin
!        if( ob%vertx(2,i)<ymin )ob%vertx(2,i)=ymin
!        if( ob%vertx(1,i)>xmax )ob%vertx(1,i)=xmax
!        if( ob%vertx(2,i)>ymax )ob%vertx(2,i)=ymax
!      enddo
!      !omp enddo
!      return

      allocate(inside(ob%nvert))
      !omp do
      do i=1,ob%nvert
        if(      xmin<=ob%vertx(1,i) .and. ob%vertx(1,i)<=xmax &
        &  .and. ymin<=ob%vertx(2,i) .and. ob%vertx(2,i)<=ymax )then
          inside(i)=.true.
        else
          inside(i)=.false.
        endif
      enddo
      !omp enddo

      !
      allocate(cell_inside(ob%nT3))
      nt=0
      !omp do
      do i=1,ob%nT3
        if(    inside(ob%trian(1,i)) &
        &  .or.inside(ob%trian(2,i)) &
        &  .or.inside(ob%trian(3,i)) )then
          nt=nt+1
          cell_inside(i)=.true.
        else
          cell_inside(i)=.false.        
        endif
      enddo
      !omp enddo
      
      allocate(trian(4,nt)) ; nt=0
      do i=1,ob%nT3
        if( cell_inside(i) )then
          nt=nt+1 ; trian(1:4,nt)=ob%trian(1:4,i)
        endif
      enddo
      deallocate(cell_inside)

      !omp do
      do j=1,nt
        do i=1,3
          if( .not.inside(trian(i,j)) )then
            if( ob%vertx(1,trian(i,j))<xmin )ob%vertx(1,trian(i,j))=xmin
            if( ob%vertx(2,trian(i,j))<ymin )ob%vertx(2,trian(i,j))=ymin
            if( ob%vertx(1,trian(i,j))>xmax )ob%vertx(1,trian(i,j))=xmax
            if( ob%vertx(2,trian(i,j))>ymax )ob%vertx(2,trian(i,j))=ymax
            inside(trian(i,j))=.true.
          endif
        enddo
      enddo
      !omp enddo

      nv=count(inside)

      allocate(vertx(2,nv),mark(nv))
      allocate(idx(ob%nvert))
      nv=0
      do i=1,ob%nvert
        if( inside(i) )then
          nv=nv+1
          idx(i)=nv
          vertx(1:2,nv)=ob%vertx(1:2,i)
          mark (    nv)=ob%mark (    i)
        endif
      enddo

      do i=1,nt
        trian(1:4,i)=[idx(trian(1,i)),&
        &             idx(trian(2,i)),&
        &             idx(trian(3,i)),&
        &             idx(trian(4,i)) ]
      enddo

      ob%nvert=nv ; call move_alloc(vertx, ob%vertx) ; call move_alloc(mark , ob%mark )
      ob%nT3  =nt ; call move_alloc(trian, ob%trian) ; deallocate(idx)
     !ob%nL2=0    ; if( allocated(ob%edges) )deallocate(ob%edges)
      
    case(3)

      write(*,'(3x,"xmin,ymin,zmin,xmax,ymax,zmax")')
      write(*,'(3x,"")',advance='no')
      read(*,*)xmin,ymin,zmin,xmax,ymax,zmax
      !
     !do i=1,ob%nvert
     !  if( ob%vertx(1,i)<xmin )ob%vertx(1,i)=xmin
     !  if( ob%vertx(2,i)<ymin )ob%vertx(2,i)=ymin
     !  if( ob%vertx(3,i)<zmin )ob%vertx(3,i)=zmin
     !  if( ob%vertx(1,i)>xmax )ob%vertx(1,i)=xmax
     !  if( ob%vertx(2,i)>ymax )ob%vertx(2,i)=ymax
     !  if( ob%vertx(3,i)>zmax )ob%vertx(3,i)=zmax
     !enddo
     !return

      allocate(inside(ob%nvert))
      !omp do
      do i=1,ob%nvert
        if(     (xmin<=ob%vertx(1,i).and.ob%vertx(1,i)<=xmax) &
        &  .and.(ymin<=ob%vertx(2,i).and.ob%vertx(2,i)<=ymax) &
        &  .and.(zmin<=ob%vertx(3,i).and.ob%vertx(3,i)<=zmax) )then
          inside(i)=.true.
        else
          inside(i)=.false.
        endif
      enddo
      !omp enddo
      !
      allocate(cell_inside(ob%nT4))
      nt=0
      !omp do
      do i=1,ob%nT4
        if(    inside(ob%tetra(1,i)) &
        &  .or.inside(ob%tetra(2,i)) &
        &  .or.inside(ob%tetra(3,i)) &
        &  .or.inside(ob%tetra(4,i)) )then
          nt=nt+1
          cell_inside(i)=.true.
        else
          cell_inside(i)=.false.
        endif
      enddo
      !omp enddo

      allocate(tetra(5,nt)) ; nt=0
      do i=1,ob%nT4
        if( cell_inside(i) )then
          nt=nt+1 ; tetra(1:5,nt)=ob%tetra(1:5,i)
        endif
      enddo
      deallocate(cell_inside)

      !omp do
      do j=1,nt
        do i=1,4
          if( .not.inside(tetra(i,j)) )then
           !if( ob%vertx(1,tetra(i,j))<xmin )ob%vertx(1,tetra(i,j))=xmin
           !if( ob%vertx(2,tetra(i,j))<ymin )ob%vertx(2,tetra(i,j))=ymin
           !if( ob%vertx(3,tetra(i,j))<zmin )ob%vertx(3,tetra(i,j))=zmin
           !if( ob%vertx(1,tetra(i,j))>xmax )ob%vertx(1,tetra(i,j))=xmax
           !if( ob%vertx(2,tetra(i,j))>ymax )ob%vertx(2,tetra(i,j))=ymax
           !if( ob%vertx(3,tetra(i,j))>zmax )ob%vertx(3,tetra(i,j))=zmax
            inside(tetra(i,j))=.true.
          endif
        enddo
      enddo
      !omp enddo

      nv=count(inside)
      allocate(vertx(3,nv),mark(nv))
      allocate(idx(ob%nvert))
      nv=0
      do i=1,ob%nvert
        if( inside(i) )then
          nv=nv+1
          idx(i)=nv
          vertx(1:3,nv)=ob%vertx(1:3,i)
          mark (    nv)=ob%mark (    i)
        endif
      enddo

      do i=1,nt
        tetra(1:4,i)=[idx(tetra(1,i)),&
        &             idx(tetra(2,i)),&
        &             idx(tetra(3,i)),&
        &             idx(tetra(4,i)) ]
      enddo

      ob%nvert=nv ; call move_alloc(vertx, ob%vertx) ; call move_alloc(mark , ob%mark )
      ob%nT4  =nt ; call move_alloc(tetra, ob%tetra) ; deallocate(idx)
!     ob%nT3=0    ; if( allocated(ob%trian) )deallocate(ob%trian)
!     ob%nL2=0    ; if( allocated(ob%edges) )deallocate(ob%edges)
    end select

    call cpu_time(t1)
    write(*,'( 3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )then
      write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
      do i=1,100
        n=count(ob%tetra(5,:)==i)
        if( n/=0 )write(*,'(6x,"Tetra marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob%nQ4

    if( ob%nT3/=0 )then
      write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
      do i=1,100
        n=count(ob%trian(4,:)==i)
        if( n/=0 )write(*,'(6x,"Trian marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10 )')ob%nL2
    write(ob%nlog,'("End Cutting Mesh - CPU =",e12.5,"s")')t1-t0    
  end subroutine mesh_dg_cut_mesh

  subroutine mesh_dg_cut_solu(ob,inside)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    logical , allocatable :: inside(:)
    !------------------------------------------------
    integer               :: i,nv
    real(8), allocatable  :: solu(:,:)
    !------------------------------------------------
    nv=count(inside)
    allocate(solu(ob%ker,nv))
    nv=0
    do i=1,ob%nsol
      if( inside(i) )then
        nv=nv+1
        solu(:,nv)=ob%solu(:,i)
      endif
    enddo
    ob%nsol =nv
    call move_alloc(solu,ob%solu)
  end subroutine mesh_dg_cut_solu

  subroutine mesh_dg_delete(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    ob%geo=0
    ob%ker=0
    if( allocated(ob%vertx) )deallocate(ob%vertx) ; ob%nvert=0
    if( allocated(ob%mark ) )deallocate(ob%mark )
    if( allocated(ob%hexas) )deallocate(ob%hexas) ; ob%nH6=0
    if( allocated(ob%tetra) )deallocate(ob%tetra) ; ob%nT4=0
    if( allocated(ob%quadr) )deallocate(ob%quadr) ; ob%nQ4=0
    if( allocated(ob%trian) )deallocate(ob%trian) ; ob%nT3=0
    if( allocated(ob%edges) )deallocate(ob%edges) ; ob%nL2=0
    if( allocated(ob%norms) )deallocate(ob%norms)
    if( allocated(ob%metri) )deallocate(ob%metri)
    if( allocated(ob%solu ) )deallocate(ob%solu ) ; ob%nsol=0
  end subroutine mesh_dg_delete

  subroutine mesh_dg_gradient_set(ob)
    use m_vtk, only: writeVtkASCII
    !-----------------------------------
    type(mesh_dg) :: ob
    !-----------------------------------
    real(8)               :: t0,t1
    integer               :: ad,j,k
    type(T3)              :: eT3
    type(jacob2D)         :: j2D
    real(8)               :: dndx(3),dndy(3),u0(3),v0(3)
    real(8)               :: dx_u0,dy_u0
    real(8)               :: dx_v0,dy_v0
    real(8) , allocatable :: solu(:,:)
    integer , allocatable :: kind(:)
    character(256)        :: file
    !-----------------------------------
    call cpu_time(t0)
    write(*,'(/"Computing Gradient")')

    file='Flow_gradient.vtk'
    select case(ob%geo)
    case(2)
      write(*,'(3x,"Initial vaiables")')
      do j=1,ob%ker
        write(*,'(6x,"min/max    var",i1,": ",2e12.5)')j,minval(ob%solu(j,:)),maxval(ob%solu(j,:))
      enddo
      !
      allocate(solu(2*ob%ker,ob%nT3))
      allocate(kind(ob%ker)) ; kind=2      
      do ad=1,ob%nT3
        call mesh_dg_T3_set(ob,ad,eT3)
        j2D=mesh_dg_gradient_T3_jacobian2D(eT3)
        dndx=mesh_dg_gradient_T3_01_h1_daidx(0d0,0d0,j2D)
        dndy=mesh_dg_gradient_T3_01_h1_daidy(0d0,0d0,j2D)
        do j=1,ob%ker
          k=2*j-1
          solu(k  ,ad)=dndx(1)*ob%solu(j,eT3%n1)+dndx(2)*ob%solu(j,eT3%n2)+dndx(3)*ob%solu(j,eT3%n3)
          solu(k+1,ad)=dndy(1)*ob%solu(j,eT3%n1)+dndy(2)*ob%solu(j,eT3%n2)+dndy(3)*ob%solu(j,eT3%n3)
        enddo
      enddo

      write(*,'(3x,"Final vaiables")')
      do j=1,ob%ker
        k=2*j-1
        write(*,'(6x,"min/max dx_var",i1,": ",2e12.5)')j,minval(solu(k  ,:)),maxval(solu(k  ,:))
        write(*,'(6x,"min/max dy_var",i1,": ",2e12.5)')j,minval(solu(k+1,:)),maxval(solu(k+1,:))
      enddo

      call writeVtkASCII(  &
      &  fileOut=file     ,&
      &  geo=ob%geo       ,&
      &  vertx=ob%vertx   ,&
      &  trian=ob%trian   ,&
      &  nFields=ob%ker   ,&
      &  kind=kind        ,&
      &  solu=solu        ,&
      &  solAtVertx=.false.)

!      &  edges=ob%edges   ,&

    case(3)

      do ad=1,ob%nT4
      enddo

    end select    

    call cpu_time(t1)
    write(*,'("End Computing Gradient            - CPU =",e12.5," s")')t1-t0

  end subroutine mesh_dg_gradient_set

  subroutine mesh_dg_T3_display(ob)
    ! ---------------------------------------------------------------
    ! declaration des variables passees en argument
    type(T3) , intent(in) :: ob
    ! ---------------------------------------------------------------
    write(*,'("- T3 --------------------------------------------------")')
    write(*,'(" nd = ",3(i12  ,1x))')ob%n1, ob%n2, ob%n3
    write(*,'("  x = ",3(e12.5,1x))')ob%x (1:3)
    write(*,'("  y = ",3(e12.5,1x))')ob%y (1:3)
    write(*,'("-------------------------------------------------------")')
  end subroutine mesh_dg_T3_display

  subroutine mesh_dg_T3_set(ob0,ad,ob1)
    ! ---------------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob0
    integer      , intent(in)  :: ad
    type(T3)     , intent(out) :: ob1
    ! ---------------------------------------------------------------
    integer                    :: i
    ! ---------------------------------------------------------------
    do i=1,3
      ob1%x(i)=ob0%vertx(1,ob0%trian(i,ad))
      ob1%y(i)=ob0%vertx(2,ob0%trian(i,ad))
    enddo
    ob1%n1=ob0%trian(1,ad)
    ob1%n2=ob0%trian(2,ad)
    ob1%n3=ob0%trian(3,ad)
  end subroutine mesh_dg_T3_set


  type(jacob2D) function mesh_dg_gradient_T3_jacobian2D(ob) result( jac )
    ! ---------------------------------------------------------------
    ! Geometries 2D, axi et 3D
    !  Matrice Jacobienne         : jac%mat
    !  Matrice Jacobienne Inverse : jac%inv
    !  Jacobien                   : jac%det
    ! ---------------------------------------------------------------
    ! delcaration des variables passees en arguments
    type(T3)   :: ob
    ! ---------------------------------------------------------------
    real(8)    :: inv_det
    ! ---------------------------------------------------------------
    ! Matrice jac        | dx/du dx/dv |
    !  (jac%Mat)         | dy/du dy/dv |
    jac%mat(1,1)=ob%x(2)-ob%x(1) ; jac%mat(1,2)=ob%x(3)-ob%x(1)

    jac%mat(2,1)=ob%y(2)-ob%y(1) ; jac%mat(2,2)=ob%y(3)-ob%y(1)
    ! Jacobien = det(jac%Mat)
    jac%det=jac%mat(1,1)*jac%mat(2,2)-jac%mat(2,1)*jac%mat(1,2)
    inv_det=1d0/jac%det
    ! Matrice jac-1      | du/dx du/dz |
    !  (jac%Inv)         | dv/dx dv/dz |
    jac%inv(1,1)= jac%mat(2,2)*inv_det ; jac%inv(1,2)=-jac%mat(1,2)*inv_det
    jac%inv(2,1)=-jac%mat(2,1)*inv_det ; jac%inv(2,2)= jac%mat(1,1)*inv_det
  end function mesh_dg_gradient_T3_jacobian2D


  function mesh_dg_gradient_T3_jacobian2D_det(ob) result(det)
    ! ---------------------------------------------------------------
    ! Geometries 2D, axi et 3D
    !   Matrice Jacobienne         : jac%mat
    !   Matrice Jacobienne Inverse : jac%inv
    !   Jacobien                   : det
    !
    ! Matrice    | dx/du dx/dv |
    ! Jacobienne | dy/du dy/dv |
    !
    ! Jacobien = det(jac%Mat)=a11*a22-a21*a12
    ! avec : 
    !   a11=ob%x(2)-ob%x(1) ; a12=ob%x(3)-ob%x(1)
    !   a21=ob%y(2)-ob%y(1) ; a22=ob%y(3)-ob%y(1)
    ! ---------------------------------------------------------------
    ! delcaration des variables passees en arguments
    type(T3)   :: ob
    real(8)    :: det
    ! ---------------------------------------------------------------
    det=(ob%x(2)-ob%x(1))*(ob%y(3)-ob%y(1))-(ob%y(2)-ob%y(1))*(ob%x(3)-ob%x(1))
  end function mesh_dg_gradient_T3_jacobian2D_det

  function mesh_dg_gradient_T3_01_h1_daidx(u,v,jac) result(dndx)
    ! ______________________________________________
    ! Espace H1
    ! Fonctions daidx : dXidx = \sum_i dadx_i Xi_i
    ! ______________________________________________
    ! delcaration des variables passees en argument
    real(8)       :: u,v
    type(jacob2D) :: jac
    real(8)       :: dndx(3)
    ! ______________________________________________
    ! instructions
    !   dn/dx=(dn/du)(du/dx)+(dn/dv)(dv/dx)
    dndx(1) = -jac%inv(1,1)-jac%inv(2,1)
    dndx(2) =  jac%inv(1,1)             
    dndx(3) =               jac%inv(2,1)
  end function mesh_dg_gradient_T3_01_h1_daidx

  function mesh_dg_gradient_T3_01_h1_daidy(u,v,jac) result(dndy)
    ! ______________________________________________
    ! Espace H1
    ! Fonctions daidy : dXidz = \sum_i dadz_i Xi_i
    ! ______________________________________________
    ! delcaration des variables passees en argument
    real(8)       :: u,v
    type(jacob2D) :: jac
    real(8)       :: dndy(3) 
    ! ______________________________________________
    ! instructions
    !   dn/dy=(dn/du)(du/dy)+(dn/dv)(dv/dy)
    dndy(1) = -jac%inv(1,2)-jac%inv(2,2)
    dndy(2) =  jac%inv(1,2)
    dndy(3) =               jac%inv(2,2)
  end function mesh_dg_gradient_T3_01_h1_daidy


  function mesh_dg_geo_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: out
    !-----------------------------------
    out=ob%geo
  end function mesh_dg_geo_get

  subroutine mesh_dg_geo_set(ob,in)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: in
    !-----------------------------------
    ob%geo=in
  end subroutine mesh_dg_geo_set


  subroutine mesh_dg_quadr2tria_mesh(ob)
    !-----------------------------------
    type(mesh_dg)         :: ob
    !-----------------------------------
    integer               :: i,j,nT3
    integer , allocatable :: trian(:,:)
    real(8)               :: t0,t1
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Converting Mesh Quad to Trian")')
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
    !
    nT3=ob%nT3+2*ob%nQ4
    allocate(trian(4,nT3))
    
    j=0
    do i=1,ob%nT3
      j=j+1 ; trian(1:4,j)=[ob%trian(1,i),ob%trian(2,i),ob%trian(3,i), ob%trian(4,i)]
    enddo
    do i=1,ob%nQ4
      j=j+1 ; trian(1:4,j)=[ob%quadr(1,i),ob%quadr(2,i),ob%quadr(3,i), ob%quadr(5,i)]
      j=j+1 ; trian(1:4,j)=[ob%quadr(1,i),ob%quadr(3,i),ob%quadr(4,i), ob%quadr(5,i)]
    enddo

    ob%nQ4=0   ; deallocate(ob%quadr)
    ob%nT3=nT3 ; call move_alloc(trian, ob%trian)

    call cpu_time(t1)
    write(*,'( 3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10 )')ob%nL2
    write(ob%nlog,'("End Converting Mesh Quad to Trian - CPU =",e12.5," s")')t1-t0    
  end subroutine mesh_dg_quadr2tria_mesh


  subroutine mesh_dg_hexa2tetra_mesh(ob)
    !-----------------------------------
    type(mesh_dg) :: ob
    !-----------------------------------
    integer               :: i,j,k,l,m
    integer               :: i_min,n_min
    integer               :: nod(9)
    integer               :: nvert,nT4
    integer               :: nod0(4,6),nod1(4,6)
    real(8) , allocatable :: vertx(:,:)
    integer , allocatable :: mark (:)
    integer , allocatable :: tetra(:,:)
    real(8)               :: t0,t1
    integer               :: n(0:9)
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Converting Mesh Hexa to Tetra")')
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    do i=0,9
      n(i)=count(ob%mark==i)
      if( n(i)/=0 )write(ob%nlog,'(6x,"mark",i1,":",14x,i10)')i,n(i)
    enddo
    if( ob%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
   !write(*,'()')

    ! adding 1 vertex at center of Hexa
    nT4=12*ob%nH6
    nvert=ob%nvert+ob%nH6
    allocate(vertx(3,nvert))
    allocate(mark (  nvert))
    allocate(tetra(5,nT4  ))
    !
    !omp do
    do i=1,ob%nvert
      vertx(1:3,i)=ob%vertx(1:3,i)
      mark (    i)=ob%mark (    i)
    enddo
    !omp enddo
    !
    nT4=0
    do i=1,ob%nH6
      !
      nod(1:8)=[(ob%hexas(k,i), k=1,8)]
      nod(9)=ob%nvert+i
      do j=1,3
        vertx(j,nod(9))=sum([(ob%vertx(j,nod(k)), k=1,8)])/real(8,kind=4)
      enddo
!      mark (  nod(9))=ob%mark(nod(1))
      mark(nod(9))=0

      ! List of Pyramids
      nod0(1:4,1)=[nod(1),nod(2),nod(6),nod(5)]
      nod0(1:4,2)=[nod(3),nod(4),nod(8),nod(7)]
      nod0(1:4,3)=[nod(2),nod(3),nod(7),nod(6)]
      nod0(1:4,4)=[nod(1),nod(5),nod(8),nod(4)]
      nod0(1:4,5)=[nod(5),nod(6),nod(7),nod(8)]
      nod0(1:4,6)=[nod(1),nod(4),nod(3),nod(2)]

      ! Generating tetrahedra
      do m=1,6
        i_min=1 ; n_min=nod0(1,m)
        do l=2,4
          if( nod0(l,m)<n_min )then
            i_min=     l
            n_min=nod0(l,m)
          endif
        enddo
        nod1(1:4,m)=cshift(nod0(1:4,m),i_min-1)
        !
        nT4=nT4+1 ; tetra(1:5,nT4)=[nod1(1,m),nod1(2:3,m),nod(9),ob%hexas(9,i)] ! call tetra_trigo
        nT4=nT4+1 ; tetra(1:5,nT4)=[nod1(1,m),nod1(3:4,m),nod(9),ob%hexas(9,i)] ! call tetra_trigo
      enddo
    enddo

    ob%nH6=0
    ob%nvert=nvert
    call move_alloc(vertx, ob%vertx)
    call move_alloc(mark , ob%mark )
    ob%nT4=nT4
    call move_alloc(tetra, ob%tetra)

    call cpu_time(t1)
    write(*,'( 3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    do i=0,9
      n(i)=count(ob%mark==i)
      if( n(i)/=0 )write(ob%nlog,'(6x,"mark",i1,":",14x,i10)')i,n(i)
    enddo
    if( ob%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10 )')ob%nL2
    write(ob%nlog,'("End Converting Mesh Hexa to Tetra - CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_hexa2tetra_mesh


  subroutine mesh_dg_hexa2tetra_solu(ob)
    !-----------------------------------
    type(mesh_dg) :: ob
    !-----------------------------------
    integer              :: i,j,k,nH6,nsol,nod(8)
    real(8), allocatable :: solu(:,:)
    real(8)              :: t0,t1
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Converting Solu Hexa to Tetra")')
    write(*,'(3x,"Initial Number of solutions: ",i10 )')ob%nsol

    nH6=size(ob%hexas,2)
    nsol=ob%nsol+nH6
    allocate(solu(size(ob%solu,1),nsol))

    !omp do
    do i=1,ob%nsol
      solu(:,i)=ob%solu(:,i)
    enddo
    !omp enddo
    !
    do i=1,nH6
      nod(1:8)=[(ob%hexas(k,i), k=1,8)]
      nod(9)=ob%nsol+i
      do j=1,ob%nfld
        solu(j,nod(9))=sum([(ob%solu(j,nod(k)), k=1,8)])/real(8,kind=4)
      enddo
    enddo

    ob%nsol=nsol
    call move_alloc(solu, ob%solu)

    call cpu_time(t1)
    write(*,'(3x,"Final   Number of solutions: ",i10 )')ob%nsol
    write(ob%nlog,'("End Converting Solu Hexa to Tetra - CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_hexa2tetra_solu


  subroutine mesh_dg_interpolate_vert(ob,vertx,solut)
    !------------------------------------------------
    type(mesh_dg), intent(in)    :: ob
    real(8)      , intent(inout) :: vertx(:,:)    
    real(8)      , intent(out)   :: solut(:,:)    
    !------------------------------------------------
    integer                      :: i,ivert,icell,nod(4),iNod,nvert
    integer      , allocatable   :: ad(:)
    real(8)                      :: vertu(3)
    real(8)                      :: ai(4)
    real(8)                      :: dist
    real(8)                      :: t0,t1
    !------------------------------------------------
    if( size(solut,1)/=size(ob%solu,1) )then
      write(*,'("size(solut,1)/=size(ob%solu,1)")')
      write(*,'("stop @ mesh_dg_interpolate_vert")')
      stop
    endif
    !
    nvert=size(vertx,2)
    allocate(ad(nvert)) ; ad(:)=0
    !
    select case(ob%geo)
    case(2)
      do ivert=1,nvert
        if( vertx(1,ivert)<ob%xmin )vertx(1,ivert)=ob%xmin
        if( vertx(1,ivert)>ob%xmax )vertx(1,ivert)=ob%xmax
        !
        if( vertx(2,ivert)<ob%ymin )vertx(2,ivert)=ob%ymin
        if( vertx(2,ivert)>ob%ymax )vertx(2,ivert)=ob%ymax
      enddo
      !
      call mesh_dg_localize2D(ob=ob,vertx=vertx,ad=ad)
      !
    case(3)
      do ivert=1,nvert
        if( vertx(1,ivert)<ob%xmin )vertx(1,ivert)=ob%xmin
        if( vertx(1,ivert)>ob%xmax )vertx(1,ivert)=ob%xmax
        !
        if( vertx(2,ivert)<ob%ymin )vertx(2,ivert)=ob%ymin
        if( vertx(2,ivert)>ob%ymax )vertx(2,ivert)=ob%ymax
        !
        if( vertx(3,ivert)<ob%zmin )vertx(3,ivert)=ob%zmin
        if( vertx(3,ivert)>ob%zmax )vertx(3,ivert)=ob%zmax
      enddo
      !
      call mesh_dg_localize3D(ob=ob,vertx=vertx,ad=ad)
    end select
    !
    !
    call cpu_time(t0)
    write(ob%nlog,'(/"Interpolate ",i1,"D Solution: ",i2,"x",i10)')ob%geo,size(solut  ,1),size(solut  ,2)
    write(ob%nlog,'( "From        ",i1,"D Solution: ",i2,"x",i10)')ob%geo,size(ob%solu,1),size(ob%solu,2)
    !
    !
    select case(ob%geo)
    case(2)
      !
      do ivert=1,nvert
        !
        icell=ad(ivert)
        nod(1:3)=ob%trian(1:3,icell)
        !
        call mesh_dg_xy_uv(ob,nod,vertx(1:2,ivert),vertu(1:2))
        !
        ai(1)=1d0-vertu(1)-vertu(2)
        ai(2)=    vertu(1)
        ai(3)=             vertu(2)
        !
        solut(:,ivert)=0d0
        do inod=1,3
          solut(:,ivert)=solut(:,ivert)+ai(iNod)*ob%solu(:,nod(iNod))
        enddo
      enddo
      !
    case(3)
      !
      !omp do private(nod,icell,ai,inod,vertu)
      do ivert=1,nvert
        !
        icell=ad(ivert)
        if( iCell<0 .or. ob%nT4<iCell )then
          write(*,'("stop @ mesh_dg_interpolate_vert")')
          write(*,'("icell=",i10,3x,"ob%nT4=",i10)')icell,ob%nT4
          stop
        endif
        !
        nod(1:4)=ob%tetra(1:4,icell)        
        !
        call mesh_dg_xyz_uvw(ob=ob,nod=nod(1:4),vertx=vertx(1:3,ivert),vertu=vertu(1:3))
        !
        ai(1:4)=[1d0-vertu(1)-vertu(2)-vertu(3),&
        &            vertu(1)                  ,&
        &                     vertu(2)         ,&
        &                              vertu(3) ]


!        do inod=1,4
!          call mesh_dg_xyz_uvw(ob=ob,nod=nod(1:4),vertx=ob%vertx(1:3,nod(inod)),vertu=vertu(1:3))
!          write(*,'("nod",i1,": (u,v,w)=",3(f12.5,1x))')inod,vertu(1:3)
!          !
!          ai(1:4)=[1d0-vertu(1)-vertu(2)-vertu(3),&
!          &            vertu(1)                  ,&
!          &                     vertu(2)         ,&
!          &                              vertu(3) ]
!          !
!          write(*,'("nod",i1,": ai(u,v,w)=",4(f12.5,1x))')inod,ai(1:4)
!        enddo
!
!        write(*,'()')
!        if( ivert==10 )stop
        !

!        ai(1:4)=25d-2
        
        solut(:,ivert)=0d0
        do inod=1,4
          solut(:,ivert)=solut(:,ivert)+ai(inod)*ob%solu (:,nod(inod))
         !solut(:,ivert)=solut(:,ivert)+ai(inod)*ob%vertx(:,nod(inod))
        enddo

      enddo
     !omp enddo

    end select

    write(*,'(/3x,"solu0")')

    do i=1,ob%ker
      write(ob%nlog,'( 6x,"min,max( solu0(",i1,",:) )=",2(f12.5,1x) )')i,minval(ob%solu(i,:)),maxval(ob%solu(i,:))
    enddo

    write(*,'(/3x,"solu1")')

    do i=1,ob%ker
      write(ob%nlog,'( 6x,"min,max( solu1(",i1,",:) )=",2(f12.5,1x) )')i,minval(solut(i,:)),maxval(solut(i,:))
    enddo



    deallocate(ad)

    call cpu_time(t1)
    write(ob%nlog,'(/"End Interpolate Solution - CPU=",e12.5)')t0-t1

  end subroutine mesh_dg_interpolate_vert


  subroutine mesh_dg_interpolate(ob0,ob1)
    !------------------------------------------------
    type(mesh_dg), intent(in)    :: ob0
    type(mesh_dg), intent(inout) :: ob1
    !------------------------------------------------
    ob1%nsol=ob1%nvert
    ob1%ker =ob0%ker
    ob1%nfld=ob0%nfld
    ob1%kind=ob0%kind

!    ob1%ker =3 !ob0%ker
!    ob1%nfld=1 !ob0%nfld
!    ob1%kind(1)=2 !ob0%kind

    !
    allocate(ob1%solu(ob1%ker,ob1%nsol))
    
    call mesh_dg_interpolate_vert(ob=ob0,vertx=ob1%vertx,solut=ob1%solu)

  end subroutine mesh_dg_interpolate


  subroutine mesh_dg_inverse_triangles(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    integer               :: i
    integer               :: nT3
    integer, allocatable  :: trian(:,:)
    real(8)               :: t0,t1
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Inverse Triangles (n1,n2,n3, mark) -> (n1,n3,n2, mark)")')
    if( ob%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
    allocate(trian(4,ob%nT3))
    !omp do
    do i=1,ob%nT3
      trian(1,i)=ob%trian(1,i)
      trian(2,i)=ob%trian(3,i)
      trian(3,i)=ob%trian(2,i)
      trian(4,i)=ob%trian(4,i)
    enddo
    !omp enddo
    call move_alloc(trian, ob%trian)
    call cpu_time(t1)
    if( ob%nT3/=0 )write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
    write(ob%nlog,'(/"End Inverse Triangles - CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_inverse_triangles


  subroutine mesh_dg_localize(ob0,ob1,ad)
    !------------------------------------------------
    type(mesh_dg), intent(in)  :: ob0
    type(mesh_dg), intent(in)  :: ob1
    integer      , intent(out) :: ad(:)
    !------------------------------------------------
    integer                    :: i
    
    !------------------------------------------------
    ad(:)=0
    select case( ob0%geo )
    case(2) ; call mesh_dg_localize2D(ob0,ob1%vertx,ad)
    case(3) ; call mesh_dg_localize3D(ob0,ob1%vertx,ad)
    end select
  end subroutine mesh_dg_localize


  subroutine mesh_dg_localize2D(ob,vertx,ad)
    !------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob
    real(8)      , intent(in)  :: vertx(:,:)
    integer      , intent(out) :: ad   (:)
    !------------------------------------------------------
    real(8)                    :: t0,t1
    integer                    :: i,j,k,k0
    integer                    :: ll,mm,d
    integer                    :: imin,imax,jmin,jmax
    integer                    :: nvert,cpt1,cpt2,cpt3
    integer                    :: ii,jj,ic
    integer , allocatable      :: head (:),link (:)
    integer                    :: ii0,jj0,ic0
    integer                    :: nvert0
    integer , allocatable      :: head0(:),link0(:)
    real(8) , allocatable      :: x0   (:),y0   (:)
    integer , parameter        :: siz=512
    integer                    :: sizx,nx
    integer                    :: sizy,ny
    integer                    :: half_siz
    real(8)                    :: ux,uy,d2,d2_min,dm,dx,dy
    real(8) , parameter        :: tol=1d-2
    integer                    :: code
    integer                    :: e00,e0,e0_min,n,ei
    real(8)                    :: det(4)
    logical                    :: localized
    character(2)               :: kind
    real(8)                    :: xmin,xmax
    real(8)                    :: ymin,ymax
    integer , allocatable      :: neighborhood(:,:),idx(:)
    integer                    :: nEdgesMax
    integer , allocatable      :: nEdges(:),edges(:,:)
    integer                    :: nTrianMax
    integer , allocatable      :: nTrian(:),trian(:,:)
    real(8)                    :: x1,x2,y1,y2,a,b,c
    !------------------------------------------------------
    call cpu_time(t0)
    !
    nvert=size(vertx,2)
    write(ob%nlog,'(/"Localizing 2D vertices: ",i10)')nvert
    !
    cpt1=0 ; cpt2=0 ; cpt3=0
    half_siz=siz/2
    !
    ! Determining neighborhood for each vertex
    !
    allocate(nEdges(ob%nvert)) ; nEdges(:)=0
    !omp do
    do i=1,ob%nL2
      do j=1,2
        nEdges(ob%edges(j,i))=nEdges(ob%edges(j,i))+1
      enddo
    enddo
    !omp enddo
    nEdgesMax=maxval(nEdges)
    allocate(edges(nEdgesMax,ob%nvert))
    nEdges=0 ; edges=0
    !
    !omp do
    do i=1,ob%nL2
      do j=1,2
        nEdges(ob%edges(j,i))=nEdges(ob%edges(j,i))+1
        edges(nEdges(ob%edges(j,i)),ob%edges(j,i))=i
      enddo
    enddo
    !omp enddo
    !
    !
    allocate(nTrian(ob%nvert)) ; nTrian(:)=0
    !omp do
    do i=1,ob%nT3
      do j=1,3
        nTrian(ob%trian(j,i))=nTrian(ob%trian(j,i))+1
      enddo
    enddo
    !omp enddo
    nTrianMax=maxval(nTrian)
    allocate(trian(nTrianMax,ob%nvert))
    nTrian=0 ; trian=0
    !
    !omp do
    do i=1,ob%nT3
      do j=1,3
        nTrian(ob%trian(j,i))=nTrian(ob%trian(j,i))+1
        trian(nTrian(ob%trian(j,i)),ob%trian(j,i))=i
      enddo
    enddo
    !omp enddo
    !
    !
    ! Domain Bounding box
    !
    xmin=minval(ob%vertx(1,:)) ; xmax=maxval(ob%vertx(1,:)) ; dx=xmax-xmin
    ymin=minval(ob%vertx(2,:)) ; ymax=maxval(ob%vertx(2,:)) ; dy=ymax-ymin
    !
    d2=max(dx,dy)
    sizx=int(real(siz,kind=8)*dx/d2) ; nx=sizx+1
    sizy=int(real(siz,kind=8)*dy/d2) ; ny=sizy+1
    !
    dx=real(sizx,kind=8)/dx
    dy=real(sizy,kind=8)/dy
    !
    write(ob%nlog,'(3x,"Bounding Box of Reference Mesh")')
    write(ob%nlog,'(6x,2(a,e12.5,1x),a,i3)')'xmin=',xmin,'xmax=',xmax,'sizx=',sizx
    write(ob%nlog,'(6x,2(a,e12.5,1x),a,i3)')'ymin=',ymin,'ymax=',ymax,'sizy=',sizy
    !
    ! Building of the Dual Carthesian Grid
    !
    allocate(head(ny*nx+1),link(ob%nVert))
    head=0 ; link=0
    !
    do k=1,ob%nVert
      ii=int(real(ob%vertx(1,k)-xmin,kind=8)*dx)
      jj=int(real(ob%vertx(2,k)-ymin,kind=8)*dy)
      ic=jj*nx+ii+1
      if( head(ic)==0 )then
        head(ic)=k
      else
        link(k)=head(ic)
        head(ic)=k
      endif
    enddo
    !
    ! Localisation of vertices list vertx(1:2,:)
    !
    do k=1,nvert
      !
      ! (x,y) is inside box number ic
      ii=int(real(vertx(1,k)-xmin,kind=8)*dx) ; ii=max(0,min(ii,sizx))
      jj=int(real(vertx(2,k)-ymin,kind=8)*dy) ; jj=max(0,min(jj,sizy))
      ic=jj*nx+ii+1
      !
      n=head(ic)
      if( n/=0 )then
        dm=1d30
        j=n
        do
          ux=vertx(1,k)-ob%vertx(1,j)
          uy=vertx(2,k)-ob%vertx(2,j)
          d2=(ux*ux+uy*uy)/((xmax-xmin)**2+(ymax-ymin)**2)
          if( d2<dm )then
            n=j
            dm=d2
          endif
          if( link(j)==0 )exit
          j=link(j)
        enddo
        !
      else
        !
        d=1
        imin=ii ; imax=ii
        jmin=jj ; jmax=jj
        Cell : do
          imin=max(0,imin-1) ; imax=min(imax+1,sizx)
          jmin=max(0,jmin-1) ; jmax=min(jmax+1,sizy)
          !
          ll=imin
          do mm=jmin+1,jmax
            ic=mm*nx+ll+1
            n=head(ic)
            if( n/=0 )exit Cell
          enddo
          !
          mm=jmax
          do ll=imin+1,imax
            ic=mm*nx+ll+1
            n=head(ic)
            if( n/=0 )exit Cell
          enddo
          !
          ll=imax
          do mm=jmax-1,jmin,-1
            ic=mm*nx+ll+1
            n=head(ic)
            if( n/=0 )exit Cell
          enddo
          !
          mm=jmin
          do ll=imax-1,imin,-1
            ic=mm*nx+ll+1
            n=head(ic)
            if( n/=0 )exit Cell
          enddo
          !
          d=d+1
          if( d>half_siz )stop 'd>half_size'
        enddo Cell
      endif 
      !
      !
      do i=1,nTrian(n)
        e0=trian(i,n)
        call mesh_dg_vertex_inside_Triangle(ob,e0,vertx(1:2,k),det(1:4),localized)
        if( localized )exit
      enddo

      if( localized )then
       !write(*,'("vertex localied in trian: ",i10)')e0
        cpt1=cpt1+1
        ad(k)=e0
      else

        if( sqrt(dm)<tol )then

          dm=1d30
          do i=1,nTrian(n)
            e0=trian(i,n)
            !
            ! [n1:n2]
            x1=ob%vertx(1,ob%trian(1,e0)) ; y1=ob%vertx(2,ob%trian(1,e0))
            x2=ob%vertx(1,ob%trian(2,e0)) ; y2=ob%vertx(2,ob%trian(2,e0))
            ! D : a x + b y + c = 0
            a= (y2-y1) ; b=-(x2-x1) ; c= y1*(x2-x1)-x1*(y2-y1)
            ! Distance point vertx(:,k ) a droite D
            d2=(a*vertx(1,k)+b*vertx(2,k)+c)**2/(a*a+b*b) / ((xmax-xmin)**2+(ymax-ymin)**2)
            if( d2<dm )then
              dm=d2
              ad(k)=e0
            endif
            !
            ! [n2:n3]
            x1=ob%vertx(1,ob%trian(2,e0)) ; y1=ob%vertx(2,ob%trian(2,e0))
            x2=ob%vertx(1,ob%trian(3,e0)) ; y2=ob%vertx(2,ob%trian(3,e0))
            ! D : a x + b y + c = 0
            a= (y2-y1) ; b=-(x2-x1) ; c= y1*(x2-x1)-x1*(y2-y1)
            ! Distance point vertx(:,k ) a droite D
            d2=(a*vertx(1,k)+b*vertx(2,k)+c)**2/(a*a+b*b) / ((xmax-xmin)**2+(ymax-ymin)**2)
            if( d2<dm )then
              dm=d2
              ad(k)=e0
            endif
            !
            ! [n3:n1]
            x1=ob%vertx(1,ob%trian(3,e0)) ; y1=ob%vertx(2,ob%trian(3,e0))
            x2=ob%vertx(1,ob%trian(1,e0)) ; y2=ob%vertx(2,ob%trian(1,e0))
            ! D : a x + b y + c = 0
            a= (y2-y1) ; b=-(x2-x1) ; c= y1*(x2-x1)-x1*(y2-y1)
            ! Distance point vertx(:,k ) a droite D
            d2=(a*vertx(1,k)+b*vertx(2,k)+c)**2/(a*a+b*b) / ((xmax-xmin)**2+(ymax-ymin)**2)
            if( d2<dm )then
              dm=d2
              ad(k)=e0
            endif
          enddo

          cpt2=cpt2+1
      
        else

          dm=1d30
          do i=1,ob%nT3 !nTrian(n)
            e0=i !trian(i,n)
            !
            ! [n1:n2]
            x1=ob%vertx(1,ob%trian(1,e0)) ; y1=ob%vertx(2,ob%trian(1,e0))
            x2=ob%vertx(1,ob%trian(2,e0)) ; y2=ob%vertx(2,ob%trian(2,e0))
            ! D : a x + b y + c = 0
            a= (y2-y1) ; b=-(x2-x1) ; c= y1*(x2-x1)-x1*(y2-y1)
            ! Distance point vertx(:,k ) a droite D
            d2=(a*vertx(1,k)+b*vertx(2,k)+c)**2/(a*a+b*b) / ((xmax-xmin)**2+(ymax-ymin)**2)
            if( d2<dm )then
              dm=d2
              ad(k)=e0
            endif
            !
            ! [n2:n3]
            x1=ob%vertx(1,ob%trian(2,e0)) ; y1=ob%vertx(2,ob%trian(2,e0))
            x2=ob%vertx(1,ob%trian(3,e0)) ; y2=ob%vertx(2,ob%trian(3,e0))
            ! D : a x + b y + c = 0
            a= (y2-y1) ; b=-(x2-x1) ; c= y1*(x2-x1)-x1*(y2-y1)
            ! Distance point vertx(:,k ) a droite D
            d2=(a*vertx(1,k)+b*vertx(2,k)+c)**2/(a*a+b*b) / ((xmax-xmin)**2+(ymax-ymin)**2)
            if( d2<dm )then
              dm=d2
              ad(k)=e0
            endif
            !
            ! [n3:n1]
            x1=ob%vertx(1,ob%trian(3,e0)) ; y1=ob%vertx(2,ob%trian(3,e0))
            x2=ob%vertx(1,ob%trian(1,e0)) ; y2=ob%vertx(2,ob%trian(1,e0))
            ! D : a x + b y + c = 0
            a= (y2-y1) ; b=-(x2-x1) ; c= y1*(x2-x1)-x1*(y2-y1)
            ! Distance point vertx(:,k ) a droite D
            d2=(a*vertx(1,k)+b*vertx(2,k)+c)**2/(a*a+b*b) / ((xmax-xmin)**2+(ymax-ymin)**2)
            if( d2<dm )then
              dm=d2
              ad(k)=e0
            endif
          enddo

          write(*,'("vertex ",i10," warning localized with relative distance ",e12.5)')k,sqrt(dm)
  
          cpt3=cpt3+1

        endif
        
      endif

    enddo

    write(*,'(3x,"Number of vertices localised=                         ",i10)')cpt1
    write(*,'(3x,"Number of vertices localized with geometric tolerance=",i10)')cpt2
    write(*,'(3x,"Number of vertices unlocalised=                       ",i10)')cpt3
!
!    if( count(ad==0)/=0 )then
!      write(*,'(//"STOP @ mesh_dg_localize2D"//)')
!      write(*,'("Number of vertices                      =",i10)')nvert
!      write(*,'("Number of vertices localised in cell    =",i10)')cpt1
!      write(*,'("Number of vertices localised near edges =",i10)')cpt2
!      write(*,'("Number of unlocalized vertices          =",i10)')count(ad==0)
!      stop
!    endif

    deallocate(head ,link )

    open(unit=100,file='unlocalized_vertices.txt')
    open(unit=200,file='localized_vertices.txt')
    do k=1,nvert
      if(ad(k)==0 )then
        write(100,'(f12.5,2x,f12.5)')vertx(1:2,k)
      else
        write(200,'(f12.5,2x,f12.5)')vertx(1:2,k)
      endif
    enddo
    close(100)
    close(200)
    
    call cpu_time(t1)
    write(ob%nlog,'("End Localizing 2D vertices - CPU =",e12.5," s")')t1-t0

  end subroutine mesh_dg_localize2D


  subroutine mesh_dg_localize3D(ob, vertx, ad)
    !------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob
    real(8)      , intent(in)  :: vertx(:,:)
    integer      , intent(out) :: ad   (:)
    !------------------------------------------------------
    real(8)                    :: t0,t1
    integer                    :: i,j,k,k0
    integer                    :: ll,mm,nn
    integer                    :: imin,imax,jmin,jmax,kmin,kmax
    integer                    :: ivert,nvert,cpt1,cpt2,cpt3
    integer                    :: ii,jj,kk,ic,d
    integer , allocatable      :: head (:),link (:)
    integer                    :: ii0,jj0,ic0
    integer                    :: nvert0
    integer , allocatable      :: head0(:),link0(:)
    real(8) , allocatable      :: x0   (:),y0   (:)
    integer , parameter        :: siz=32
    integer                    :: sizx,nx
    integer                    :: sizy,ny
    integer                    :: sizz,nz
    integer                    :: half_siz
    real(8)                    :: ux,uy,uz,dm,dx,dy,dz,d2Max
    real(8)                    :: d2(4)
    real(8) , parameter        :: tol=1d-2
    integer                    :: code
    integer                    :: e00,e0,e0_min,n,ei
    real(8)                    :: det(4)
    logical                    :: localized
    character(2)               :: kind

    integer                    :: nTetraMax
    integer , allocatable      :: nTetra(:),tetra(:,:)
    !------------------------------------------------------
    call cpu_time(t0)
    !
    nvert=size(vertx,2)
    write(ob%nlog,'(/"Localizing 3D vertices: ",i10)')nvert
    !
    cpt1=0 ; cpt2=0 ; cpt3=0
    half_siz=siz/2
    !
    ! Determining neighborhood for each vertex
    !
    allocate(nTetra(ob%nvert)) ; nTetra(:)=0
    !omp do
    do i=1,ob%nT4
      do j=1,4
        nTetra(ob%tetra(j,i))=nTetra(ob%tetra(j,i))+1
      enddo
    enddo
    !omp enddo
    nTetraMax=maxval(nTetra)
    write(*,'(3x,"nTetraMin=",i2,3x,"nTetraMax=",i2)')minval(nTetra),nTetraMax
    !
    allocate(tetra(nTetraMax,ob%nvert))
    nTetra=0 ; tetra=0
    !
    !omp do
    do i=1,ob%nT4
      do j=1,4
        ivert=ob%tetra(j,i)
        nTetra(ivert)=nTetra(ivert)+1
        tetra(nTetra(ivert),ivert)=i
      enddo
    enddo
    !omp enddo
    !
    !
    ! Domain Bounding box
    !
    dx=ob%xmax-ob%xmin
    dy=ob%ymax-ob%ymin
    dz=ob%zmax-ob%zmin
    !
    d2Max=max(dx,dy,dz)
    sizx=int(real(siz,kind=8)*dx/d2Max) ; nx=sizx+1
    sizy=int(real(siz,kind=8)*dy/d2Max) ; ny=sizy+1
    sizz=int(real(siz,kind=8)*dz/d2Max) ; nz=sizz+1
    !
    dx=real(sizx,kind=8)/dx
    dy=real(sizy,kind=8)/dy
    dz=real(sizz,kind=8)/dz
    !
    write(ob%nlog,'(3x,"Bounding Box of Reference Mesh")')
    write(ob%nlog,'(6x,2(a,e12.5,1x),a,i3)')'xmin=',ob%xmin,'xmax=',ob%xmax,'sizx=',sizx
    write(ob%nlog,'(6x,2(a,e12.5,1x),a,i3)')'ymin=',ob%ymin,'ymax=',ob%ymax,'sizy=',sizy
    write(ob%nlog,'(6x,2(a,e12.5,1x),a,i3)')'zmin=',ob%zmin,'zmax=',ob%zmax,'sizy=',sizz
    !
    ! Building of the Dual Carthesian Grid
    !
    allocate(head(nz*ny*nx+1),link(ob%nVert))
    head=0 ; link=0
    !
    do k=1,ob%nVert
      ii=int(real(ob%vertx(1,k)-ob%xmin,kind=8)*dx)
      jj=int(real(ob%vertx(2,k)-ob%ymin,kind=8)*dy)
      kk=int(real(ob%vertx(3,k)-ob%zmin,kind=8)*dz)
      ic=(kk*ny+jj)*nx+ii+1
      if( head(ic)==0 )then
        head(ic)=k
      else
        link(k)=head(ic)
        head(ic)=k
      endif
    enddo
    !
    !
    ! Localisation of vertices list vertx(1:3,:)
    !    
    d2Max= (ob%xmax-ob%xmin)*(ob%xmax-ob%xmin) &
    &     +(ob%ymax-ob%ymin)*(ob%ymax-ob%ymin) &
    &     +(ob%zmax-ob%zmin)*(ob%zmax-ob%zmin)
    d2Max=1d0/d2Max
    !
    do k=1,nvert
      !
      ! (x,y,z) is inside box number ic
      ii=int(real(vertx(1,k)-ob%xmin,kind=8)*dx) ; ii=max(0,min(ii,sizx))
      jj=int(real(vertx(2,k)-ob%ymin,kind=8)*dy) ; jj=max(0,min(jj,sizy))
      kk=int(real(vertx(3,k)-ob%zmin,kind=8)*dz) ; kk=max(0,min(kk,sizz))
      ic=(kk*ny+jj)*nx+ii+1
      !
      n=head(ic)
      !
      if( n/=0 )then ! some vertices are located in box ic
        dm=1d30
        j=n
        do
          ux=vertx(1,k)-ob%vertx(1,j)
          uy=vertx(2,k)-ob%vertx(2,j)
          uz=vertx(3,k)-ob%vertx(3,j)
          d2(1)=(ux*ux+uy*uy+uz*uz)*d2Max
          if( d2(1)<dm )then
            n=j
            dm=d2(1)
          endif
          if( link(j)==0 )exit
          j=link(j)
        enddo
        !
      else ! no vertices are located in box ic => increasing the box
        !
        d=1
        imin=ii ; imax=ii
        jmin=jj ; jmax=jj
        kmin=kk ; kmax=kk
        Cell : do
          imin=max(0,imin-1) ; imax=min(imax+1,sizx)
          jmin=max(0,jmin-1) ; jmax=min(jmax+1,sizy)
          kmin=max(0,kmin-1) ; kmax=min(kmax+1,sizz)
          do nn=kmin,kmax
            do mm=jmin,jmax
              do ll=imin,imax
                if( ll/=ii .and. mm/=jj .and. nn/=kk )then
                  ic=(nn*ny+mm)*nx+ll+1
                  n=head(ic)
                  if( n/=0 )exit Cell
                endif
              enddo
            enddo
          enddo
          d=d+1
          if( d >half_siz )stop 'd>half_size'
        enddo Cell
        !
      endif
      !
      ! n
      do i=1,nTetra(n)
        e0=tetra(i,n)
        !
        call mesh_dg_vertex_inside_Tetra( &
        &    ob=ob                       ,&
        &    e0=e0                       ,&
        &    vertx=vertx(1:3,k)          ,&
        &    det=det(1:4)                ,&
        &    loc=localized                )
        !
        if( localized )exit
      enddo


      if( localized )then
       !write(*,'("vertex localied in tetra: ",i10)')e0
        cpt1=cpt1+1
        ad(k)=e0

      else

        if( sqrt(dm)<tol )then

          dm=1d30
          do i=1,nTetra(n)
            e0=tetra(i,n)
            !
            ! [n2:n3:n4]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(2,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(3,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(4,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(1)                       )
            !
            !
            ! [n1:n4:n3]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(1,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(4,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(3,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(2)                       )
            !
            !
            ! [n1:n2:n4]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(1,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(2,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(4,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(3)                       )
            !
            !
            ! [n1:n3:n2]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(1,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(3,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(2,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(4)                       )
            !
            ! Distance normalisee
            d2(1:4)=d2(1:4)*d2Max
            if( d2(1)<dm .or. d2(2)<dm .or. d2(3)<dm .or. d2(4)<dm)then
              dm=minval(d2)
              ad(k)=e0
            endif
            !
          enddo

          cpt2=cpt2+1
      
        else

          dm=1d30
          do i=1,ob%nT4 !nTetra(n)
            e0=i !tetra(i,n)
            !
            !
            ! [n2:n3:n4]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(2,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(3,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(4,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(1)                       )
            !
            ! [n1:n4:n3]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(1,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(4,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(3,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(2)                       )
            !
            ! [n1:n2:n4]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(1,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(2,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(4,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(3)                       )
            !
            ! [n1:n3:n2]
            !
            call mesh_dg_distancePlan(             &
            &    pt1=ob%vertx(1:3,ob%tetra(1,e0)) ,&
            &    pt2=ob%vertx(1:3,ob%tetra(3,e0)) ,&
            &    pt3=ob%vertx(1:3,ob%tetra(2,e0)) ,&
            &    xyz=   vertx(1:3,k)              ,&
            &    dist2=d2(4)                       )
            !
            !
            ! Distance normalisee
            d2(1:4)=d2(1:4)*d2Max
            if( d2(1)<dm .or. d2(2)<dm .or. d2(3)<dm .or. d2(4)<dm)then
              dm=minval(d2)
              ad(k)=e0
            endif
            !
          enddo

          write(*,'("vertex ",i10," warning localized with relative distance ",e12.5)')k,sqrt(dm)
  
          cpt3=cpt3+1

        endif
        
      endif

    enddo

    write(*,'(3x,"Number of vertices localised=                         ",i10)')cpt1
    write(*,'(3x,"Number of vertices localized with geometric tolerance=",i10)')cpt2
    write(*,'(3x,"Number of vertices unlocalised=                       ",i10)')cpt3

    deallocate(head ,link )

!    open(unit=100,file='unlocalized_vertices.txt')
!    open(unit=200,file='localized_vertices.txt')
!    do k=1,nvert
!      if(ad(k)==0 )then
!        write(100,'(f12.5,2x,f12.5,2x,f12.5)')vertx(1:3,k)
!      else
!        write(200,'(f12.5,2x,f12.5,2x,f12.5)')vertx(1:3,k)
!      endif
!    enddo
!    close(100)
!    close(200)

    call cpu_time(t1)
    write(ob%nlog,'("End Localizing 3D vertices - CPU =",e12.5," s")')t1-t0

  end subroutine mesh_dg_localize3D

 
  subroutine mesh_dg_distancePlan(pt1,pt2,pt3,xyz, dist2)
    !-----------------------------------
    real(8), intent(in)  :: pt1(3)
    real(8), intent(in)  :: pt2(3)
    real(8), intent(in)  :: pt3(3)
    real(8), intent(in)  :: xyz(3)
    real(8), intent(out) :: dist2
    !-----------------------------------
    real(8) :: x1,y1,z1
    real(8) :: x2,y2,z2
    real(8) :: x3,y3,z3
    real(8) :: a,b,c,d
    !-----------------------------------
    x1=pt1(1)    ; y1=pt1(2)    ; z1=pt1(3)
    x2=pt2(1)-x1 ; y2=pt2(2)-y1 ; z2=pt2(3)-z1
    x3=pt3(1)-x1 ; y3=pt3(2)-y1 ; z3=pt3(3)-z1
    !
    ! P : a x + b y + c z + d = 0
    a= ((y2*z3)-(z2*y3)) 
    b=-((x2*z3)-(z2*x3))
    c= ((x2*y3)-(y2*x3))
    d=-(x1*a+y1*b+z1*c)
    !
    ! Distance^2 point xyz a plan P
    !
    dist2=(a*xyz(1)+b*xyz(2)+c*xyz(3)+d)**2/(a*a+b*b+c*c)
    !
  end subroutine mesh_dg_distancePlan


  function mesh_dg_mesh_name_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg)  :: ob
    character(256) :: out
    !-----------------------------------
    out=ob%mesh_name
  end function mesh_dg_mesh_name_get

  subroutine mesh_dg_mesh_name_set(ob,in)
    !-----------------------------------
    type(mesh_dg)  :: ob
    character(256) :: in
    !-----------------------------------
    ob%mesh_name=in
  end subroutine mesh_dg_mesh_name_set

  function mesh_dg_solu_name_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg)  :: ob
    character(256) :: out
    !-----------------------------------
    out=ob%solu_name
  end function mesh_dg_solu_name_get

  subroutine mesh_dg_solu_name_set(ob,in)
    !-----------------------------------
    type(mesh_dg)  :: ob
    character(256) :: in
    !-----------------------------------
    ob%solu_name=in
  end subroutine mesh_dg_solu_name_set

  function mesh_dg_nH6_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: out
    !-----------------------------------
    out=ob%nH6
  end function mesh_dg_nH6_get

  subroutine mesh_dg_nH6_set(ob,in)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: in
    !-----------------------------------
    ob%nH6=in
  end subroutine mesh_dg_nH6_set

  function mesh_dg_nL2_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: out
    !-----------------------------------
    out=ob%nL2
  end function mesh_dg_nL2_get

  subroutine mesh_dg_nL2_set(ob,in)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: in
    !-----------------------------------
    ob%nL2=in
  end subroutine mesh_dg_nL2_set

  function mesh_dg_nlog_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: out
    !-----------------------------------
    out=ob%nlog
  end function mesh_dg_nlog_get

  subroutine mesh_dg_nlog_set(ob,in)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: in
    !-----------------------------------
    ob%nlog=in
  end subroutine mesh_dg_nlog_set


  subroutine mesh_dg_mesh_mark(ob)
    !-----------------------------------
    type(mesh_dg)                 :: ob
    !-----------------------------------
    character(200)                :: name0
    integer                       :: i,l,ierr,cmpt
    integer                       :: ni(50)
    character(20)                 :: key
    integer                       :: mark
    real(8)                       :: x(3),y(3),z(3)
    real(8)                       :: t0,t1
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Building Mesh Marks")')

    select case(ob%geo)
    case(2)
      !omp do
      do i=1,50
        ni(i)=count(ob%edges(3,:)==i)
      enddo
      !omp enddo
      do i=1,50
        if( ni(i)/=0 )then
          write(*,'(3x,"Initial Number of edges marked: ",i2,": ",i10 )')i,ni(i)
        endif
      enddo
    case(3)
      !omp do
      do i=1,50
        ni(i)=count(ob%trian(4,:)==i)
      enddo
      !omp do
      do i=1,50
        if( ni(i)/=0 )then
          write(*,'(3x,"Initial Number of triangles marked: ",i2,": ",i10 )')i,ni(i)
        endif
      enddo
    end select

    ob%mark(:)=0
    if( ob%nL2/=0 )ob%edges(3,:)=0
    if( ob%nT3/=0 )ob%trian(4,:)=0
    if( ob%nT4/=0 )ob%tetra(5,:)=0


   !l=index(name,'.',.true.)-1
    name0=trim(ob%mesh_name)//'.mark'
    open(unit=101,file=trim(name0),status='old',action='read',iostat=ierr)
    if( ierr/=0 )then
      write(*,'("WARNING: File ",a," Not Found")')trim(name0)
      write(*,'("WARNING: Mesh Unmarked")')
      call cpu_time(t1)
      write(ob%nlog,'(a,e12.5,a)')'End Building Mesh Marks - CPU =',t1-t0,' s'
      return
    endif
    write(ob%nlog,'(3x,"Reading Mark file  ",a)')trim(name0)

    Reading : do
      read(101,*)key

      select case(trim(key))
      case('BB','bb','BoundingBox','boundingbox')
        write(*,'(3x,"BoundingBox (x,y,z)")')
        read(101,*)mark
        read(101,*)x(1),y(1),z(1)
        read(101,*)x(2),y(2),z(2)

        call mesh_dg_vertx_xyz_mark_set(ob=ob,x=x,y=y,z=z,mark=mark,cmpt=cmpt)

        write(*,'(6x,"mark ",i3)'),mark
        write(*,'(6x,e12.5" < x <",e12.5)')minval(x(1:2)),maxval(x(1:2))
        write(*,'(6x,e12.5" < y <",e12.5)')minval(y(1:2)),maxval(y(1:2))
        write(*,'(6x,e12.5" < z <",e12.5)')minval(z(1:2)),maxval(z(1:2))
        write(*,'(6x,"number of edges",i10)')cmpt


      case('cyl','Cyl','Cylinder','BBcyl','bbcyl','BoundingBox_Cylinder','boundingbox_cylinder')
        write(*,'(3x,"BoundingBox (r,z)")')
        read(101,*)mark
        read(101,*)x(1),y(1)
        read(101,*)x(2),y(2)

        write(*,'(6x,"mark ",i3)'),mark
        write(*,'(6x,e12.5" < r <",e12.5)')minval(x(1:2)),maxval(x(1:2))
        write(*,'(6x,e12.5" < z <",e12.5)')minval(y(1:2)),maxval(y(1:2))
        write(*,'(6x,"number of triangles",i10)')cmpt

        call mesh_dg_vertx_rtz_mark_set(ob=ob,x=x,y=y,mark=mark,cmpt=cmpt)

      case('VERTEX','Vertex','vertex','vertx')
        read(101,*)mark
        read(101,*)i
        ob%mark(i)=mark
        write(*,'(3x,"Vertex")')
        write(*,'(6x,"mark ",i3)'),mark
        write(*,'(6x,"i=",i10)'),i
      case('Triangle','Trian','trian')
        read(101,*)mark
        read(101,*)i
        ob%trian(4,i)         =mark
        ob%mark(ob%trian(1,i))=mark
        ob%mark(ob%trian(2,i))=mark
        ob%mark(ob%trian(3,i))=mark
        write(*,'(3x,"Triangle")')
        write(*,'(6x,"mark ",i3)'),mark
        write(*,'(6x,"i=",i10)'),i
      case('Edge','egde')
        read(101,*)mark
        read(101,*)i
        ob%edges(3,i)         =mark
        ob%mark(ob%edges(1,i))=mark
        ob%mark(ob%edges(2,i))=mark
        write(*,'(3x,"Edge")')
        write(*,'(6x,"mark ",i3)'),mark
        write(*,'(6x,"i=",i10)'),i
      case default
      case('END','End','end')
        close(101)
        exit
      end select
    enddo Reading
    !
    select case(ob%geo)
    case(2)
      !omp do
      do i=1,50
        ni(i)=count(ob%edges(3,:)==i)
      enddo
      !omp enddo
      do i=1,50
        if( ni(i)/=0 )then
          write(*,'(3x,"Final   Number of edges marked: ",i2,": ",i10 )')i,ni(i)
        endif
      enddo
    case(3)
      !omp do
      do i=1,50
        ni(i)=count(ob%trian(4,:)==i)
      enddo
      !omp do
      do i=1,50
        if( ni(i)/=0 )then
          write(*,'(3x,"Final   Number of triangles marked: ",i2,": ",i10 )')i,ni(i)
        endif
      enddo
    end select

    call cpu_time(t1)
    write(ob%nlog,'(a,e12.5,a)')'End Building Mesh Marks - CPU =',t1-t0,' s'
  end subroutine mesh_dg_mesh_mark


  subroutine mesh_dg_merge_meshes(ob1,ob2)
    !-----------------------------------
    type(mesh_dg)               :: ob1,ob2
    !-----------------------------------
    integer               :: i,j
    integer               :: nvert
    real(8), allocatable  :: vertx(:,:)
    integer               :: nL2
    integer, allocatable  :: edges(:,:)
    integer               :: nT3
    integer, allocatable  :: trian(:,:)
    integer               :: nQ4
    integer, allocatable  :: quadr(:,:)
    integer               :: nT4
    integer, allocatable  :: tetra(:,:)
    integer, allocatable  :: mark (:)
    real(8)               :: t0,t1
    !-----------------------------------
    call cpu_time(t0)
    write(ob1%nlog,'(/"Merging Meshes")')
    write(*,'(3x,"First Mesh: ",a)')trim(ob1%mesh_name)
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob1%nvert
    if( ob1%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob1%nH6
    if( ob1%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob1%nT4
    if( ob1%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob1%nQ4
    if( ob1%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob1%nT3
    if( ob1%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob1%nL2

    write(*,'(/3x,"Second Mesh: ",a)')trim(ob2%mesh_name)
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob2%nvert
    if( ob2%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob2%nH6
    if( ob2%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob2%nT4
    if( ob2%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob2%nQ4
    if( ob2%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob2%nT3
    if( ob2%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob2%nL2

write(*,*)'coucou0'    
    ! Edges

    nL2=ob1%nL2+ob2%nL2
    if( nL2/=0 )then
      allocate(edges(3,nL2))
      !omp do
      do i=1,ob1%nL2
        edges(:,i)=ob1%edges(:,i)
      enddo
      !omp enddo
write(*,*)'coucou1'
      !omp do
      do i=1,ob2%nL2
        j=ob1%nL2+i
        edges(1:2,j)=ob2%edges(1:2,i)+ob1%nvert
        edges(  3,j)=ob2%edges(  3,i)
      enddo
      !omp enddo

      ob1%nL2=nL2 ; call move_alloc(edges, ob1%edges)
      ob2%nL2=0   ; if( allocated(ob2%edges) )deallocate(ob2%edges)
    endif


    ! Triangles

    nT3=ob1%nT3+ob2%nT3
    if( nT3/=0 )then
      allocate(trian(4,nT3))
      !omp do
      do i=1,ob1%nT3
        trian(:,i)=ob1%trian(:,i)
      enddo
      !omp enddo
      !omp do
      do i=1,ob2%nT3
        j=ob1%nT3+i
        trian(1:3,j)=ob2%trian(1:3,i)+ob1%nvert
        trian(  4,j)=ob2%trian(  4,i)
      enddo
      !omp enddo
      ob1%nT3=nT3 ; call move_alloc(trian, ob1%trian)
      ob2%nT3=0   ; if( allocated(ob2%trian) )deallocate(ob2%trian)
    endif

    ! Quandrangles

    nQ4=ob1%nQ4+ob2%nQ4
    if( nQ4/=0 )then
      allocate(quadr(5,nQ4))
      !omp do
      do i=1,ob1%nQ4
        quadr(:,i)=ob1%quadr(:,i)
      enddo
      !omp enddo
      !omp do
      do i=1,ob2%nQ4
        j=ob1%nQ4+i
        quadr(1:4,j)=ob2%quadr(1:4,i)+ob1%nvert
        quadr(  5,j)=ob2%quadr(  5,i)
      enddo
      !omp enddo
      ob1%nQ4=nQ4 ; call move_alloc(quadr, ob1%quadr)
      ob2%nQ4=0   ; if( allocated(ob2%quadr) )deallocate(ob2%quadr)
    endif

    ! Tetra

    nT4=ob1%nT4+ob2%nT4
    if( nT4/=0 )then
      allocate(tetra(5,nT4))
      !omp do
      do i=1,ob1%nT4
        tetra(:,i)=ob1%tetra(:,i)
      enddo
      !omp enddo
      !omp do
      do i=1,ob2%nT4
        j=ob1%nT4+i
        tetra(1:4,j)=ob2%tetra(1:4,i)+ob1%nvert
        tetra(  5,j)=ob2%tetra(  5,i)
      enddo
      !omp enddo
      ob1%nT4=nT4 ; call move_alloc(tetra, ob1%tetra)
      ob2%nT4=0   ; if( allocated(ob2%tetra) )deallocate(ob2%tetra)
    endif
    
    ! Vertices

    nvert=ob1%nvert+ob2%nvert
    allocate(vertx(size(ob1%vertx,1),nvert),mark(nvert))
    !omp do
    do i=1,ob1%nvert
      vertx(:,i)=ob1%vertx(:,i)
      mark (  i)=ob1%mark (  i)
    enddo
    !omp enddo
    !omp do
    do i=1,ob2%nvert
      j=ob1%nvert+i
      vertx(:,j)=ob2%vertx(:,i)
      mark (  j)=ob2%mark (  i)
    enddo
    !omp enddo
    ob1%nvert=nvert
    call move_alloc(vertx, ob1%vertx)
    call move_alloc(mark , ob1%mark )    
    ob2%nvert=0
    deallocate(ob2%vertx)
    deallocate(ob2%mark )

    ! End
    
    call cpu_time(t1)
    write(*,'(/3x,"Final   Number of vertices:  ",i10 )')ob1%nvert
    if( ob1%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob1%nH6
    if( ob1%nT4/=0 )write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob1%nT4
    if( ob1%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob1%nQ4
    if( ob1%nT3/=0 )write(*,'(3x,"Final   Number of triangles: ",i10 )')ob1%nT3
    if( ob1%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10 )')ob1%nL2
    write(ob1%nlog,'("End Converting Mesh Quad to Trian - CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_merge_meshes


  subroutine mesh_dg_vertx_xyz_mark_set(ob,x,y,z,mark,cmpt)
    !-----------------------------------
    type(mesh_dg)               :: ob
    real(8)     , intent(in)    :: x(2)
    real(8)     , intent(in)    :: y(2)
    real(8)     , intent(in)    :: z(2)
    integer     , intent(in)    :: mark
    integer     , intent(out)   :: cmpt
    !-----------------------------------
    integer                     :: i,n1,n2,n3
    real(8)                     :: xmin,ymin,zmin,xmax,ymax,zmax
    !-----------------------------------
    cmpt=0
    ! min and max
    xmin=minval(x) ; xmax=maxval(x)
    ymin=minval(y) ; ymax=maxval(y)
    zmin=minval(z) ; zmax=maxval(z)
    !
    select case(ob%geo)
    case(2)
      ! omp do
      do i=1,ob%nL2
        n1=ob%edges(1,i)
        n2=ob%edges(2,i)
        if(                                                    &
        &       ob%vertx(1,n1)>=xmin .and.ob%vertx(1,n1)<=xmax &
        &  .and.ob%vertx(2,n1)>=ymin .and.ob%vertx(2,n1)<=ymax &
        &                                                      &
        &  .and.ob%vertx(1,n2)>=xmin .and.ob%vertx(1,n2)<=xmax &
        &  .and.ob%vertx(2,n2)>=ymin .and.ob%vertx(2,n2)<=ymax )then
          cmpt=cmpt+1
          ob%edges(3,i)=mark
          ob%mark(n1)  =mark
          ob%mark(n2)  =mark
        endif
      enddo
     ! omp enddo
    case(3)
      ! omp do
      do i=1,ob%nT3
        n1=ob%trian(1,i)
        n2=ob%trian(2,i)
        n3=ob%trian(3,i)
        if(                                                    &
        &       ob%vertx(1,n1)>=xmin .and.ob%vertx(1,n1)<=xmax &
        &  .and.ob%vertx(2,n1)>=ymin .and.ob%vertx(2,n1)<=ymax &
        &  .and.ob%vertx(3,n1)>=zmin .and.ob%vertx(3,n1)<=zmax &
        &                                                      &
        &  .and.ob%vertx(1,n2)>=xmin .and.ob%vertx(1,n2)<=xmax &
        &  .and.ob%vertx(2,n2)>=ymin .and.ob%vertx(2,n2)<=ymax &
        &  .and.ob%vertx(3,n2)>=zmin .and.ob%vertx(3,n2)<=zmax &
        &                                                      &
        &  .and.ob%vertx(1,n3)>=xmin .and.ob%vertx(1,n3)<=xmax &
        &  .and.ob%vertx(2,n3)>=ymin .and.ob%vertx(2,n3)<=ymax &
        &  .and.ob%vertx(3,n3)>=zmin .and.ob%vertx(3,n3)<=zmax )then
          cmpt=cmpt+1
          ob%trian(4,i)=mark
          ob%mark(n1)  =mark
          ob%mark(n2)  =mark
          ob%mark(n3)  =mark
        endif
      enddo
     ! omp enddo
    end select
  end subroutine mesh_dg_vertx_xyz_mark_set

  subroutine mesh_dg_vertx_rtz_mark_set(ob,x,y,mark,cmpt)
    !-----------------------------------
    ! (r, theta, z)
    !-----------------------------------
    type(mesh_dg)               :: ob
    real(8)     , intent(in)    :: x(2)
    real(8)     , intent(in)    :: y(2)
    integer     , intent(in)    :: mark
    integer     , intent(out)   :: cmpt
    !-----------------------------------
    real(8)     , allocatable   :: vertx(:,:)
    integer                     :: i,n1,n2,n3
    real(8)                     :: rmin,zmin,rmax,zmax
    !-----------------------------------
    cmpt=0
    ! min and max
    rmin=minval(x) ; rmax=maxval(x)
    zmin=minval(y) ; zmax=maxval(y)
    !
    allocate(vertx(3,ob%nvert))
    !
    ! omp do
    do i=1,ob%nvert
      vertx(1,i)=sqrt(ob%vertx(1,i)**2+ob%vertx(3,i)**2) ! r=sqrt(x^2+z^2)
      vertx(2,i)=atan2(ob%vertx(1,i),ob%vertx(3,i))      ! theta=atan2(x,z)
      vertx(3,i)=ob%vertx(2,i)                           ! z=y
    enddo
    ! omp enddo
    !
    ! omp do
    do i=1,ob%nT3
      n1=ob%trian(1,i)
      n2=ob%trian(2,i)
      n3=ob%trian(3,i)
      if(                                             &
      &       rmin<=vertx(1,n1).and.vertx(1,n1)<=rmax &
      &  .and.zmin<=vertx(3,n1).and.vertx(3,n1)<=zmax &
      &                                               &
      &  .and.rmin<=vertx(1,n2).and.vertx(1,n2)<=rmax &
      &  .and.zmin<=vertx(3,n2).and.vertx(3,n2)<=zmax &
      &                                               &
      &  .and.rmin<=vertx(1,n3).and.vertx(1,n3)<=rmax &
      &  .and.zmin<=vertx(3,n3).and.vertx(3,n3)<=zmax )then
        cmpt=cmpt+1
        ob%trian(4,i)=mark
        ob%mark(n1)  =mark
        ob%mark(n2)  =mark
        ob%mark(n3)  =mark
      endif
    enddo
    ! omp enddo
    deallocate(vertx)
  end subroutine mesh_dg_vertx_rtz_mark_set

  subroutine mesh_dg_metric_mesh(ob,ascii)
    !------------------------------------------------
   !use m_libmesh4
   !use m_libmesh5
    use M_libmesh5_api
    !------------------------------------------------
    type(mesh_dg)         :: ob
    logical, intent(in)   :: ascii
    !------------------------------------------------
    integer               :: i,j
    integer               :: kind(1),nfield
    character(256)        :: name0
    character(256)        :: command
    real(8), allocatable  :: vertx(:)
    real(8)               :: xmin,xmax
    real(8)               :: ymin,ymax
    real(8)               :: zmin,zmax
    real(8)               :: ax,ay,az
    integer               :: power
    
    integer               :: iGeom
    real(8)               :: x0,y0,z0
    real(8)               :: dx,dy,dz
    real(8)               :: dhx,dhy,dhz,dh,coef
    real(8)               :: hmin,hmax,dhdr
    real(8)               :: rmin,rmax,r
    integer               :: out,res,ver
    integer , allocatable :: TypTab(:)
    real(8)               :: t0,t1
    integer               :: n
    real(8) , allocatable :: x(:),h(:)
    integer               :: ierr
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Building Mesh Metric")')

!    write(*,'(3x,"xmin,ymin,zmin,xmax,ymax,zmax")')
!    write(*,'(3x,"")',advance='no')
!    read(*,*)xmin,ymin,zmin,xmax,ymax,zmax
!    !
!    write(*,'(3x,"hmin,hmax")')
!    write(*,'(3x,"")',advance='no')
!    read(*,*)hmin,hmax
!    !
!    allocate(ob%metri(1,ob%nvert))
!    ob%metri(1,i)=hmax
!
!    !omp do
!    do i=1,ob%nvert
!      if(     (xmin<=ob%vertx(1,i).and.ob%vertx(1,i)<=xmax) &
!      &  .and.(ymin<=ob%vertx(2,i).and.ob%vertx(2,i)<=ymax) &
!      &  .and.(zmin<=ob%vertx(3,i).and.ob%vertx(3,i)<=zmax) )then
!        ob%metri(1,i)=hmin
!      endif
!    enddo
!    !omp enddo

    ob%prec=1

    select case(ob%geo)
    case(2)

      write(*,'(3x,"xmin,ymin,xmax,ymax")')
      write(*,'(3x,"")',advance='no')
      read(*,*)xmin,ymin,xmax,ymax

      write(*,'(3x,"hmin,hmax")')
      write(*,'(3x,"")',advance='no')
      read(*,*)hmin,hmax

      allocate(ob%metri(1,ob%nvert))
 
      !omp do
      do i=1,ob%nvert
        if(     (xmin<=ob%vertx(1,i).and.ob%vertx(1,i)<=xmax) &
        &  .and.(ymin<=ob%vertx(2,i).and.ob%vertx(2,i)<=ymax) )then
          ob%metri(1,i)=hmin
        else
          ob%metri(1,i)=hmax      
        endif
      enddo
      !omp enddo

    case(3)

      allocate(ob%metri(1,ob%nvert))
      ob%metri(:,:)=1d0

      open(unit=500,file='./METRIC.mesh_dg',action='read',status='old',iostat=ierr)
      if( ierr==0 )then
        print '( 3x,"Reading METRIC.mesh_dg")'
      endif

      !
      loopMetric : do 

        if( ierr==0 )then
          read(500,*)iGeom
          select case (iGeom)
          case(1)  ; write(*,'(3x," 1 -> Cylinder axis xx''")')
          case(2)  ; write(*,'(3x," 2 -> Cylinder axis yy''")')
          case(3)  ; write(*,'(3x," 3 -> Cylinder axis zz''")')
          case(4)  ; write(*,'(3x," 4 -> Sphere"            )')
          case(5)  ; write(*,'(3x," 5 -> Linear xx''"       )')
          case(6)  ; write(*,'(3x," 6 -> Elipsoid"          )')
          case(7)  ; write(*,'(3x," 7 -> Box     "          )')
          case(10) ; write(*,'(3x,"10 -> Exit"              )')
          case default ; print '("Error in METRIC.mesh_dg")' ; stop
          end select
        else
          write(*,'(3x," 1 -> Cylinder axis xx''")')
          write(*,'(3x," 2 -> Cylinder axis yy''")')
          write(*,'(3x," 3 -> Cylinder axis zz''")')
          write(*,'(3x," 4 -> Sphere"            )')
          write(*,'(3x," 5 -> Linear xx''"       )')
          write(*,'(3x," 6 -> Elipsoid"          )')
          write(*,'(3x," 7 -> Box"               )')
          write(*,'(3x,"10 -> Exit"              )')
          write(*,'(3x,"")',advance='no')
          read(*,*)iGeom
        endif
        
        !
        select case(iGeom)
        case(1) ; write(*,'(3x,"Your choice is: Cylinder axis xx''")')

          if( ierr==0 )then
            read(500,*)y0,z0
            read(500,*)xMin,xMax
            read(500,*)rmin,rmax
            read(500,*)hmin,hmax

            print '(3x,"y0,z0    "$)'
            print '(3x,2(e22.15,1x))',y0,z0

            print '(3x,"xMin,xMax"$)'
            print '(3x,2(e22.15,1x))',xMin,xMax

            print '(3x,"rmin,rmax"$)'
            print '(3x,2(e22.15,1x))',rmin,rMax

            print '(3x,"hmin,hmax"$)'
            print '(3x,2(e22.15,1x))',hmin,hMax

          else
            write(*,'(3x,"y0,z0")')
            write(*,'(3x,"")',advance='no')
            read(*,*)y0,z0

            write(*,'(3x,"xMin,xMax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)xMin,xMax

            write(*,'(3x,"rmin,rmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)rmin,rmax

            write(*,'(3x,"hmin,hmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)hmin,hmax

          endif
          !
          allocate(vertx(ob%nvert))
!          !$omp parallel private(i,dx,dy,dz) shared(vertx)
!          !$omp do
          do i=1,ob%nvert
            !
!            print '("i=",i4,3x,"x=",f12.5)',i,ob%vertx(1,i)
            !
            if    (                         ob%vertx(1,i)< xMin )then ; dx=(xMin-ob%vertx(1,i)) 
            elseif( xMin<=ob%vertx(1,i).and.ob%vertx(1,i)<=xMax )then ; dx=0d0
            elseif( xMax< ob%vertx(1,i)                         )then ; dx=(ob%vertx(1,i)-xMax)
            endif
            !
            dy=ob%vertx(2,i)-y0
            dz=ob%vertx(3,i)-z0
            !
            vertx(i)=sqrt(dx*dx+dy*dy+dz*dz)

           !if( dx/=0d0 )print '("dx=",f12.5)',dx
          enddo
!          !$omp enddo
!          !$omp end parallel



          if( rmin/=rmax )dhdr=(hmax-hmin)/(rmax-rmin)
         !$omp parallel private(i) shared(vertx,ob,rMin,rMax,hmin)
         !$omp do
          do i=1,ob%nvert
            if( vertx(i)<=rmin )then
              ob%metri(1,i)=ob%metri(1,i)*hmin
            else if( rmin<vertx(i).and.vertx(i)<rmax )then
              ob%metri(1,i)=ob%metri(1,i)*(hmin+dhdr*(vertx(i)-rmin))
            else
              ob%metri(1,i)=ob%metri(1,i)*hmax
            endif
          enddo
         !$omp enddo
         !$omp end parallel

          deallocate(vertx)

          
        case(2) ; write(*,'(3x,"Your choice is: Cylinder axis yy''")')
          
          write(*,'(3x,"x0,z0")')
          write(*,'(3x,"")',advance='no')
          read(*,*)x0,z0

          allocate(vertx(ob%nvert))
         !$omp parallel private(i,dx,dy,dz) shared(vertx)
         !$omp do
          do i=1,ob%nvert
            dx=ob%vertx(1,i)-x0
            dz=ob%vertx(3,i)-z0
            vertx(i)=sqrt(dx*dx+dz*dz)
          enddo
         !$omp enddo
         !$omp end parallel

          write(*,'(3x,"rmin,rmax")')
          write(*,'(3x,"")',advance='no')
          read(*,*)rmin,rmax

          write(*,'(3x,"hmin,hmax")')
          write(*,'(3x,"")',advance='no')
          read(*,*)hmin,hmax

          if( rmin/=rmax )dhdr=(hmax-hmin)/(rmax-rmin)
          ! omp do
          do i=1,ob%nvert
            if( vertx(i)<=rmin )then
              ob%metri(1,i)=ob%metri(1,i)*hmin
            else if( rmin<vertx(i).and.vertx(i)<rmax )then
              ob%metri(1,i)=ob%metri(1,i)*(hmin+dhdr*(vertx(i)-rmin))
            else
              ob%metri(1,i)=ob%metri(1,i)*hmax
            endif
          enddo
          ! omp enddo
          deallocate(vertx)
         
        case(3) ; write(*,'(3x,"Your choice is: Cylinder axis zz''")')
          
          write(*,'(3x,"x0,y0")')
          write(*,'(3x,"")',advance='no')
          read(*,*)x0,y0
          
          allocate(vertx(ob%nvert))
         !$omp parallel private(i,dx,dy,dz) shared(vertx)
         !$omp do
          do i=1,ob%nvert
            dx=ob%vertx(1,i)-x0
            dy=ob%vertx(2,i)-y0
            vertx(i)=sqrt(dx*dx+dy*dy)
          enddo
         !$omp enddo
         !$omp end parallel
          
        case(4) ; write(*,'(3x,"Your choice is: Sphere")')
          
          if( ierr==0 )then
            read(500,*)x0,y0,z0
            read(500,*)rmin,rmax
            read(500,*)hmin,hmax

            print '(3x,"x0,y0,z0")'
            print '(3x,3(e22.15,1x))',x0,y0,z0

            write(*,'(3x,"rmin,rmax")')
            print '(2(e22.15,1x))',rmin,rmax

            write(*,'(3x,"hmin,hmax")')
            print '(2(e22.15,1x))',hmin,hmax

          else
            write(*,'(3x,"x0,y0,z0")')
            write(*,'(3x,"")',advance='no')
            read(*,*)x0,y0,z0

            write(*,'(3x,"rmin,rmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)rmin,rmax

            write(*,'(3x,"hmin,hmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)hmin,hmax
          endif
          
          allocate(vertx(ob%nvert))
         !$omp parallel private(i,dx,dy,dz) shared(vertx)
         !$omp do
          do i=1,ob%nvert
            dx=ob%vertx(1,i)-x0
            dy=ob%vertx(2,i)-y0
            dz=ob%vertx(3,i)-z0
            vertx(i)=sqrt(dx*dx+dy*dy+dz*dz)
          enddo
         !$omp enddo
         !$omp end parallel


          if( rmin/=rmax )dhdr=(hmax-hmin)/(rmax-rmin)
          ! omp do
          do i=1,ob%nvert
            if( vertx(i)<=rmin )then
              ob%metri(1,i)=ob%metri(1,i)*hmin
            else if( rmin<vertx(i).and.vertx(i)<rmax )then
              ob%metri(1,i)=ob%metri(1,i)*(hmin+dhdr*(vertx(i)-rmin))
            else
              ob%metri(1,i)=ob%metri(1,i)*hmax
            endif
          enddo
          ! omp enddo
          deallocate(vertx)

        case(5) ; write(*,'(5x,"Your choice is: Linear xx''")')

          write(*,'(3x,"Number of x")')
          write(*,'(3x,"")',advance='no')
          read(*,*)n

          write(*,'(3x,"Enter x_i from smaller to bigger" )')
          allocate(x(n),h(n))
          do i=1,n
            write(*,'( 3x,"x(",i2,") - h(",i2,")" )')i,i
            write(*,'(3x,"")',advance='no')
            read(*,*)x(i),h(i)
          enddo
          
         !$omp parallel private(i,j)
         !$omp do
          do i=1,ob%nvert
            !
            do j=1,n
              if( ob%vertx(1,i)<x(j) )exit
            enddo
            !
            if    ( j==1 )then
              ob%metri(1,i)=ob%metri(1,i)*h(1)
            elseif( j==n .and. x(j)<=ob%vertx(1,i) )then
              ob%metri(1,i)=ob%metri(1,i)*h(n)
            else
              ob%metri(1,i)=ob%metri(1,i)*( h(j-1)+ (h(j)-h(j-1))*( ob%vertx(1,i)-x(j-1) )/( x(j)-x(j-1) ) )
            endif
          enddo
         !$omp enddo
         !$omp end parallel
         
         deallocate(x,h)
            
        case(06) ; write(*,'(3x,"Your choice is: Elipsoid")')
        
          if( ierr==0 )then
            read(500,*)x0,y0,z0
            read(500,*)ax,ay,az
            read(500,*)rmin,rmax
            read(500,*)hmin,hmax

            print '(3x,"x0,y0,z0 =",3(e22.15,1x))',x0,y0,z0
            print '(3x,"ax,ay,az =",3(e22.15,1x))',ax,ay,az
            print '(3x,"rmin,rmax=",2(e22.15,1x))',rmin,rmax
            print '(3x,"hmin,hmax=",2(e22.15,1x))',hmin,hmax

          else
            write(*,'(3x,"x0,y0,z0")')
            write(*,'(3x,"")',advance='no')
            read(*,*)x0,y0,z0

            write(*,'(3x,"ax,ay,az")')
            write(*,'(3x,"")',advance='no')
            read(*,*)ax,ay,az

            write(*,'(3x,"rmin,rmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)rmin,rmax

            write(*,'(3x,"hmin,hmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)hmin,hmax
          endif


          allocate(vertx(ob%nvert))
          do i=1,ob%nvert
            dx=(ob%vertx(1,i)-x0)/ax
            dy=(ob%vertx(2,i)-y0)/ay
            dz=(ob%vertx(3,i)-z0)/az
            vertx(i)=(dx**2+dy**2+dz**2)**(1d0/2d0)
           !vertx(i)=(dx**4+dy**4+dz**4)**(1d0/4d0)
          enddo

          if( rmin/=rmax )dhdr=(hmax-hmin)/(rmax-rmin)
          do i=1,ob%nvert
            if( vertx(i)<=rmin )then
              ob%metri(1,i)=ob%metri(1,i)*hmin
            else if( rmin<vertx(i).and.vertx(i)<rmax )then
              ob%metri(1,i)=ob%metri(1,i)*(hmin+dhdr*(vertx(i)-rmin))
            else
              ob%metri(1,i)=ob%metri(1,i)*hmax
            endif
          enddo
          deallocate(vertx)


        case(07) ; write(*,'(3x,"Your choice is: Box")')
        
          if( ierr==0 )then
            read(500,*)x0,y0,z0
            read(500,*)xmin,xmax
            read(500,*)ymin,ymax
            read(500,*)zmin,zmax
            read(500,*)dx,dy,dz
            read(500,*)hmin,hmax

            print '(3x,"x0,y0,z0  =",3(e22.15,1x))',x0,y0,z0
            print '(3x,"xmin,xmax =",2(e22.15,1x))',xmin,xmax
            print '(3x,"ymin,ymax =",2(e22.15,1x))',ymin,ymax
            print '(3x,"zmin,zmax =",2(e22.15,1x))',zmin,zmax
            print '(3x,"dx,dy,dz  =",3(e22.15,1x))',dx,dy,dz
            print '(3x,"hmin,hmax =",2(e22.15,1x))',hmin,hmax

          else

            write(*,'(3x,"x0,y0,z0")')
            write(*,'(3x,"")',advance='no')
            read(*,*)x0,y0,z0

            write(*,'(3x,"xmin,xmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)xmin,xmax

            write(*,'(3x,"ymin,ymax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)ymin,ymax

            write(*,'(3x,"zmin,zmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)zmin,zmax

            write(*,'(3x,"dx,dy,dz")')
            write(*,'(3x,"")',advance='no')
            read(*,*)dx,dy,dz

            write(*,'(3x,"hmin,hmax")')
            write(*,'(3x,"")',advance='no')
            read(*,*)hmin,hmax
          endif

          dh=hmin-hmax

          ob%vertx(1,:)=ob%vertx(1,:)-x0
          ob%vertx(2,:)=ob%vertx(2,:)-y0
          ob%vertx(3,:)=ob%vertx(3,:)-z0          
          do i=1,ob%nvert
            !
            if(      (xmin<=ob%vertx(1,i) .and. ob%vertx(1,i)<=xmax) &
            &  .and. (ymin<=ob%vertx(2,i) .and. ob%vertx(2,i)<=ymax) &
            &  .and. (zmin<=ob%vertx(3,i) .and. ob%vertx(3,i)<=zmax) )then
              
              ob%metri(1,i)=ob%metri(1,i)*hmin
              
            elseif(      (ob%vertx(1,i)<xmin-dx .or. xmax+dx<ob%vertx(1,i)) &
            &      .or.  (ob%vertx(2,i)<ymin-dy .or. ymax+dy<ob%vertx(2,i)) &
            &      .or.  (ob%vertx(3,i)<zmin-dz .or. zmax+dz<ob%vertx(3,i)) )then
              
              ob%metri(1,i)=ob%metri(1,i)*hmax
              
            else
              
              if    ( (xmin   <=ob%vertx(1,i) .and. ob%vertx(1,i)<=xmax   ) )then
                dhx=0d0
              elseif( (xmin-dx<=ob%vertx(1,i) .and. ob%vertx(1,i)<=xmax+dx) )then
                dhx=min(ob%vertx(1,i)-xmin,xmax-ob%vertx(1,i))/dx*dh
              endif

              if    ( (ymin   <=ob%vertx(2,i) .and. ob%vertx(2,i)<=ymax   ) )then
                dhy=0d0
              elseif( (ymin-dy<=ob%vertx(2,i) .and. ob%vertx(2,i)<=ymax+dy) )then
                dhy=min(ob%vertx(2,i)-ymin,ymax-ob%vertx(2,i))/dy
              endif

              if    ( (zmin   <=ob%vertx(3,i) .and. ob%vertx(3,i)<=zmax   ) )then
                dhz=0d0
              elseif( (zmin-dz<=ob%vertx(3,i) .and. ob%vertx(3,i)<=zmax+dz) )then
                dhz=min(ob%vertx(3,i)-zmin,zmax-ob%vertx(3,i))/dz
              endif
              !
              coef=sqrt(dhx*dhx+dhy*dhy+dhz*dhz)
              if( coef>1d0 ) &
              & print '("dhx,dhy,dhz=",3(e22.15,1x),"norm=",e22.15)',dhx,dhy,dhz,coef

              ob%metri(1,i)=ob%metri(1,i)*(hmin+coef*dh)

            endif

          enddo
          
          ob%vertx(1,:)=ob%vertx(1,:)+x0
          ob%vertx(2,:)=ob%vertx(2,:)+y0
          ob%vertx(3,:)=ob%vertx(3,:)+z0
        
        case(10) ; write(*,'(5x,"Your choice is: Exit")')
          exit loopMetric
        end select


      enddo loopMetric

    end select
    close(500)

    if( ascii )then
      name0="metric.mesh"
    else
      name0="metric.meshb"
    endif
    write(ob%nlog,'(3x,"Writing Metric mesh file: ",a)')trim(name0)
    write(*,'( 3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10 )')ob%nL2


    ver=2
    out=GmfOpenMeshF77(trim(name0),GmfWrite,ver,ob%geo)
    ! vertices
    if( ob%nvert/=0 )then
      res=GmfSetKwdF77(out,GmfVertices,ob%nvert,0,TypTab)
      select case(ob%geo)
      case(2)
        do i=1,ob%nvert
          call GmfSetVertex2Dr8(out,ob%vertx(1,i),ob%vertx(2,i),ob%mark(i))
        enddo
      case(3)
        do i=1,ob%nvert
          call GmfSetVertex3dr8(out,ob%vertx(1,i),ob%vertx(2,i),ob%vertx(3,i),ob%mark(i))
        enddo
      end select
    endif
    ! tetrahedra
    if( ob%nT4/=0 )then
      res=GmfSetKwdF77(out,GmfTetrahedra,ob%nT4,ver,TypTab)
      do i=1,ob%nT4
        call GmfSetTetrahedron(out,ob%tetra(1,i),ob%tetra(2,i),ob%tetra(3,i),ob%tetra(4,i),ob%tetra(5,i))
      enddo      
    endif
    ! triangles
    if( ob%nT3/=0 )then
      res=GmfSetKwdF77(out,GmfTriangles,ob%nT3,ver,TypTab)
      do i=1,ob%nT3
        call GmfSetTriangle(out,ob%trian(1,i),ob%trian(2,i),ob%trian(3,i),ob%trian(4,i))
      enddo      
    endif
    ! edges
    if( ob%nL2/=0 )then
      res=GmfSetKwdF77(out,GmfEdges,ob%nL2,ver,TypTab)
      do i=1,ob%nL2
        call GmfSetEdge(out,ob%edges(1,i),ob%edges(2,i),ob%edges(3,i))
      enddo      
    endif
    res = GmfCloseMeshf77(out)
    ! <<< libmesh5 <<<


    if( ascii )then
      name0="metric.sol"
    else
      name0="metric.solb"
    endif
    write(ob%nlog,'(3x,"Writing Metric solu file: ",a)')trim(name0)
    if( ob%nfld/=0 )write(ob%nlog,'(3x,a,i10)')'Number of fields:      ',1
    if( ob%nsol/=0 )write(ob%nlog,'(3x,a,i10)')'Number of sol@vertx:   ',ob%nvert


    ver=2 ; nfield=1 ; kind(1)=1
    out=GmfOpenMeshF77(trim(name0),GmfWrite,ver,ob%geo)
    res=GmfSetKwdF77(out,GmfSolAtVertices,ob%nvert,nfield,kind)
    do i=1,ob%nvert
      call gmfSetSolAtVertexR8(out,ob%metri(1,i))
    enddo
    res=GmfCloseMeshf77(out)
    ! <<< libmesh5 <<<

    deallocate(ob%metri)
    call cpu_time(t1)
    write(ob%nlog,'("End Building Mesh Metric - CPU =",e12.5," s")')t1-t0
    stop
  end subroutine mesh_dg_metric_mesh

  subroutine mesh_dg_nomal_set(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    integer               :: i
    real(8)               :: t0,t1
    real(8)               :: v12(3),v13(3),nx,ny,nz,inv_norm
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Building Mesh Normals")')
    select case(ob%geo)
    case(2)
      if( ob%nL2/=0 )then
        allocate(ob%norms(2,ob%nL2))
        !
        !omp do private(nx,ny,inv_norm)
        do i=1,ob%nL2
          nx=ob%vertx(2,ob%edges(2,i))-ob%vertx(2,ob%edges(1,i))
          ny=ob%vertx(1,ob%edges(1,i))-ob%vertx(1,ob%edges(2,i))
          inv_norm=1d0/sqrt(nx*nx+ny*ny)
          ob%norms(1,i)=inv_norm*nx
          ob%norms(2,i)=inv_norm*ny
        enddo
        !omp enddo
        !
      endif

    case(3)
      if( ob%nT3/=0 )then
        allocate(ob%norms(3,ob%nT3))

        !omp do private(v12,v13,nx,ny,nz,inv_norm)
        do i=1,ob%nT3
          v12(1:3)=[ob%vertx(1,ob%trian(2,i))-ob%vertx(1,ob%trian(1,i)) ,&
          &         ob%vertx(2,ob%trian(2,i))-ob%vertx(2,ob%trian(1,i)) ,&
          &         ob%vertx(3,ob%trian(2,i))-ob%vertx(3,ob%trian(1,i))  ]

          v13(1:3)=[ob%vertx(1,ob%trian(3,i))-ob%vertx(1,ob%trian(1,i)) ,&
          &         ob%vertx(2,ob%trian(3,i))-ob%vertx(2,ob%trian(1,i)) ,&
          &         ob%vertx(3,ob%trian(3,i))-ob%vertx(3,ob%trian(1,i))  ]
          !
          nx=v12(2)*v13(3)-v12(3)*v13(2)
          ny=v12(3)*v13(1)-v12(1)*v13(3)
          nz=v12(1)*v13(2)-v12(2)*v13(1)    
          !
          inv_norm=1d0/sqrt(nx*nx+ny*ny+nz*nz)
          ob%norms(1,i)= inv_norm*nx
          ob%norms(2,i)= inv_norm*ny
          ob%norms(3,i)= inv_norm*nz
        enddo
        !omp enddo
      endif

    end select

    call cpu_time(t1)
    write(ob%nlog,'("End Building Mesh Normals - CPU =",e12.5,"s")')t1-t0

  end subroutine mesh_dg_nomal_set

  function mesh_dg_nT3_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: out
    !-----------------------------------
    out=ob%nT3
  end function mesh_dg_nT3_get

  subroutine mesh_dg_nT3_set(ob,in)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: in
    !-----------------------------------
    ob%nT3=in
  end subroutine mesh_dg_nT3_set

  function mesh_dg_nT4_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: out
    !-----------------------------------
    out=ob%nT4
  end function mesh_dg_nT4_get

  subroutine mesh_dg_nT4_set(ob,in)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: in
    !-----------------------------------
    ob%nT4=in
  end subroutine mesh_dg_nT4_set

  function mesh_dg_nVert_get(ob) result(out)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: out
    !-----------------------------------
    out=ob%nVert
  end function mesh_dg_nVert_get

  subroutine mesh_dg_nVert_set(ob,in)
    !-----------------------------------
    type(mesh_dg) :: ob
    integer       :: in
    !-----------------------------------
    ob%nVert=in
  end subroutine mesh_dg_nVert_set


  subroutine mesh_dg_read_mesh_actran(ob)
    !-----------------------------------
    type(mesh_dg)         :: ob
    !-----------------------------------
    integer               :: i,j
    integer               :: i0,i1,i2,ne,nn,geo,i0min,i0max
    integer , allocatable :: idx(:)
    integer , allocatable :: nd(:,:)
    real(8)               :: x,y,z
    character(256)        :: name,plot_name
    real(8)               :: t0,t1
    integer               :: iostat
    character(80)         :: ligne
    character(80)         :: word(4)
    logical               :: solution=.false.
    real(8) , allocatable :: u0(:,:)
    real(8) , allocatable :: r0(:)
    real(8) , allocatable :: p0(:)
    real(8)               :: a00,r00,cp0,cv0
    real(8)               :: freq
    integer               :: iAxi
    integer               :: nT3
    integer, allocatable  :: trian(:,:)
    integer               :: iMark
    integer               :: iter
    integer               :: iCell
    integer               :: sumNdMax,sumNd,minNd,maxNd,previous
    integer , allocatable :: key(:),link(:),maxNds(:),minNds(:)
    !-----------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Reading Mesh (actran format)")')
    !
    name=ob%mesh_name
    ob%mesh_name='actran'
    ob%nT3=0
    ob%nQ4=0
    ob%nT4=0
    !
    plot_name='actran.plt'
    open(unit=10,file=trim(name),action='read',status='old')
    readingMeshActran : do
      read(10,'(a)',iostat=iostat)ligne
      if( is_iostat_end(iostat) )exit readingMeshActran
     !write(*,*)trim(ligne)
      select case(trim(ligne))
      case("")
      case("BEGIN ACTRAN")

      case("BEGIN FREQUENCY_DOMAIN") ; read(10,*)freq
      case("END FREQUENCY_DOMAIN"  )

      case("BEGIN AXISYMMETRY")      ; read(10,*)iAxi
      case("END AXISYMMETRY"  )
      
      case("COMMENT_START")
        readingMeshActranComment : do
          read(10,'(a80)',iostat=iostat)ligne
          if( is_iostat_end(iostat) )exit readingMeshActranComment
          if( trim(ligne)=="COMMENT_STOP" )exit readingMeshActranComment
          write(*,*)trim(ligne)
        enddo readingMeshActranComment

      case("BEGIN TITLE")
        read(10,*)word(1)
        ob%mesh_name=trim(word(1))
        read(10,*)
        !
        !
      case("END TITLE")
        !
        !
      case("BEGIN MESH"  )
        read(10,*)ob%nvert,ne,ob%geo
        write(*,'(3x,"Geometry: ",i1,"D"       )')ob%geo
        !
        read(10,*) ! BEGIN NODE
        write(*,'(3x,"Number of vertices: ",i10)')ob%nvert
        allocate(idx     (10*ob%nvert    )) ; idx     (:  )=0.
        allocate(ob%vertx(ob%geo,ob%nvert)) ; ob%vertx(:,:)=0.
        allocate(ob%mark (       ob%nvert)) ; ob%mark (:  )=0
        !
        select case(ob%geo)
        case(2)
          do i=1,ob%nvert
            read(10,*)i0,ob%vertx(1:2,i) 
            idx(i0)=i
            ob%mark(i)=0
          enddo
        case(3)
          do i=1,ob%nvert
            read(10,*)i0,ob%vertx(1:3,i)
            idx(i0)=i
            ob%mark(i)=0
          enddo
        end select
        read(10,*) ! END NODE
        !
        read(10,*) ! BEGIN ELEMENT
        write(*,'(3x,"Number of cells:    ",i10)')ne
        allocate(nd(13,ne))
        ob%nH6=0
        ob%nT4=0
        ob%nQ4=0
        ob%nT3=0
        ob%nL2=0
        do i=1,ne
          read(10,'(3i10)',advance='no')nd(1:3,i)
          select case(nd(2,i))
          case(12) ! hexahedron Q1
            ob%nH6=ob%nH6+1
            read(10,'(8i10)')nd(4:11,i)
            do j=4,11 ;  nd(j,i)=idx(nd(j,i)) ; enddo
            write(*,'(3x,a,8i10)')'h6=',nd(4:11,i)
          case(09) ! tetra P2
            ob%nT4=ob%nT4+1
            read(10,'(10i10)')nd(4:13,i)
            nd( 4,i)=idx(nd( 4,i))
            nd( 6,i)=idx(nd( 6,i))
            nd( 8,i)=idx(nd( 8,i))
            nd(13,i)=idx(nd(13,i))
          case(06) ! quadrangle
            ob%nQ4=ob%nQ4+1
            read(10,'(4i10)')nd(4:7,i)
            do j=4,7 ;  nd(j,i)=idx(nd(j,i)) ; enddo
            write(*,'(3x,a,4i10)')'q4=',nd(4:7,i)
          case(04) ! triangle
            ob%nT3=ob%nT3+1
            read(10,'(3i10)')nd(4:6,i)
            do j=4,6 ;  nd(j,i)=idx(nd(j,i)) ; enddo
            write(*,'(3x,a,3i10)')'t3=',nd(4:6,i)
          case default
            write(*,'("Cell: ",i10," is of unknown kind: ",i2)')i,nd(2,i)
            stop
          end select
        enddo
        !
        if( ob%nH6/=0 )allocate(ob%hexas(9,ob%nH6)) ! ob%nH6=0
        if( ob%nT4/=0 )allocate(ob%tetra(5,ob%nT4)) ; ob%nT4=0
        if( ob%nQ4/=0 )allocate(ob%quadr(5,ob%nQ4)) ! ob%nQ4=0
        if( ob%nT3/=0 )allocate(ob%trian(4,ob%nT3)) ! ob%nT3=0
        if( ob%nL2/=0 )allocate(ob%edges(3,ob%nL2)) ! ob%nL2=0
        !
        do i=1,ne
          select case(nd(2,i))
          case(12) ! hexahedron
           !ob%nH6=ob%nH6+1
            ob%hexas(1:9,nd(1,i))=[nd(4:11,i),nd(3,i)]
          case( 9) ! tetra
            ob%nT4=ob%nT4+1
            ob%tetra(1:5,ob%nT4)=[nd(4,i),nd(6,i),nd(8,i),nd(13,i), nd(3,i)]
            !ob%tetra(1:5,nd(1,i))=[nd(4,i),nd(6,i),nd(8,i),nd(13,i), nd(3,i)]
          case( 6) ! quadrangle
           !ob%nQ4=ob%nQ4+1
            ob%quadr(1:5,nd(1,i))=[nd(4:7,i),nd(3,i)]
          case( 4) ! triangle
           !ob%nT3=ob%nT3+1
            ob%trian(1:4,nd(1,i))=[nd(4:6,i),nd(3,i)]
          end select
        enddo
        deallocate(nd)
        read(10,*)   ! END ELEMENT
        read(10,*)   ! END MESH
        !
        if( ob%nT4/=0 .and. ob%nT3==0 )then
          !
          call build_skin(ob=ob,mark0=10)
          !
          sumNdMax=0
          allocate(maxNds(ob%nT3),minNds(ob%nT3))
          do i=1,ob%nT3
            sumNd=    ob%trian(1,i)+ob%trian(2,i)+ob%trian(3,i)
            minNd=min(ob%trian(1,i),ob%trian(2,i),ob%trian(3,i))
            maxNd=max(ob%trian(1,i),ob%trian(2,i),ob%trian(3,i))
            !
            minNds(i)=minNd ; maxNds(i)=maxNd
            if( sumNd>sumNdMax)sumNdMax=sumNd
          enddo
          !
          ! Building Hash table for Triangular Cells
          allocate(key(sumNdMax)) ; key=0
          allocate(link(ob%nT3))  ; link=0
          !
          do i=1,ob%nT3
            sumNd=ob%trian(1,i)+ob%trian(2,i)+ob%trian(3,i) ! The hash Key
            iCell=key(sumNd)
            if( iCell==0 )then      ! First Entry
              key(sumNd)=i
            else                    ! linking Triangles with same Hash Key
              iterLink : do
                if( link(iCell)==0 )exit iterLink
                iCell=link(iCell)
              enddo iterLink
              link(iCell)=i
            endif
          enddo
        endif
        !
        !
      case("BEGIN FIELD_MESH"  ) ; read(10,*)nn,ne,geo
        read(10,*) ! BEGIN NODE
        do i=1,nn
          read(10,*)
        enddo
        read(10,*) ! END NODE
        read(10,*) ! BEGIN ELEMENT
        do i=1,ne
          read(10,*)
        enddo
        read(10,*) ! END ELEMENT
        read(10,*) ! END FIELD_MESH
        !
        !
      case("BEGIN INFINITE_MESH")
        read(10,*)ne
        read(10,*) ! BEGIN INFINITE_ELEMENT
        allocate(nd(8,ne))
        iMark=5
        nT3=0
        write(*,'(3x,"Number of cells ",i2," :",i10)')5,ne
        do i=1,ne
          read(10,'(2i10)',advance='no')nd(1:2,i)
          select case(nd(1,i))
          case(3)
            nT3=nT3+1
            read(10,'(3i10)')nd(3:5,i)
            do j=4,6 ;  nd(j,i)=idx(nd(j,i)) ; enddo
          case(6)
            nT3=nT3+1
            read(10,'(6i10)')nd(3:8,i)
            nd(3,i)=idx(nd(3,i))
            nd(5,i)=idx(nd(5,i))
            nd(7,i)=idx(nd(7,i))
          end select
        enddo
        !
        if( nT3/=0 )then
          do i=1,ne
            select case(nd(1,i))
            case(3)
              sumNd=    nd(3,i)+nd(4,i)+nd(5,i)
              minNd=min(nd(3,i),nd(4,i),nd(5,i))
              maxNd=max(nd(3,i),nd(4,i),nd(5,i))
            case(6)
              sumNd=    nd(3,i)+nd(5,i)+nd(7,i)
              minNd=min(nd(3,i),nd(5,i),nd(7,i))
              maxNd=max(nd(3,i),nd(5,i),nd(7,i))
            end select
            !
            iter=1
            iCell=key(sumNd)
            searchCell : do
              if( iCell==0 )then
                 write(*,'("link(iCell)==0")')
                 write(*,'(3x,"iCell=",i10," - iter=",i10," - Nd:",3i10)')iCell,iter,ob%trian(1:3,iCell)
                exit searchCell
              endif
              if( minNd==minNds(iCell) .and. maxNd==maxNds(iCell) )exit searchCell
              iter=iter+1
              if( iter==ob%nT3 )stop ' Cell not Found'
              iCell=link(iCell)
            enddo searchCell
            if( iCell/=0 )ob%trian(4,iCell)=iMark
            !
          enddo
        endif
        !
        deallocate(nd)
        read(10,*) ! END INFINITE_ELEMENT
        read(10,*) ! END INFINITE_MESH
        !
        !
      case("BEGIN MODAL_SURFACE")
        read(10,*)ne
        allocate(nd(8,ne))
        iMark=60
        nT3=0
        write(*,'(3x,"Number of cells ",i2," :",i10)')iMark,ne
        do i=1,ne
          read(10,'(2i10)',advance='no')nd(1:2,i)
          select case(nd(1,i))
          case(3)
            nT3=nT3+1
            read(10,'(3i10)')nd(3:5,i)
            do j=4,6 ;  nd(j,i)=idx(nd(j,i)) ; enddo
          case(6)
            nT3=nT3+1
            read(10,'(6i10)')nd(3:8,i)
            nd(3,i)=idx(nd(3,i))
            nd(5,i)=idx(nd(5,i))
            nd(7,i)=idx(nd(7,i))
          end select
        enddo
        !
        if( nT3/=0 )then
          do i=1,ne
            select case(nd(1,i))
            case(3)
              sumNd=    nd(3,i)+nd(4,i)+nd(5,i)
              minNd=min(nd(3,i),nd(4,i),nd(5,i))
              maxNd=max(nd(3,i),nd(4,i),nd(5,i))
            case(6)
              sumNd=    nd(3,i)+nd(5,i)+nd(7,i)
              minNd=min(nd(3,i),nd(5,i),nd(7,i))
              maxNd=max(nd(3,i),nd(5,i),nd(7,i))
            end select
            !
            iter=1
            iCell=key(sumNd)
            searchCellMod : do
              if( iCell==0 )then
                 write(*,'(3x,"link(iCell)==0  - iCell=",i10," - iter=",i10," - Nd:",3i10)')iCell,iter,ob%trian(1:3,iCell)
                exit searchCellMod
              endif
              if( minNd==minNds(iCell) .and. maxNd==maxNds(iCell) )exit searchCellMod
              iter=iter+1
              if( iter==ob%nT3 )stop ' Cell not Found'
              iCell=link(iCell)
            enddo searchCellMod
            if( iCell/=0 )ob%trian(4,iCell)=iMark+nd(2,i)
            !
          enddo
        endif
        !
        deallocate(nd)
        read(10,*) ! END MODAL_SURFACE
        !
        !
      case("BEGIN BOUNDARY_CONDITION")
        !
        Admittance : do
          read(10,'(a80)',iostat=iostat)ligne
          if( trim(ligne)=="END BOUNDARY_CONDITION" )exit Admittance
          !
          select case(trim(ligne))
          case("BEGIN ADMITTANCE 1") ; iMark=11
          case("BEGIN ADMITTANCE 2") ; iMark=12
          case("BEGIN ADMITTANCE 3") ; iMark=13
          case("BEGIN ADMITTANCE 4") ; iMark=14
          case("BEGIN ADMITTANCE 5") ; iMark=15
          case("BEGIN ADMITTANCE 6") ; iMark=16
          case("BEGIN ADMITTANCE 7") ; iMark=17
          case("BEGIN ADMITTANCE 8") ; iMark=18
          case("BEGIN ADMITTANCE 9") ; iMark=19
          end select
          read(10,*)
          !
          read(10,*)ne
          allocate(nd(8,ne))
          write(*,'(3x,"Number of cells ",i2," :",i10)')iMark,ne
          !
          nT3=0
          do i=1,ne
            read(10,'(1i10)',advance='no')nd(1,i)
            select case(nd(1,i))
            case(3)
              nT3=nT3+1
              read(10,'(3i10)')nd(3:5,i)
              do j=3,5 ;  nd(j,i)=idx(nd(j,i)) ; enddo
            case(6)
              nT3=nT3+1
              read(10,'(6i10)')nd(3:8,i)
              read(10,*       )
              nd(3,i)=idx(nd(3,i))
              nd(5,i)=idx(nd(5,i))
              nd(7,i)=idx(nd(7,i))
            end select
          enddo
          !
          !
          if( nT3/=0 )then
            do i=1,ne
              select case(nd(1,i))
              case(3)
                sumNd=    nd(3,i)+nd(4,i)+nd(5,i)
                minNd=min(nd(3,i),nd(4,i),nd(5,i))
                maxNd=max(nd(3,i),nd(4,i),nd(5,i))
              case(6)
                sumNd=    nd(3,i)+nd(5,i)+nd(7,i)
                minNd=min(nd(3,i),nd(5,i),nd(7,i))
                maxNd=max(nd(3,i),nd(5,i),nd(7,i))
              end select
              !
              iter=1
              iCell=key(sumNd)
              searchCellAdm : do
                if( iCell==0 )then
                   write(*,'(3x,"link(iCell)==0  - iCell=",i10," - iter=",i10," - Nd:",3i10)')iCell,iter,ob%trian(1:3,iCell)
                  exit searchCellAdm
                endif
                if( minNd==minNds(iCell) .and. maxNd==maxNds(iCell) )exit searchCellAdm
                iter=iter+1
                if( iter==ob%nT3 )stop ' Cell not Found'
                iCell=link(iCell)
              enddo searchCellAdm
              if( iCell/=0 )ob%trian(4,iCell)=iMark
            enddo
          endif
          !
          deallocate(nd)
          read(10,*) ! "END ADMITTANCE"
        enddo Admittance

       case("BEGIN RADIATING_SURFACE 1")
        read(10,*)ne
        do i=1,ne
          read(10,*)
        enddo
        read(10,*) ! END RADIATING_SURFACE 1
        !
        !
      case("BEGIN OUTPUT_FRF")
        read(10,*)plot_name
        
      case("      BEGIN FIELD_POINT")
        read (10,*)ne
        open (20,file='actran.plt',action='write')
        write(20,'("dim" )')
        write(20,'(i10/  )')ne
        write(20,'("plot")')
        !
        fieldPoint : do
          read (10,*)ligne
          if(trim(ligne)=="    END FIELD_POINT")exit fieldPoint
          write(20,*)ligne
        enddo fieldPoint
        !
        write(20,'(/"end")')
        close(20)
        
      case("END OUTPUT_FRF")

      case("BEGIN MATERIAL 1")
        read(10,*)word(1)
        select case(trim(word(1)))
        case("FLUID")
          fluid : do
            read(10,'(a80)',iostat=iostat)ligne
            select case(trim(ligne))
            case("END MATERIAL 1") ; exit fluid
            case default
              read(ligne,*)word(2),x
              select case(trim(word(2)))
              case("SOUND_SPEED"   ) ; a00=x ; write(*,'(3x,"a00=",f7.2)')a00
              case("FLUID_DENSITY" ) ; r00=x ; write(*,'(3x,"r00=",f7.2)')r00
              case("CP"            ) ; cp0=x ; write(*,'(3x,"cp =",f7.2)')cp0
              case("CV"            ) ; cv0=x ; write(*,'(3x,"cv =",f7.2)')cv0
              end select
            end select
          enddo fluid     

        case default
          write(*,'("stop @ mesh_dg_read_mesh_actran")')
          write(*,'("unknown material: ",a)')trim(word(1))
          stop
        end select

      case("END ACTRAN")

      case default

        read(ligne,*)word(1)
        select case(trim(word(1)))
        case("INCLUDE_FILE")
          read(ligne,*)word(2:3)
          write(*,'("File to include: ",2a)')trim(word(3))
          solution=.true.
          ob%solu_name=trim(word(3))
        case default
         !write(*,'(3x,"warning line not interpreted: ",a)')trim(ligne)
        end select
      end select
    enddo readingMeshActran
    close(10)    
    call cpu_time(t1)
    write(ob%nlog,'(a,e12.5,a)')'End Reading Mesh (actran format) - CPU =',t1-t0,' s'

    if( solution )then
      call cpu_time(t0)
      write(ob%nlog,'(/"Reading Solu (actran format)")')
      name=ob%solu_name
      ob%nfld=0
      open(unit=10,file=trim(name),action='read',status='old')
      readingSoluActran : do
        read(10,'(a80)',iostat=iostat)ligne
        if( is_iostat_end(iostat) )exit readingSoluActran
       !write(*,'(a)')trim(ligne)
        select case(trim(ligne))
        case("BEGIN FLOW")
          ob%nfld=ob%nfld+1
          !
          read(10,*)ob%nsol
          write(*,'(3x,"Number of solutions: ",i10)')ob%nsol
          allocate(u0(ob%geo,ob%nsol))
          do i=1,ob%nsol
            read(10,'(i10)',advance='no')i0
            read(10,*)u0(1:ob%geo,idx(i0))
          enddo
          read(10,*) ! END FLOW
          !
          !
        case("BEGIN ACOUSTIC_HETEROGENEITY")
        case("  DENSITY_PRESSURE")
          ob%nfld=ob%nfld+2
          allocate(p0(ob%nsol),r0(ob%nsol))
          read(10,*)
          do i=1,ob%nsol
            read(10,*)i0,r0(i),p0(i)
          enddo
          read(10,*) ! END ACOUSTIC_HETEROGENEITY
          !
          !
        case default
!          write(*,'("warning line not interpreted: ",a)')trim(ligne)
        end select
      enddo readingSoluActran
      close(10)


      allocate(ob%solu(ob%geo+2,ob%nsol))
      ob%kind(1:3)=[1,1,2]
      select case(ob%nfld)
      case(1)
        ob%nfld=3
        do i=1,ob%nsol
          ob%solu(:,i)=[a00,r00,u0(:,i)]
        enddo
        deallocate(u0)
      case(3)
        do i=1,ob%nsol
          ob%solu(:,i)=[p0(i),r0(i),u0(:,i)]
        enddo
        deallocate(p0,r0,u0)      
      end select
            
      if( allocated(idx   ) )deallocate(idx)
      if( allocated(key   ) )deallocate(key)
      if( allocated(link  ) )deallocate(link)
      if( allocated(maxNds) )deallocate(maxNds)
      if( allocated(minNds) )deallocate(minNds)
      
      call cpu_time(t1)
      write(ob%nlog,'(a,e12.5,a)')'End Reading Solu (actran format) - CPU =',t1-t0,' s'
    endif


  end subroutine mesh_dg_read_mesh_actran


  subroutine mesh_dg_read_mesh_ensight(ob)
    !-----------------------------------
    use m_ensight
    !-----------------------------------
    type(mesh_dg)         :: ob
    !-----------------------------------
    character(256)        :: name0, name
    integer               :: i,n,res
    real(8)               :: t0,t1
    !----------------------------------- 
    call cpu_time(t0)
    write(ob%nlog,'(/"Reading Mesh (ensight format)")')

    name=trim(ob%mesh_name)
    call readEnsightMeshASCII(fileIn=name,vertices=ob%vertx,tetra=ob%tetra,trian=ob%trian,edges=ob%edges)

    ob%geo=3
    ob%nvert=size(ob%vertx,2)
    allocate(ob%mark(ob%nvert)) ; ob%mark=0

    if( allocated(ob%tetra) )ob%nT4=size(ob%tetra,2)
    if( allocated(ob%trian) )ob%nT3=size(ob%trian,2)
    if( allocated(ob%edges) )ob%nL2=size(ob%edges,2)

    if( ob%nvert/=0 )write(ob%nlog,'(3x,"Number of vertices:  ",i10 )')ob%nVert
    if( ob%nH6/=0   )write(ob%nlog,'(3x,"Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0   )then
      write(ob%nlog,'(3x,"Number of tetrahedra ",i10 )')ob%nT4
      do i=1,100
        n=count(ob%tetra(5,:)==i)
        if( n/=0 )write(*,'(6x,"Tetra marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nQ4/=0   )write(ob%nlog,'(3x,"Number of quads      ",i10 )')ob%nQ4

    if( ob%nT3/=0   )then
      write(ob%nlog,'(3x,"Number of triangles: ",i10 )')ob%nT3
      do i=1,100
        n=count(ob%trian(4,:)==i)
        if( n/=0 )write(*,'(6x,"Trian marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nL2/=0   )write(ob%nlog,'(3x,"Number of edges:     ",i10 )')ob%nL2
    write(ob%nlog,'()')

    !
    write(ob%nlog,'(3x,"Bounding Box")')
    select case(ob%geo)
    case(2)    
      write(ob%nlog,'(6x,2(a,e12.5))')'xmin=',minval(ob%vertx(1,:)),' xmax=',maxval(ob%vertx(1,:))
      write(ob%nlog,'(6x,2(a,e12.5))')'ymin=',minval(ob%vertx(2,:)),' ymax=',maxval(ob%vertx(2,:))
    case(3)    
      write(ob%nlog,'(6x,2(a,e12.5))')'xmin=',minval(ob%vertx(1,:)),' xmax=',maxval(ob%vertx(1,:))
      write(ob%nlog,'(6x,2(a,e12.5))')'ymin=',minval(ob%vertx(2,:)),' ymax=',maxval(ob%vertx(2,:))
      write(ob%nlog,'(6x,2(a,e12.5))')'zmin=',minval(ob%vertx(3,:)),' zmax=',maxval(ob%vertx(3,:))
    end select

    call cpu_time(t1)
    write(ob%nlog,'(a,e12.5,a)')'End Reading Mesh (ensight format) - CPU =',t1-t0,' s'
  end subroutine mesh_dg_read_mesh_ensight


  subroutine mesh_dg_read_mesh_v3d(ob0, ob1)
    !------------------------------------------------------------
   !use m_libmesh5
    use M_libmesh5_api
    !------------------------------------------------------------
    type(mesh_v3d)        :: ob0
    type(mesh_dg )        :: ob1
    !------------------------------------------------------------
    integer               :: n
    character(20)         :: name
    character(20)         :: cvar,cform,iform,rform
    character(80)         :: ligne
    integer               :: idom,ndom
    integer               :: i,j,k,ip,jp,kp
    character(80)         :: command
    logical               :: binary

    integer               :: i1,l,nlog
    character(7)          :: key0,key1,key2

    real(8) , allocatable :: x(:,:,:)
    real(8) , allocatable :: y(:,:,:)
    real(8) , allocatable :: z(:,:,:)
    real(8) , allocatable :: v(:,:,:,:)

    real(8) , allocatable :: v1(:,:,:)
    real(8) , allocatable :: v2(:,:,:)
    real(8) , allocatable :: v3(:,:,:)
    real(8) , allocatable :: v4(:,:,:)
    real(8) , allocatable :: v5(:,:,:)
    real(8) , allocatable :: v6(:,:,:)
    real(8) , allocatable :: v7(:,:,:)
    real(8) , allocatable :: v8(:,:,:)

    real(8) , allocatable :: a0(:,:,:)

    integer               :: out
    integer               :: geo
    integer               :: iVert,nVert,dnVert,nVert1
    integer               :: iCell,nCell,dnCell,nCell1
    integer               :: nField

    real(8) , allocatable :: vert1(:,:)
    integer , allocatable :: cell1(:,:)
    integer , allocatable :: mark1(  :)
    real(8) , allocatable :: solu1(:,:)

    real(8) , allocatable :: vert (:,:)
    integer , allocatable :: cell (:,:)
    integer , allocatable :: mark (  :)
    real(8) , allocatable :: solu (:,:)

    integer , allocatable :: kind(:)
    integer               :: res
    integer               :: code
    integer , allocatable :: TypTab(:)
    
    integer               :: n1,n2,n3,n4,n5,n6,n7,n8
    real(8)               :: vec1(2),vec2(2),det
    
    real(8)               :: a0_inf,p0_inf,r0_inf,T0_inf, Gamma, Rgaz, Cv, Cp
    logical               :: show_domain=.true.
    !------------------------------------------------------------

!    write(*,'("Opening BINARY VOIR3D Mesh ",a)')trim(ob0%input_mesh)
!    open(unit=10,file=trim(ob0%input_mesh),status='old',action='read',form='unformatted')
!
!    read(10)ligne
!    write(*,*)ligne


    ! Reading of files    
    write(*,'("Opening ASCII VOIR3D Mesh ",a)')trim(ob0%input_mesh)
    open(unit=10,file=trim(ob0%input_mesh),status='old',action='read',form='formatted')
    do i=1,4 ; read(10,*) ; enddo

    write(*,'("Opening ASCII VOIR3D Solu ",a)')trim(ob0%input_solu)
    open(unit=20,file=trim(ob0%input_solu),status='old',action='read',form='formatted')
    do i=1,9 ; read(20,*) ; enddo
    read(20,*)p0_inf, T0_inf, Gamma, Rgaz
    read(20,*)

    r0_inf=p0_inf/Rgaz/T0_inf
    a0_inf=sqrt(gamma*Rgaz*T0_inf)
    Cv=Rgaz/(gamma-1.)
    Cp=Rgaz+Cv

    write(*,'(/"Gaz")')
    write(*,'(3x,a,e12.5)')'Gamma=',Gamma
    write(*,'(3x,a,e12.5)')'Rgaz =',Rgaz
    write(*,'(3x,a,e12.5)')'Cv   =',Cv
    write(*,'(3x,a,e12.5)')'Cp   =',Cp

    write(*,'(/"Thermo")')
    write(*,'(3x,a,f12.5)')'a0_inf = ',a0_inf
    write(*,'(3x,a,f12.5)')'p0_inf = ',p0_inf
    write(*,'(3x,a,f12.5)')'r0_inf = ',r0_inf
    write(*,'(3x,a,f12.5)')'T0_inf = ',T0_inf

    write(*,'(/"List of Coordinates")')
    write(*,'(3x,"x")')
    write(*,'(3x,"y")')
    write(*,'(3x,"z")')

    write(*,'(/"List of Variables")')
    write(*,'(3x,"v1 = rho0    / rho_inf")')
    write(*,'(3x,"v2 = rho0 u0 / rho_inf / a_inf")')
    write(*,'(3x,"v3 = rho0 v0 / rho_inf / a_inf")')
    write(*,'(3x,"v4 = rho0 w0 / rho_inf / a_inf")')
    write(*,'(3x,"v5 = rho0 E0 / rho_inf / a_inf^2")')

    write(*,'(/6x,"   rho0 E0 = rho0 U0                       + 0.5 rho0^2 (u0^2+v0^2) ")')
    write(*,'( 6x,"=>         = rho0 Cv T0                    + 0.5 rho0^2 (u0^2+v0^2) ")')
    write(*,'( 6x,"=>         = rho0 T0           R/(Gamma-1) + 0.5 rho0^2 (u0^2+v0^2) ")')
    write(*,'( 6x,"=>         = rho0 a0^2/Gamma/R R/(Gamma-1) + 0.5 rho0^2 (u0^2+v0^2) ")')
    write(*,'( 6x,"=>         = rho0 a0^2/Gamma    /(Gamma-1) + 0.5 rho0^2 (u0^2+v0^2) ")')
    write(*,'(/6x,"=> a0^2    = Gamma (Gamma-1) /rho0 (rho0 E0 - 0.5 rho0^2 (u0^2+v0^2))")')
    write(*,'( 6x,"=> a0^2    = Gamma (Gamma-1) /rho0 (E0 - 0.5 rho0^2 u0^2- 0.5 rho0^2 v0^2)")')
    write(*,'( 6x,"=> a0      = sqrt( Gamma (Gamma-1)/rho0 (rho0 E0 - rho0^2 u0^2- rho0^2 v0^2) )"/)')

    geo=3
    !
    iVert=0 ; nVert=0
    iCell=0 ; nCell=0
    idom=0

    Loop1 : do
      !---------------------------------------------------------
      idom=idom+1
      !---------------------------------------------------------
      write(*,'(/"Reading ASCII VOIR3D Mesh @ domain=",i2)')idom
    
      read(10,'(2a20)')cvar,cform
      read(10,'(4i6 )')ndom,ip,jp,kp  
      allocate(x(ip,jp,kp))
      read(10,cform)(((x(i,j,k), i=1,ip), j=1,jp), k=1,kp)
     !write(*,'(3x,3a)')'coordinate: ',trim(cvar),' readed'

      read(10,'(2a20)')cvar,cform  
      read(10,'(4i6 )')ndom,ip,jp,kp  
      allocate(y(ip,jp,kp))
      read(10,cform)(((y(i,j,k), i=1,ip), j=1,jp), k=1,kp)
     !write(*,'(3x,3a)')'coordinate: ',trim(cvar),' readed'

      read(10,'(2a20)')cvar,cform  
      read(10,'(4i6 )')ndom,ip,jp,kp
      allocate(z(ip,jp,kp))
      read(10,cform)(((z(i,j,k), i=1,ip), j=1,jp), k=1,kp)
     !write(*,'(3x,3a)')'coordinate: ',trim(cvar),' readed'

      write(*,'( 3x,"min,max(x )=",2(f12.5,1x))')minval(x),maxval(x)
      write(*,'( 3x,"min,max(y )=",2(f12.5,1x))')minval(y),maxval(y)
      write(*,'( 3x,"min,max(z )=",2(f12.5,1x))')minval(z),maxval(z)

      !---------------------------------------------------------
      write(*,'( "Reading ASCII VOIR3D Solu @ domain=",i2)')idom
      allocate(v(ip,jp,kp,ob0%nfields))

      do l=1,ob0%nfields
        read(20,'(2a20)')cvar,cform  
        read(20,'(4i6)')ndom,ip,jp,kp  
        read(20,cform)(((v(i,j,k,l), i=1,ip), j=1,jp), k=1,kp)
       !write(*,'(3x,3a)')'variable: ',trim(cvar),' readed'
      enddo

      write(*,'( 3x,"min,max(v1)=",2(f12.5,1x))')minval(v(:,:,:,1)),maxval(v(:,:,:,1))
      write(*,'( 3x,"min,max(v2)=",2(f12.5,1x))')minval(v(:,:,:,2)),maxval(v(:,:,:,2))
      write(*,'( 3x,"min,max(v3)=",2(f12.5,1x))')minval(v(:,:,:,3)),maxval(v(:,:,:,3))
      write(*,'( 3x,"min,max(v4)=",2(f12.5,1x))')minval(v(:,:,:,4)),maxval(v(:,:,:,4))
      write(*,'( 3x,"min,max(v5)=",2(f12.5,1x))')minval(v(:,:,:,5)),maxval(v(:,:,:,5))


      v(:,:,:,1)=v(:,:,:,1)*r0_inf               ! rho0
      v(:,:,:,2)=v(:,:,:,2)*r0_inf*a0_inf        ! rho0 u0
      v(:,:,:,3)=v(:,:,:,3)*r0_inf*a0_inf        ! rho0 v0
      v(:,:,:,4)=v(:,:,:,4)*r0_inf*a0_inf        ! rho0 w0
      v(:,:,:,5)=v(:,:,:,5)*r0_inf*a0_inf*a0_inf ! rho0 E0

      allocate(a0(ip,jp,kp))
      a0=sqrt(.56/v(:,:,:,1)*(v(:,:,:,5)-v(:,:,:,2)*v(:,:,:,2)-v(:,:,:,3)*v(:,:,:,3)-v(:,:,:,4)*v(:,:,:,4)))

     !write(*,'( 3x,"min,max(r0     )=",2(f12.5,1x))')minval(v(:,:,:,1)),maxval(v(:,:,:,1))
     !write(*,'( 3x,"min,max(rho0 u0)=",2(f12.5,1x))')minval(v(:,:,:,2)),maxval(v(:,:,:,2))
     !write(*,'( 3x,"min,max(rho0 v0)=",2(f12.5,1x))')minval(v(:,:,:,3)),maxval(v(:,:,:,3))
     !write(*,'( 3x,"min,max(rho0 w0)=",2(f12.5,1x))')minval(v(:,:,:,4)),maxval(v(:,:,:,4))
     !write(*,'( 3x,"min,max(rho0 E0)=",2(f12.5,1x))')minval(v(:,:,:,5)),maxval(v(:,:,:,5))
     !write(*,'( 3x,"min,max(a0     )=",2(f12.5,1x))')minval(a0),maxval(a0)

      !------------------------------------------------------------
      ! Creating inria mesh format

      write(*,'("Exporting v3d to INRIA Mesh Format @ domain=",i2)')idom

      ! Vertices

      dnVert=ip*jp*kp
      dnCell=max(ip-1,1)*max(jp-1,1)*max(kp-1,1)
          
      nVert1=nVert+dnVert
      nCell1=nCell+dnCell

      allocate(vert1(geo,nVert1),mark1(nVert1))  
      allocate(solu1(5  ,nVert1))

      select case(geo)
      case(2) ; allocate(cell1(5,nCell1)) ! quad
      case(3) ; allocate(cell1(9,nCell1)) ! hexa
      end select

      if( iVert/=0 )vert1(:,1:iVert)=vert(:,1:iVert)
      if( iVert/=0 )solu1(:,1:iVert)=solu(:,1:iVert)
      if( iCell/=0 )cell1(:,1:iCell)=cell(:,1:iCell)

      do k=1,kp
        do j=1,jp
          do i=1,ip
            iVert=iVert+1
            vert1(1,iVert)=x(i,j,k)
            vert1(2,iVert)=y(i,j,k)
            vert1(3,iVert)=z(i,j,k)
            mark1(  iVert)=0
            !
            solu1(1,iVert) = a0(i,j,k)
            solu1(2,iVert) = v(i,j,k,1)
            solu1(3,iVert) = v(i,j,k,2) / v(i,j,k,1)
            solu1(4,iVert) = v(i,j,k,3) / v(i,j,k,1)
            solu1(5,iVert) = v(i,j,k,4) / v(i,j,k,1)
          enddo
        enddo
      enddo

      ! geometry
      write(*,'( 3x,"min,max(x )=",2(f12.5,1x))')minval(vert1(1,nVert+1:nVert1)),maxval(vert1(1,nVert+1:nVert1))
      write(*,'( 3x,"min,max(y )=",2(f12.5,1x))')minval(vert1(2,nVert+1:nVert1)),maxval(vert1(2,nVert+1:nVert1))
      write(*,'( 3x,"min,max(z )=",2(f12.5,1x))')minval(vert1(3,nVert+1:nVert1)),maxval(vert1(3,nVert+1:nVert1))
      ! cfd
      write(*,'( 3x,"min,max(a0)=",2(f12.5,1x))')minval(solu1(1,nVert+1:nVert1)),maxval(solu1(1,nVert+1:nVert1))
      write(*,'( 3x,"min,max(r0)=",2(f12.5,1x))')minval(solu1(2,nVert+1:nVert1)),maxval(solu1(2,nVert+1:nVert1))
      write(*,'( 3x,"min,max(u0)=",2(f12.5,1x))')minval(solu1(3,nVert+1:nVert1)),maxval(solu1(3,nVert+1:nVert1))
      write(*,'( 3x,"min,max(v0)=",2(f12.5,1x))')minval(solu1(4,nVert+1:nVert1)),maxval(solu1(4,nVert+1:nVert1))
      write(*,'( 3x,"min,max(w0)=",2(f12.5,1x))')minval(solu1(5,nVert+1:nVert1)),maxval(solu1(5,nVert+1:nVert1))

      write(*,'(3x,a,i10,a,i2)')'mesh vertices added ',dnVert,' @ domain ',idom

      ! Cellules

      select case(geo)
      case(2)
        do j=1,jp-1
          do i=1,ip-1
            iCell=iCell+1
            !
            n1=nVert +i  +(j-1)*ip
            n2=nVert +i  +(j  )*ip
            n3=nVert +i+1+(j  )*ip
            n4=nVert +i+1+(j-1)*ip
            
            ! orientation du quad (n1,n2,n3,n4)
            
            vec1=[ vert1(1,n2)-vert1(1,n1),vert1(2,n2)-vert1(2,n1) ]
            vec2=[ vert1(1,n4)-vert1(1,n1),vert1(2,n4)-vert1(2,n1) ]
            det=vec1(1)*vec2(2)-vec1(2)*vec2(1)
            !
            if( det >=0. )then
              cell1(1,iCell)=n1
              cell1(2,iCell)=n2
              cell1(3,iCell)=n3
              cell1(4,iCell)=n4
            else
              cell1(1,iCell)=n1
              cell1(2,iCell)=n4
              cell1(3,iCell)=n3
              cell1(4,iCell)=n2
            endif
            if( show_domain )then
              cell1(5,iCell)=idom
            else
              cell1(5,iCell)=0
            endif          
          enddo
        enddo
      case(3)
        do k=1,kp-1
          do j=1,jp-1
            do i=1,ip-1
              iCell=iCell+1
              !
              n1=nVert +i  +(j-1)*ip+(k-1)*ip*jp
              n2=nVert +i  +(j  )*ip+(k-1)*ip*jp
              n3=nVert +i+1+(j  )*ip+(k-1)*ip*jp
              n4=nVert +i+1+(j-1)*ip+(k-1)*ip*jp
              n5=nVert +i  +(j-1)*ip+(k  )*ip*jp
              n6=nVert +i  +(j  )*ip+(k  )*ip*jp
              n7=nVert +i+1+(j  )*ip+(k  )*ip*jp
              n8=nVert +i+1+(j-1)*ip+(k  )*ip*jp
              !
              cell1(1:8,iCell)=[n1,n2,n3,n4,n5,n6,n7,n8]
              !
              if( show_domain )then
                cell1(9,iCell)=idom
              else
                cell1(9,iCell)=0
              endif          
            enddo
          enddo
        enddo
      end select

      nVert=nVert1
      nCell=nCell1
      call move_alloc(vert1, vert)
      call move_alloc(cell1, cell)
      call move_alloc(mark1, mark)
      call move_alloc(solu1, solu)

      write(*,'(3x,a,i10,a,i2)')'mesh cellules added ',dnCell,' @ domain ',idom

      deallocate(x,y,z)
      deallocate(v,a0)

      if( eof(10).and.eof(20) )exit loop1

    enddo loop1

    close(10)
    close(20)


    ob0%output_mesh='exportV3D.meshb'
    write(*,'(/"Global INRIA Mesh Format Created: ",a)')trim(ob0%output_mesh)

    write(*,'( 3x,"min,max(x )=",2(f12.5,1x) )')minval(vert(1,:)),maxval(vert(1,:))
    write(*,'( 3x,"min,max(y )=",2(f12.5,1x) )')minval(vert(2,:)),maxval(vert(2,:))
    if( geo==3 )&
   &write(*,'( 3x,"min,max(z )=",2(f12.5,1x) )')minval(vert(3,:)),maxval(vert(3,:))

    write(*,'( 3x,"min,max(a0)=",2(f12.5,1x) )')minval(solu(1,:)),maxval(solu(1,:))
    write(*,'( 3x,"min,max(r0)=",2(f12.5,1x) )')minval(solu(2,:)),maxval(solu(2,:))
    write(*,'( 3x,"min,max(u0)=",2(f12.5,1x) )')minval(solu(3,:)),maxval(solu(3,:))
    write(*,'( 3x,"min,max(v0)=",2(f12.5,1x) )')minval(solu(4,:)),maxval(solu(4,:))
    if( geo==3 )&
   &write(*,'( 3x,"min,max(w0)=",2(f12.5,1x) )')minval(solu(5,:)),maxval(solu(5,:))



    write(*,'(/"Writing Mesh ",a)')trim(ob0%output_mesh)
    write(*,'(3x,a,i10)')'Number of vertices:    ',iVert

    out=GmfOpenMeshF77(               &
    &    FilNam=trim(ob0%output_mesh),&
    &    mod=GmfWrite                ,&
    &    ver=2                       ,& ! real(8)
    &    dim=geo                      )
    !
    ! vertices
    !
    res=gmfsetkwdf77(        &
    &   MshIdx=out          ,&
    &   KwdIdx=GmfVertices  ,&
    &   NmbLin=iVert        ,&
    &   NmbTyp=0            ,&
    &   TypTab=TypTab        )

    select case(geo)
    case(2)
      do i=1,iVert
        call GmfSetVertex2Dr8(  &
        &     out              ,&
        &     vert(1,i)        ,&
        &     vert(2,i)        ,&
        &     mark(i)           )
      enddo
    case(3)
      do i=1,iVert
        call gmfsetvertex3Dr8( &
        &    MshIdx=out       ,&
        &    r0=vert(1,i)     ,&
        &    r1=vert(2,i)     ,&
        &    r2=vert(3,i)     ,&
        &    i3=mark(  i)      )
      enddo
    end select

    ! sauvegarde des quadrangles

!    res=GmfSetKwdF77(out, GmfQuadrilaterals, iCell, 1, TypTab)
!    select case( geo )
!    case(2)
!      do i=1,iCell
!        call GmfSetQuadrilateral( &
!        &  out                   ,&
!        &  cell(1,i)             ,&
!        &  cell(2,i)             ,&
!        &  cell(3,i)             ,&
!        &  cell(4,i)             ,&
!        &  cell(5,i)              )
!      enddo
!      !
!    case default
!      write(*,'("Geometry Not Implemented")')
!      write(*,'("Stop @ mesh_dg_read_mesh_v3d")')
!      stop
!    end select


    select case( geo )
    case(2)
      ! chaque quadrangle est decoupe en deux triangles
      write(*,'(3x,a,i10)')'Number of triangles:   ',2*iCell
      res=GmfSetKwdF77(out, GmfTriangles, 2*iCell, 1, TypTab)
      !
      do i=1,iCell
        call GmfSetTriangle( &
        &  out              ,&
        &  cell(1,i)        ,&
        &  cell(2,i)        ,&
        &  cell(3,i)        ,&
        &  cell(5,i)         )
        !
        call GmfSetTriangle( &
        &  out              ,&
        &  cell(1,i)        ,&
        &  cell(3,i)        ,&
        &  cell(4,i)        ,&
        &  cell(5,i)         )
      enddo
      !
    case(3)
      res=GmfSetKwdF77(out, GmfHexahedra, iCell, 1, TypTab)
      write(*,'(3x,a,i10)')'Number of hexa:        ',iCell
      !
      do i=1,iCell
        call GmfSetHexahedron( &
        &  out                ,&
        &  cell(1,i)          ,&
        &  cell(2,i)          ,&
        &  cell(3,i)          ,&
        &  cell(4,i)          ,&
        &  cell(5,i)          ,&
        &  cell(6,i)          ,&
        &  cell(7,i)          ,&
        &  cell(8,i)          ,&
        &  cell(9,i)           )
      enddo
      !
    case default
      write(*,'("Geometry Not Implemented")')
      write(*,'("Stop @ mesh_dg_read_mesh_v3d")')
      stop
    end select
    res=GmfCloseMeshf77(out)

    select case(geo)
    case(2)
      write(*,'(3x,"Bounding Box")')
      write(*,'(6x,"xmin=",e12.5," - xmax=",e12.5)')minval(vert(1,1:ivert)),maxval(vert(1,1:ivert))
      write(*,'(6x,"ymin=",e12.5," - ymax=",e12.5)')minval(vert(2,1:ivert)),maxval(vert(2,1:ivert))
    case(3)    
      write(*,'(3x,"Bounding Box")')
      write(*,'(6x,"xmin=",e12.5," - xmax=",e12.5)')minval(vert(1,1:ivert)),maxval(vert(1,1:ivert))
      write(*,'(6x,"ymin=",e12.5," - ymax=",e12.5)')minval(vert(2,1:ivert)),maxval(vert(2,1:ivert))
      write(*,'(6x,"zmin=",e12.5," - zmax=",e12.5)')minval(vert(3,1:ivert)),maxval(vert(3,1:ivert))
    end select

    deallocate(vert,cell,mark)


    l=index(ob0%output_mesh,'.',.true.)-1
    ob0%output_mesh=ob0%output_mesh(1:l)//'.solb'
    nField=3 ; allocate(kind(nField)) ; kind=[1,1,2]

    write(*,'(/"Writing Solu ",a)')trim(ob0%output_mesh)
    write(*,'(3x,"Double Precision Solu File: ",a)')trim(ob0%output_mesh)
    write(*,'(3x,a,i10)')'Number of fields:      ',nField
    write(*,'(3x,a,i10)')'Number of sol@vertx:   ',iVert
    write(*,'(3x,"Bounding Box")')
    do i=1,size(solu,1)
      write(*,'( 6x,"min,max( solu(",i1,",:) )=",2(f12.5,1x) )')i,minval(solu(i,:)),maxval(solu(i,:))
    enddo

    out=GmfOpenMeshF77(              &
    &   FilNam=trim(ob0%output_mesh),&
    &   mod=GmfWrite                ,&
    &   ver=2                       ,&
    &   dim=geo                      )
    !    
    res=gmfsetkwdf77(                &
    &   MshIdx=out                  ,&
    &   KwdIdx=GmfSolAtVertices     ,&
    &   NmbLin=iVert                ,&
    &   NmbTyp=nField               ,&
    &   TypTab=kind                  )
        
    do i=1,iVert
      call gmfSetSolAtVertexR8(out,solu(:,i))
    enddo
    res=GmfCloseMeshf77(out)
    
    deallocate(solu,kind)
    write(*,'("End Writing Solu")')

  end subroutine mesh_dg_read_mesh_v3d


  subroutine mesh_dg_read_mesh(ob)
    !-----------------------------------
   !use m_libmesh4
   !use m_libmesh5
    use M_libmesh5_api
    !-----------------------------------
    type(mesh_dg)         :: ob
    !-----------------------------------
    character(256)        :: name0, name
    integer               :: ins,ver
    integer               :: i,n,res
    integer , allocatable :: TypTab(:)
    real(8)               :: t0,t1
    real(4)               :: xyz(3)
    !----------------------------------- 
    call cpu_time(t0)
    write(ob%nlog,'(/"Reading Mesh")')
    !
    name=trim(ob%mesh_name)//'.meshb'
    ins=GmfOpenMeshF77(trim(name),GmfRead,ver,ob%geo)
        
    if( ins<=0 )then
      res = GmfCloseMeshF77(ins)
      name=trim(ob%mesh_name)//'.mesh'
      ins=GmfOpenMeshF77(trim(name),GmfRead,ver,ob%geo)
      if( ins<=0 )then
        res = GmfCloseMeshF77(ins)
        write(ob%nlog,'(3x,"File not Found: ",a)')trim(ob%mesh_name)//'.mesh'
        write(ob%nlog,'(3x,"File not Found: ",a)')trim(ob%mesh_name)//'.meshb'
        stop ' stop @ mesh_read_medit_mesh'
      endif
    endif

    select case(ver)
    case(1) ; write(ob%nlog,'(3x,"Single Precision Mesh File: ",a)')trim(name)
    case(2) ; write(ob%nlog,'(3x,"Double Precision Mesh File: ",a)')trim(name)
    end select
    !
    ! Reading of vertices
    !
    ob%nvert=GmfStatKwdF77(ins,GmfVertices,ver,0,TypTab)

    if( ob%nvert/=0 )then
      allocate(ob%mark(ob%nVert),ob%vertx(ob%geo,ob%nvert))
      ! Read the vertices
      res=GmfGotoKwdF77(ins,GmfVertices)
      select case(ob%geo)
      case(2)

        select case(ver)
        case(1)
          do i=1,ob%nVert
            call gmfgetvertex2dr4(ins,xyz(1),xyz(2),ob%mark(i))
            ob%vertx(1:2,i)=xyz(1:2)
          enddo
        case(2)
          do i=1,ob%nVert
            call gmfgetvertex2dr8(ins,ob%vertx(1,i),ob%vertx(2,i),ob%mark(i))
          enddo
        end select
        
      case(3)

        select case(ver)
        case(1)
          do i=1,ob%nVert
            call GmfGetVertex3dr4(ins,xyz(1),xyz(2),xyz(3),ob%mark(i))
            ob%vertx(1:3,i)=xyz(1:3)
          enddo
        case(2)
          do i=1,ob%nVert
            call GmfGetVertex3dr8(ins,ob%vertx(1,i),ob%vertx(2,i),ob%vertx(3,i),ob%mark(i))
          enddo
        end select

      end select
    endif

    ob%nH6=GmfStatKwdF77(ins,GmfHexahedra,0,0,TypTab)
    if( ob%nH6/=0 )then
      allocate(ob%hexas(9,ob%nH6))
      ! Read the tetra
      res=GmfGotoKwdF77(ins,GmfHexahedra)
      do i=1,ob%nH6
        call GmfGetHexahedron(    &
        & ins                      ,&
        & ob%hexas(1,i)            ,&
        & ob%hexas(2,i)            ,&
        & ob%hexas(3,i)            ,&
        & ob%hexas(4,i)            ,&
        & ob%hexas(5,i)            ,&
        & ob%hexas(6,i)            ,&
        & ob%hexas(7,i)            ,&
        & ob%hexas(8,i)            ,&
        & ob%hexas(9,i)             )
      enddo
    endif

    ob%nT4=GmfStatKwdF77(ins,GmfTetrahedra,0,0,TypTab)
    if( ob%nT4/=0 )then
      allocate(ob%tetra(5,ob%nT4))
      ! Read the tetra
      res = GmfGotoKwdF77(ins,GmfTetrahedra)
      do i=1,ob%nT4
        call GmfGetTetrahedron(ins,ob%tetra(1,i),ob%tetra(2,i),ob%tetra(3,i),ob%tetra(4,i),ob%tetra(5,i))
      enddo
    endif

    ob%nQ4=GmfStatKwdF77(ins,GmfQuadrilaterals,0,0,TypTab)
    if( ob%nQ4/=0 )then
      allocate(ob%quadr(5,ob%nQ4))
      ! Read the quadr
      res = GmfGotoKwdF77(ins,GmfQuadrilaterals)
      do i=1,ob%nQ4
        call GmfGetQuadrilateral(ins,ob%quadr(1,i),ob%quadr(2,i),ob%quadr(3,i),ob%quadr(4,i),ob%quadr(5,i))
      enddo
    endif

    ob%nT3=GmfStatKwdF77(ins,GmfTriangles,0,0,TypTab)
    if( ob%nT3/=0 )then
      allocate(ob%trian(4,ob%nT3))
      ! Read the triangles
      res = GmfGotoKwdF77(ins,GmfTriangles)
      do i=1,ob%nT3
        call GmfGetTriangle(ins,ob%trian(1,i),ob%trian(2,i),ob%trian(3,i),ob%trian(4,i))
      enddo
    endif

    ob%nL2=GmfStatKwdF77(ins,GmfEdges,0,0,TypTab)
    if( ob%nL2/=0 )then
      allocate(ob%edges(3,ob%nL2))
      ! Read the Edges
      res = GmfGotoKwdF77(ins,GmfEdges)
      do i=1,ob%nL2
        call GmfGetEdge(ins,ob%edges(1,i),ob%edges(2,i),ob%edges(3,i))
      enddo
    endif

    ! Close the mesh
    res = GmfCloseMeshF77(ins)
    ! <<< libmesh5 <<<


    if( ob%nVert/=0 )write(ob%nlog,'(3x,"Number of vertices:  ",i10 )')ob%nVert
    if( ob%nH6/=0   )write(ob%nlog,'(3x,"Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0   )then
      write(ob%nlog,'(3x,"Number of tetrahedra ",i10 )')ob%nT4
      do i=1,100
        n=count(ob%tetra(5,:)==i)
        if( n/=0 )write(*,'(6x,"Tetra marked ",i2,": ",i10)')i,n
      enddo
    endif
    if( ob%nQ4/=0   )write(ob%nlog,'(3x,"Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0   )then
      write(ob%nlog,'(3x,"Number of triangles: ",i10 )')ob%nT3
      do i=1,100
        n=count(ob%trian(4,:)==i)
        if( n/=0 )write(ob%nlog,'(6x,"Trian marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nL2/=0   )write(ob%nlog,'(3x,"Number of edges:     ",i10 )')ob%nL2
   !write(ob%nlog,'()')
    !
    write(ob%nlog,'(3x,"Bounding Box")')
    select case(ob%geo)
    case(2)    
      ob%xmin=minval(ob%vertx(1,:)) ; ob%xmax=maxval(ob%vertx(1,:))
      ob%ymin=minval(ob%vertx(2,:)) ; ob%ymax=maxval(ob%vertx(2,:))
      write(ob%nlog,'(6x,2(a,e12.5))')'xmin=',ob%xmin,' xmax=',ob%xmax
      write(ob%nlog,'(6x,2(a,e12.5))')'ymin=',ob%ymin,' ymax=',ob%ymax
    case(3)    
      ob%xmin=minval(ob%vertx(1,:)) ; ob%xmax=maxval(ob%vertx(1,:))
      ob%ymin=minval(ob%vertx(2,:)) ; ob%ymax=maxval(ob%vertx(2,:))
      ob%zmin=minval(ob%vertx(3,:)) ; ob%zmax=maxval(ob%vertx(3,:))
      write(ob%nlog,'(6x,2(a,e12.5))')'xmin=',ob%xmin,' xmax=',ob%xmax
      write(ob%nlog,'(6x,2(a,e12.5))')'ymin=',ob%ymin,' ymax=',ob%ymax
      write(ob%nlog,'(6x,2(a,e12.5))')'zmin=',ob%zmin,' zmax=',ob%zmax
    end select
    !
    call cpu_time(t1)
    write(ob%nlog,'(a,e12.5,a)')'End Reading Mesh - CPU =',t1-t0,' s'
  end subroutine mesh_dg_read_mesh


  subroutine mesh_dg_read_solu(ob)
    !-----------------------------------
   !use m_libmesh5
    use M_libmesh5_api
    !-----------------------------------
    type(mesh_dg)         :: ob
    !-----------------------------------
    logical               :: solution=.true.
    character(256)        :: name0, name
    real(8)               :: t0,t1
    integer               :: i
    integer               :: ins,res,ver
    real(4) , allocatable :: solu(:)
    !----------------------------------- 
    call cpu_time(t0)
    write(ob%nlog,'(/"Reading Solu")')
    !
    ! >>> libmesh5 >>>
    name=trim(ob%solu_name)//'.solb'
    ins=GmfOpenMeshF77(trim(name),GmfRead,ver,ob%geo)
    if( ins<=0 )then
      res=GmfCloseMeshF77(ins)
      name=trim(ob%solu_name)//'.sol'
      ins=GmfOpenMeshF77(trim(name),GmfRead,ver,ob%geo)
      if( ins<=0 )then
        solution=.false.
        res=GmfCloseMeshF77(ins)
        write(ob%nlog,'(3x,"File not Found: ",a)')trim(ob%solu_name)//'.sol'
        write(ob%nlog,'(3x,"File not Found: ",a)')trim(ob%solu_name)//'.solb'
      endif
    endif
    !
    if( solution )then
      !
      select case(ver)
      case(1) ; write(ob%nlog,'(3x,"Single Precision Solu File: ",a)')trim(name)
      case(2) ; write(ob%nlog,'(3x,"Double Precision Solu File: ",a)')trim(name)
      end select
      !
      if(allocated(ob%solu))deallocate(ob%solu)
      !
      ob%nsol=GmfStatKwdF77(ins,GmfSolAtVertices,ob%nfld,ob%ker,ob%kind)
      if( ob%nsol/=0 )then
        allocate(ob%solu(ob%ker,ob%nSol))
        res=GmfGotoKwdF77(ins,GmfSolAtVertices)
        !
        select case(ver)
        case(1)
          allocate(solu(ob%ker))
          do i=1,ob%nsol
            call gmfgetsolatvertexr4( &
            &    MshIdx=ins          ,&
            &    SolTab=solu(:)       )
            ob%solu(:,i)=solu(:)
          enddo
          deallocate(solu)
        case(2)
          do i=1,ob%nsol
            call gmfgetsolatvertexr8( &
            &    MshIdx=ins          ,&
            &    SolTab=ob%solu(:,i)  )
          enddo
        end select
        !
      endif
      res=GmfCloseMeshF77(ins)
      !
      write(ob%nlog,'(3x,"Number of Fields:    ",i10)')ob%nFld
      write(ob%nlog,'(3x,"Number of solutions: ",i10)')ob%nSol
      write(ob%nlog,'(3x,"Number of components:",i10)')ob%ker
      write(ob%nlog,'(3x,"Bounding Box")')
      do i=1,ob%ker
        write(ob%nlog,'( 6x,"min,max( solu(",i1,",:) )=",2(f12.5,1x) )')i,minval(ob%solu(i,:)),maxval(ob%solu(i,:))
      enddo

      call cpu_time(t1)
      write(ob%nlog,'("End Reading Initial Solu - CPU ="e12.5,"s")')t1-t0
    else
      ob%nFld=0
      ob%nSol=0
    endif
    ! <<< libmesh5 <<<
  end subroutine mesh_dg_read_solu

  subroutine mesh_dg_rotate_mesh(ob,iRot,omega,BiDim)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    integer               :: iRot
    real(8)               :: omega
    logical               :: BiDim
    !------------------------------------------------
    integer               :: i
    real(8) , parameter   :: pi=3.14159265358979
    real(8) , allocatable :: vertx(:,:)
    real(8)               :: sin_omg,cos_omg,a,b
    real(8)               :: t0,t1
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'("Rotation Mesh ",a)')trim(ob%mesh_name)
 
    if( ob%geo==3 .and. .not.BiDim )then
      write(*,'(3x,"1 -> Rotation Ox (x,y,z) -> (x,y'',z'')")')
      write(*,'(3x,"2 -> Rotation Oy (x,y,z) -> (x'',y,z'')")')
      write(*,'(3x,"3 -> Rotation Oz (x,y,z) -> (x'',y'',z)")')
      write(*,'(3x,"")',advance='no')
      read(*,*)iRot

      write(*,'(3x,"Rotating angle in degrees")')
      write(*,'(3x,"")',advance='no')
      read(*,*)omega
      omega=omega*pi/180.
      sin_omg=sin(omega)
      cos_omg=cos(omega)
      allocate(vertx(3,ob%nvert))

      select case(iRot)
      case(1)
        !omp do
        do i=1,ob%nvert
          vertx(1,i)=        ob%vertx(1,i)
          vertx(2,i)=cos_omg*ob%vertx(2,i)-sin_omg*ob%vertx(3,i)
          vertx(3,i)=sin_omg*ob%vertx(2,i)+cos_omg*ob%vertx(3,i)
        enddo
        !omp enddo
      case(2)
        !omp do
        do i=1,ob%nvert
          vertx(1,i)=cos_omg*ob%vertx(1,i)-sin_omg*ob%vertx(3,i)
          vertx(2,i)=        ob%vertx(2,i)
          vertx(3,i)=sin_omg*ob%vertx(1,i)+cos_omg*ob%vertx(3,i)
        enddo
        !omp enddo
      case(3)
        !omp do
        do i=1,ob%nvert
          vertx(1,i)=cos_omg*ob%vertx(1,i)-sin_omg*ob%vertx(2,i)
          vertx(2,i)=sin_omg*ob%vertx(1,i)+cos_omg*ob%vertx(2,i)
          vertx(3,i)=        ob%vertx(3,i)
        enddo
        !omp enddo
      end select

    else

      write(*,'(3x,a)')"Rotation center"
      write(*,'(3x,"")',advance='no')
      read(*,*)a,b

      write(*,'(3x,a)')"Rotating angle in degrees ?"
      write(*,'(3x,"")',advance='no')
      read(*,*)omega

      omega=omega*pi/180.
      sin_omg=sin(omega)
      cos_omg=cos(omega)

      allocate(vertx(2,ob%nvert))
      !omp do
      do i=1,ob%nvert
        vertx(1,i)=cos_omg*(ob%vertx(1,i)-a)-sin_omg*(ob%vertx(2,i)-b)+a
        vertx(2,i)=sin_omg*(ob%vertx(1,i)-a)+cos_omg*(ob%vertx(2,i)-b)+b
      enddo
      !omp enddo
    endif
    call move_alloc(vertx,ob%vertx)
    call cpu_time(t1)
    write(ob%nlog,'(a,e12.5,a)')'End Rotation - CPU =',t1-t0,' s'
  end subroutine mesh_dg_rotate_mesh

  subroutine mesh_dg_rotate_solu(ob,iRot,omega,BiDim)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    integer               :: iRot
    real(8)               :: omega
    logical               :: BiDim
    !------------------------------------------------
    integer               :: i,j,ker,k1,k2,k3
    real(8) , allocatable :: solu(:,:)
    real(8)               :: sin_omg,cos_omg
    real(8)               :: t0,t1
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'("Rotation Solu ",a)')trim(ob%solu_name)

    if( omega/=0. )then
      ker=0
      cos_omg=cos(omega)
      sin_omg=sin(omega)
      allocate(solu(size(ob%solu,1),size(ob%solu,2)))
      !
      do i=1,ob%nfld
        select case(ob%kind(i))
        case(1)
          k1=ker+1
          do j=1,ob%nsol
            solu(k1,j)=        ob%solu(k1,j)
          enddo
          ker=k1
        case(2)
          if( ob%geo==3 .and. .not.BiDim )then
            k1=ker+1
            k2=ker+2
            k3=ker+3
            select case(iRot)
            case(1)
              !omp do
              do j=1,ob%nsol
                solu(k1,j)=        ob%solu(k1,j)
                solu(k2,j)=cos_omg*ob%solu(k2,j)-sin_omg*ob%solu(k3,j)
                solu(k3,j)=sin_omg*ob%solu(k2,j)+cos_omg*ob%solu(k3,j)
              enddo
              !omp enddo
            case(2)
              !omp do
              do j=1,ob%nsol
                solu(k1,j)=cos_omg*ob%solu(k1,j)-sin_omg*ob%solu(k3,j)
                solu(k2,j)=        ob%solu(k2,j)
                solu(k3,j)=sin_omg*ob%solu(k1,j)+cos_omg*ob%solu(k3,j)
              enddo
              !omp enddo
            case(3)
              !omp do
              do j=1,ob%nsol
                solu(k1,j)=cos_omg*ob%solu(k1,j)-sin_omg*ob%solu(k2,j)
                solu(k2,j)=sin_omg*ob%solu(k1,j)+cos_omg*ob%solu(k2,j)
                solu(k3,j)=        ob%solu(k3,j)
              enddo
              !omp enddo
            end select
            ker=k3
          else
            k2=ker+2
            !omp do
            do j=1,ob%nsol
              solu(k1,j)=cos_omg*ob%solu(k1,j)-sin_omg*ob%solu(k2,j)
              solu(k2,j)=sin_omg*ob%solu(k1,j)+cos_omg*ob%solu(k2,j)
            enddo
            !omp enddo
            ker=k2
          endif
        end select
      enddo
     call move_alloc(solu, ob%solu)
    endif
    call cpu_time(t1)
    write(ob%nlog,'(a,e12.5,a)')'End Rotation Solu - CPU =',t1-t0,' s'
  end subroutine mesh_dg_rotate_solu

  subroutine mesh_dg_display(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    if( ob%nVert   /=0 )write(ob%nlog,'(3x,a,i10)')'Number of vertices:    ',ob%nVert
    if( ob%nH6     /=0 )write(ob%nlog,'(3x,a,i10)')'Number of hexa:        ',ob%nH6
    if( ob%nT4     /=0 )write(ob%nlog,'(3x,a,i10)')'Number of tetra:       ',ob%nT4
    if( ob%nQ4     /=0 )write(ob%nlog,'(3x,a,i10)')'Number of quadrangles: ',ob%nQ4
    if( ob%nT3     /=0 )write(ob%nlog,'(3x,a,i10)')'Number of triangles:   ',ob%nT3
    if( ob%nL2     /=0 )write(ob%nlog,'(3x,a,i10)')'Number of edges:       ',ob%nL2
    if( ob%nfld    /=0 )write(ob%nlog,'(3x,a,i10)')'Number of fields:      ',ob%nfld
    if( ob%nSol    /=0 )write(ob%nlog,'(3x,a,i10)')'Number of solutions:   ',ob%nSol
  end subroutine mesh_dg_display


  subroutine mesh_dg_scale_mesh(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    real(8)               :: coef
    !------------------------------------------------
    write(ob%nlog,'(3x,"Rescaling ",a)')trim(ob%mesh_name)
    write(*,'(3x,"Rescaling coefficient ?")')
    read(*,*)coef
    ob%vertx(1:ob%geo,:)=coef*ob%vertx(1:ob%geo,:)
    write(ob%nlog,'(6x,"Coef ",f12.5/)')coef
  end subroutine mesh_dg_scale_mesh

  subroutine mesh_dg_project_mesh(ob,inside)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    integer               :: i,ishrink
    logical, allocatable  :: inside(:)
    real(8), allocatable  :: vertx(:,:)
    real(8)               :: x0
    real(8)               :: rmin,xmin,ymin,zmin
    real(8)               :: rmax,xmax,ymax,zmax
    real(8)               :: t0,t1
    !------------------------------------------------    
    call cpu_time(t0)
    write(ob%nlog,'(/"Shrinking Mesh Shrink")')
    !
    select case(ob%geo)
    case(2)

      allocate(inside(ob%nvert))

      write(ob%nlog,'(3x,"Select Volume to Project")')
      write(ob%nlog,'(3x,"Enter xmin,ymin,xmax,ymax")')
      write(*,'(3x,"")',advance='no')
      read(*,*)xmin,ymin,xmax,ymax

      write(ob%nlog,'(3x,"Direction of projection")')
      write(ob%nlog,'(3x,"1 x -> x0")')
      write(ob%nlog,'(3x,"2 y -> y0")')
      write(*,'(3x,"")',advance='no')
      read(*,*)ishrink

      select case(ishrink)
      case(1)
        write(ob%nlog,'(3x,"Enter x0")')
        write(*,'(3x,"")',advance='no')
        read(*,*)x0
        ! omp do
        do i=1,ob%nvert
          if(      xmin<=ob%vertx(1,i).and.ob%vertx(1,i)<=xmax &
          &  .and. ymin<=ob%vertx(2,i).and.ob%vertx(2,i)<=ymax )then
            inside(i)=.true.
            ob%vertx(1,i)=x0
          endif
        enddo
        ! omp enddo
      case(2)
        write(ob%nlog,'(3x,"Enter y0")')
        write(*,'(3x,"")',advance='no')
        read(*,*)x0
        ! omp do
        do i=1,ob%nvert
          if(      xmin<=ob%vertx(1,i).and.ob%vertx(1,i)<=xmax &
          &  .and. ymin<=ob%vertx(2,i).and.ob%vertx(2,i)<=ymax )then
            inside(i)=.true.
            ob%vertx(2,i)=x0
          endif
        enddo
        ! omp enddo
      end select

    case(3)

      write(ob%nlog,'(3x,"Select Volume to Shrink")')
      write(ob%nlog,'(3x,"1. Box")')
      write(ob%nlog,'(3x,"2. Cylinder")')
      write(*,'(3x,"")',advance='no')
      read(*,*)ishrink
      !
      allocate(inside(ob%nvert))
      select case(ishrink)
      case(1)
        write(ob%nlog,'(3x,"Enter xmin,ymin,zmin,xmax,ymax,zmax")')
        write(*,'(3x,"")',advance='no')
        read(*,*)xmin,ymin,zmin,xmax,ymax,zmax
        ! omp do
        do i=1,ob%nvert
          if(      xmin<=ob%vertx(1,i).and.ob%vertx(1,i)<=xmax &
          &  .and. ymin<=ob%vertx(2,i).and.ob%vertx(2,i)<=ymax &
          &  .and. zmin<=ob%vertx(3,i).and.ob%vertx(3,i)<=zmax )then
            inside(i)=.true.
          endif
        enddo
        ! omp enddo
      case(2)
        write(ob%nlog,'(3x,"Enter rmin,zmin,rmax,zmax")')
        write(*,'(3x,"")',advance='no')
        read(*,*)rmin,zmin,rmax,zmax
        allocate(vertx(3,ob%nvert))
        ! omp do
        do i=1,ob%nvert
          vertx(1,i)=sqrt(ob%vertx(1,i)**2+ob%vertx(3,i)**2) ! r=sqrt(x^2+z^2)
          vertx(2,i)=atan2(ob%vertx(1,i),ob%vertx(3,i))      ! theta=atan2(x,z)
          vertx(3,i)=ob%vertx(2,i)                           ! z=y
        enddo
        ! omp enddo
        ! omp do
        do i=1,ob%nvert
          if(      rmin<=vertx(1,i).and.vertx(1,i)<=rmax &
          &  .and. zmin<=vertx(3,i).and.vertx(3,i)<=zmax )then
            inside(i)=.true.
          endif
        enddo
        ! omp enddo
        deallocate(vertx)
      end select
      !
      write(ob%nlog,'(3x,"Select Shrinking Technic")')
      write(ob%nlog,'(3x,"1. x-> x0")')
      write(ob%nlog,'(3x,"2. y-> y0")')
      write(ob%nlog,'(3x,"3. z-> z0")')
      write(*,'(3x,"")',advance='no')
      read(*,*)ishrink
      !
      select case(ishrink)
      case(1)
        write(ob%nlog,'(3x,"Enter x0")')
        write(*,'(3x"x0=")',advance='no')
        read(*,*)x0
        ! omp do
        do i=1,ob%nvert
          if( inside(i) )then
            ob%vertx(1,i)=x0
          endif
        enddo
        ! omp enddo
      case(2)
        write(ob%nlog,'(3x,"Enter y0")')
        write(*,'(3x,"y0=")',advance='no')
        read(*,*)x0
        ! omp do
        do i=1,ob%nvert
          if( inside(i) )then
            ob%vertx(2,i)=x0
          endif
        enddo
        ! omp enddo
      case(3)
        write(ob%nlog,'(3x,"Enter z0")')
        write(*,'(3x,"z0=")',advance='no')
        read(*,*)x0
        ! omp do
        do i=1,ob%nvert
          if( inside(i) )then
            ob%vertx(3,i)=x0
          endif
        enddo
        ! omp enddo
      end select
      deallocate(inside)
    end select
    !
    call cpu_time(t1)
    write(ob%nlog,'("End Shrinking Mesh Shrink -CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_project_mesh


  subroutine mesh_dg_extract_skin(ob,BiDim)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    logical               :: BiDim
    !------------------------------------------------
    logical , allocatable :: skin (:)
    integer , allocatable :: index(:)
    real(8) , allocatable :: vertx(:,:)
    real(8) , allocatable :: solu (:,:)
    integer , allocatable :: mark (:)
    integer , allocatable :: quadr(:,:)
    integer , allocatable :: trian(:,:)
    integer , allocatable :: edges(:,:)
    integer               :: i,j,nvert
    logical               :: solution
    real(8)               :: t0,t1
    !------------------------------------------------
    if( ob%nsol==0 )then
      solution=.false.
    else
      solution=.true.
    endif
    !
    call cpu_time(t0)
    write(ob%nlog,'(/"Extracting Skin Cells")')
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
    write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
    write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
    write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
    write(*,'()')

    allocate(skin(ob%nvert),index(ob%nvert))
    !omp do
    do i=1,ob%nvert
      skin(i)=.false.
    enddo
    !omp enddo
    !
    select case(ob%geo)
    case(2)
      ob%nT3=0
      if( ob%nL2==0 )then
        write(ob%nlog,'(3x,a/)')'The mesh doesn''t have any skin'
        stop
      else
        !omp do
        do i=1,ob%nL2
          skin(ob%edges(1,i))=.true.
          skin(ob%edges(2,i))=.true.
        enddo
        !omp enddo
      endif
    case(3)
      if( Bidim )then
        ob%nT3=0
        if( ob%nL2==0 )then
          write(ob%nlog,'(3x,a/)')'The mesh doesn''t have any skin'
          stop
        else
          !omp do
          do i=1,ob%nL2
            skin(ob%edges(1,i))=.true.
            skin(ob%edges(2,i))=.true.
          enddo
          !omp enddo
        endif
      else
        ob%nT4=0
        if( ob%nT3==0 )then
          write(ob%nlog,'(3x,a/)')'The mesh doesn''t have any skin'
          stop
        else
          !omp do
          do i=1,ob%nT3
            skin(ob%trian(1,i))=.true.
            skin(ob%trian(2,i))=.true.
            skin(ob%trian(3,i))=.true.
          enddo
          !omp enddo
          !omp do
          do i=1,ob%nL2
            skin(ob%edges(1,i))=.true.
            skin(ob%edges(2,i))=.true.
          enddo
          !omp enddo
        endif
      endif
    end select
    !
    nvert=count(skin)
    allocate(vertx(size(ob%vertx,1),nvert),mark(nvert))
    if( solution )allocate(solu(size(ob%solu,1),nvert))
    !
    j=0
    do i=1,ob%nvert
      if( skin(i) )then
        j=j+1
        vertx(:,j)=ob%vertx(:,i)
        mark (  j)=ob%mark (  i)
        if( solution )solu(:,j)=ob%solu(:,i)
        index(i)=j
      endif
    enddo
    deallocate(skin)
    !
    call move_alloc(vertx,ob%vertx)
    call move_alloc(mark ,ob%mark )
    ob%nvert=nvert
    if( solution )then
      call move_alloc(solu,ob%solu)
      ob%nsol=nvert
    endif

    if( ob%nL2/=0 )then
      allocate(edges(3,ob%nL2))
      !omp do
      do i=1,ob%nL2
        edges(:,i)=[index(ob%edges(1,i)),&
        &           index(ob%edges(2,i)),&
        &                 ob%edges(3,i) ]
      enddo
      !omp enddo
      call move_alloc(edges,ob%edges)
    endif

    if( ob%nT3/=0 )then
      allocate(trian(4,ob%nT3))
      do i=1,ob%nT3
        trian(:,i)=[index(ob%trian(1,i)),&
        &           index(ob%trian(2,i)),&
        &           index(ob%trian(3,i)),&
        &                 ob%trian(4,i ) ]
       
       !trian(:,i)=[index(ob%trian(1,i)),&
       !&           index(ob%trian(2,i)),&
       !&           index(ob%trian(3,i)),&
       !&                 0              ] 
      enddo
      call move_alloc(trian,ob%trian)
    endif

    if( ob%nQ4/=0 )then
      allocate(quadr(1,ob%nQ4))
      do i=1,ob%nQ4
        quadr(:,i)=[index(ob%quadr(1,i)),&
        &           index(ob%quadr(2,i)),&
        &           index(ob%quadr(3,i)),&
        &           index(ob%quadr(4,i)),&
        &                 ob%quadr(5,i)  ]
      enddo
      call move_alloc(quadr,ob%quadr)
    endif

    write(*,'( 3x,"Final   Number of vertices = ",i10 )')ob%nvert
    if( ob%nT3/=0 )write(*,'( 3x,"Final   Number of triangles= ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'( 3x,"Final   Number of edges    = ",i10 )')ob%nL2
    call cpu_time(t1)
    write(ob%nlog,'("End Extracting Skin Cells - CPU =",e12.5,"s")')t1-t0
  end subroutine mesh_dg_extract_skin

  subroutine mesh_dg_replace_mark(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    real(8)               :: t0,t1
    !------------------------------------------------
    integer               :: i,j,nmark
    integer , allocatable :: idx0(:)
    integer , allocatable :: idx1(:)
    integer , allocatable :: cmpt(:)
    integer , allocatable :: mark (:)
    integer , allocatable :: hexas(:,:)
    integer , allocatable :: tetra(:,:)
    integer , allocatable :: quadr(:,:)
    integer , allocatable :: trian(:,:)
    integer , allocatable :: edges(:,:)
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Change mark")')

    write(*,'(3x,"Number of marker to change")')
    write(*,'(3x,"")',advance='no')
    read(*,*)nmark

    allocate(idx0(nmark),idx1(nmark),cmpt(nmark))
    do i=1,nmark
      write(*,'(6x,"Enter Old mark, New mark  - i=",i2)')i    
      write(*,'(6x,"")',advance='no')
      read(*,*)idx0(i),idx1(i)
    enddo

!    cmpt=0
!    !omp do
!    do i=1,ob%nvert
!      do j=1,nmark
!        if( ob%mark(i)==idx0(j) )then
!          cmpt(j)=cmpt(j)+1
!          ob%mark(i)=idx1(j)
!        endif
!      enddo
!    enddo
!    !omp enddo
!    do j=1,nmark
!      if( cmpt(j)/=0 )then
!        write(ob%nlog,'(3x,"Number of vertx mark changed from ",i2," to ",i2," = ",i10)')idx0(j),idx1(j),cmpt(j)
!      endif
!    enddo

    if( ob%nH6/=0 )then
      cmpt=0
      allocate(hexas(9,ob%nH6))
      !omp do
      do i=1,ob%nH6
        hexas(:,i)=ob%hexas(:,i)
        do j=1,nmark
          if( ob%hexas(9,i)==idx0(j) )then
            cmpt(j)=cmpt(j)+1
            hexas(9,i)=idx1(j)
          endif
        enddo
      enddo
      !omp enddo    
      call move_alloc(hexas,ob%hexas)

      do j=1,nmark
        if( cmpt(j)/=0 )then
          write(ob%nlog,'(3x,"Number of hexah mark changed from ",i2," to ",i2," = ",i10)')idx0(j),idx1(j),cmpt(j)
        endif
      enddo
    endif

    if( ob%nT4/=0 )then
      cmpt=0
      allocate(tetra(5,ob%nT4))
      !omp do
      do i=1,ob%nT4
        tetra(:,i)=ob%tetra(:,i)
        do j=1,nmark
          if( ob%tetra(5,i)==idx0(j) )then
            cmpt(j)=cmpt(j)+1
            tetra(5,i)=idx1(j)
          endif
        enddo
      enddo
      !omp enddo
      call move_alloc(tetra,ob%tetra)

      do j=1,nmark
        if( cmpt(j)/=0 )then
          write(ob%nlog,'(3x,"Number of tetra mark changed from ",i2," to ",i2," = ",i10)')idx0(j),idx1(j),cmpt(j)
        endif
      enddo
    endif

    if( ob%nQ4/=0 )then
      cmpt=0
      allocate(quadr(5,ob%nQ4))
      !omp do
      do i=1,ob%nQ4
        quadr(:,i)=ob%quadr(:,i)
        do j=1,nmark
          if( ob%quadr(5,i)==idx0(j) )then
            cmpt(j)=cmpt(j)+1
            quadr(5,i)=idx1(j)
          endif
        enddo
      enddo
      !omp enddo
      call move_alloc(quadr,ob%quadr)

      do j=1,nmark
        if( cmpt(j)/=0 )then
          write(ob%nlog,'(3x,"Number of quadr mark changed from ",i2," to ",i2," = ",i10)')idx0(j),idx1(j),cmpt(j)
        endif
      enddo
    endif

    if( ob%nT3/=0 )then
      cmpt=0
      allocate(trian(4,ob%nT3))
      !omp do
      do i=1,ob%nT3
        trian(:,i)=ob%trian(:,i)
        do j=1,nmark
          if( ob%trian(4,i)==idx0(j) )then
            cmpt(j)=cmpt(j)+1
            trian(4,i)=idx1(j)
          endif
        enddo
      enddo
      !omp enddo    
      call move_alloc(trian,ob%trian)

      do j=1,nmark
        if( cmpt(j)/=0 )then
          write(ob%nlog,'(3x,"Number of trian mark changed from ",i2," to ",i2," = ",i10)')idx0(j),idx1(j),cmpt(j)
        endif
      enddo
    endif

    if( ob%nL2/=0 )then
      cmpt=0
      allocate(edges(3,ob%nL2))
      !omp do
      do i=1,ob%nL2
        edges(:,i)=ob%edges(:,i)
        do j=1,nmark
          if( ob%edges(3,i)==idx0(j) )then
            cmpt(j)=cmpt(j)+1
            edges(3,i)=idx1(j)
          endif
        enddo
      enddo
      !omp enddo
      call move_alloc(edges,ob%edges)
      
      do j=1,nmark
        if( cmpt(j)/=0 )then
          write(ob%nlog,'(3x,"Number of edges mark changed from ",i2," to ",i2," = ",i3)')idx0(j),idx1(j),cmpt(j)
        endif
      enddo
    endif

    deallocate(idx0,idx1,cmpt)

    call cpu_time(t1)
    write(ob%nlog,'( "End Change mark - CPU",e12.4," s")')t1-t0
  end subroutine mesh_dg_replace_mark

  subroutine mesh_dg_skin_create(ob,mark0)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    integer , optional    :: mark0
    !------------------------------------------------
    real(8)               :: t0,t1
    integer               :: i,j
    integer               :: l,min_ei,max_ei,na,n,s,ne
    integer               :: n1(4),n2(4),n3(4)
    integer, allocatable  :: neighbour(:,:)
    integer, allocatable  :: key(:),link(:),min(:),max(:)
    integer, allocatable  :: edges (:,:)
    integer, allocatable  :: edges1(:,:)
    integer, allocatable  :: trian (:,:)
    integer, allocatable  :: trian1(:,:)
    integer               :: i_min,n_min,nod0(3),nod1(3)
    integer               :: nm(0:9)
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Building Mesh Skin")')
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
!    do i=0,9
!      nm(i)=count(ob%mark==i)
!      if( nm(i)/=0 )write(ob%nlog,'(6x,"mark",i1,":",14x,i10)')i,nm(i)
!    enddo
    if( ob%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
   !write(*,'()')

    select case(ob%geo)
    case(2)

      ne=3*ob%nT3
      allocate(edges(2,ne))
      allocate(neighbour(2,ne)) ; neighbour=0
      allocate(key(2*ob%nvert)) ; key (:)=0
      allocate(min (ne))        ; min (:)=0
      allocate(link(ne))        ; link(:)=0

      ! Construction des aretes par table de hachage
      na=0
      do i=1,ob%nT3
        n=3
        !        F1            F2            F3     
        n1(1:3)=[ob%trian(1,i),ob%trian(2,i),ob%trian(3,i)]
        n2(1:3)=[ob%trian(2,i),ob%trian(3,i),ob%trian(1,i)]
        !
        do j=1,n
          s=n1(j)+n2(j)
          min_ei=minval([n1(j),n2(j)])
          if( key(s)==0 )then ! nouvelle arete
            na=na+1
            key(s)=na
            min(na)=min_ei
            edges(1,na)=n1(j)
            edges(2,na)=n2(j)
            neighbour(1,na)=i
          else
            l=key(s)
            iter2D : do
              if( link(l)==0 .or. min(l)==min_ei )exit iter2D
              l=link(l)
            enddo iter2D
            if( min(l)/=min_ei )then
              na=na+1
              link(l)=na
              min(na)=min_ei
              edges(1,na)=n1(j)
              edges(2,na)=n2(j)
              neighbour(1,na)=i
            else
              neighbour(2,l)=-i ! orientation opposee
            endif

          endif
        enddo
      enddo
      deallocate(key,link,min)
      !
      ne=count(neighbour(2,1:na)==0)
      allocate(edges1(3,ne))
      j=0
      do i=1,na
        if( neighbour(2,i)==0 )then
          j=j+1
          edges1(1,j)=edges(1,i)
          edges1(2,j)=edges(2,i)
          edges1(3,j)=ob%trian(4,neighbour(1,i))
        endif
      enddo
      ob%nL2=ne ; call move_alloc(edges1, ob%edges)
      deallocate(edges,neighbour)

      do i=1,ob%nL2
        if    (    (ob%mark(ob%edges(1,i))==0.or. ob%mark(ob%edges(2,i))==0) )then
          ob%edges(3,i)=5
        elseif(    (ob%mark(ob%edges(1,i))==5.or. ob%mark(ob%edges(2,i))==5) )then
          ob%edges(3,i)=5
        elseif(    (ob%mark(ob%edges(1,i))==1.or. ob%mark(ob%edges(2,i))==1) )then
          ob%edges(3,i)=1
        elseif(    (ob%mark(ob%edges(1,i))==2.or. ob%mark(ob%edges(2,i))==2) )then
          ob%edges(3,i)=2
        elseif(    (ob%mark(ob%edges(1,i))==3.or. ob%mark(ob%edges(2,i))==3) )then
          ob%edges(3,i)=3
        elseif(    (ob%mark(ob%edges(1,i))==4.and.ob%mark(ob%edges(2,i))==4) )then
          ob%edges(3,i)=4
        elseif(    (ob%mark(ob%edges(1,i))==6.and.ob%mark(ob%edges(2,i))==6) )then
          ob%edges(3,i)=6
        else
          write(*,'("warning: L2 element with mark(nd1)=",i2," - mark(nd2)=",i2)')&
          & ob%mark(ob%edges(1,i)),ob%mark(ob%edges(2,i))
        endif
      enddo
      
    case(3)

      ne=4*ob%nT4
      allocate(trian(3,ne))
      allocate(neighbour(2,ne))
      allocate(key(3*ob%nvert)) ; key (:)=0
      allocate(min (ne))        ; min (:)=0
      allocate(max (ne))        ; max (:)=0
      allocate(link(ne))        ; link(:)=0

      ! Construction des aretes par table de hachage
      na=0
      do i=1,ob%nT4
        n=4
        !        F1            F2            F3            F4
        n1(1:4)=[ob%tetra(2,i),ob%tetra(1,i),ob%tetra(1,i),ob%tetra(1,i)]
        n2(1:4)=[ob%tetra(3,i),ob%tetra(4,i),ob%tetra(2,i),ob%tetra(3,i)]
        n3(1:4)=[ob%tetra(4,i),ob%tetra(3,i),ob%tetra(4,i),ob%tetra(2,i)]
        !
        do j=1,n
          s=n1(j)+n2(j)+n3(j)
          min_ei=minval([n1(j),n2(j),n3(j)])
          max_ei=maxval([n1(j),n2(j),n3(j)])
          if( key(s)==0 )then ! nouvelle arete
            na=na+1
            key(s)=na
            min(na)=min_ei
            max(na)=max_ei
            trian(1,na)=n1(j)
            trian(2,na)=n2(j)
            trian(3,na)=n3(j)
            neighbour(1,na)=i
          else
            l=key(s)
            Iter3D : do
              if( link(l)==0 .or. (min(l)==min_ei.and.max(l)==max_ei) )exit Iter3D
              l=link(l)
            enddo Iter3D
            if( min(l)/=min_ei.or.max(l)/=max_ei )then
              na=na+1
              link(l)=na
              min(na)=min_ei
              max(na)=max_ei
              trian(1,na)=n1(j)
              trian(2,na)=n2(j)
              trian(3,na)=n3(j)
              neighbour(1,na)=i
            else
              neighbour(2,l)=-i ! orientation opposee
            endif

          endif
        enddo
      enddo
      deallocate(key,link,min,max)
      !
      ne=count(neighbour(2,1:na)==0)
      allocate(trian1(4,ne))
      j=0
      do i=1,na
        if( neighbour(2,i)==0 )then
          j=j+1
          !
          nod0(1:3)=[trian(1,i),&
          &          trian(2,i),&
          &          trian(3,i) ]
          do l=2,3
            if( nod0(l)<n_min )then
              i_min=     l
              n_min=nod0(l)
            endif
          enddo
          nod1(1:3)=cshift(nod0(1:3),i_min-1)
          !
          trian1(1,j)=nod1(1)
          trian1(2,j)=nod1(2)
          trian1(3,j)=nod1(3)
          trian1(4,j)=ob%tetra(5,neighbour(1,i))
        endif
      enddo
      ob%nT3=ne ; call move_alloc(trian1, ob%trian)
      deallocate(trian,neighbour)

      if( present(mark0) )then
        ob%trian(4,:)=mark0
      else
        do i=1,ob%nT3
          if    (    (ob%mark(ob%trian(1,i))==0.or. ob%mark(ob%trian(2,i))==0.or. ob%mark(ob%trian(3,i))==0) )then
            ob%trian(4,i)=5
          elseif(    (ob%mark(ob%trian(1,i))==5.or. ob%mark(ob%trian(2,i))==5.or. ob%mark(ob%trian(3,i))==5) )then
            ob%trian(4,i)=5
          elseif(    (ob%mark(ob%trian(1,i))==1.or. ob%mark(ob%trian(2,i))==1.or. ob%mark(ob%trian(3,i))==1) )then
            ob%trian(4,i)=1
          elseif(    (ob%mark(ob%trian(1,i))==2.or. ob%mark(ob%trian(2,i))==2.or. ob%mark(ob%trian(3,i))==2) )then
            ob%trian(4,i)=2
          elseif(    (ob%mark(ob%trian(1,i))==3.or. ob%mark(ob%trian(2,i))==3.or. ob%mark(ob%trian(3,i))==3) )then
            ob%trian(4,i)=3
          elseif(    (ob%mark(ob%trian(1,i))==4.and.ob%mark(ob%trian(2,i))==4.and.ob%mark(ob%trian(3,i))==4) )then
            ob%trian(4,i)=4
          elseif(    (ob%mark(ob%trian(1,i))==6.and.ob%mark(ob%trian(2,i))==6.and.ob%mark(ob%trian(3,i))==6) )then
            ob%trian(4,i)=6
          else
            write(*,'("warning: T3 element with mark(nd1)=",i2," - mark(nd2)=",i2," - mark(nd3)=",i2)') &
            & ob%mark(ob%trian(1,i)),ob%mark(ob%trian(2,i)),ob%mark(ob%trian(3,i))
          endif
        enddo
      endif


    end select
    call cpu_time(t1)

    write(*,'( 3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10 )')ob%nL2
    write(ob%nlog,'("End Building Mesh Skin - CPU =",e12.5,"s")')t1-t0
  end subroutine mesh_dg_skin_create

  subroutine mesh_dg_skin_delete(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    select case(ob%geo)
    case(2)
      ob%nL2=0    ; if( allocated(ob%edges) )deallocate(ob%edges)
    case(3)
      ob%nT3=0    ; if( allocated(ob%trian) )deallocate(ob%trian)
      ob%nL2=0    ; if( allocated(ob%edges) )deallocate(ob%edges)
    end select
  end subroutine mesh_dg_skin_delete


  subroutine mesh_dg_skin3D(ob,ascii)
   !------------------------------------------------------------------
   !   mesh_skin3D
   !   Christophe Peyret
   !   Created on Thu July 12 2007
   !------------------------------------------------------------------
  !use m_libmesh5
   use M_libmesh5_api
   !------------------------------------------------
   type(mesh_dg)         :: ob
   logical, intent(in)   :: ascii
   !------------------------------------------------
   real(8) , parameter   :: pi =3.14159265358979
   real(8) , parameter   :: pi2=6.28318530717959
   type(mesh_dg)         :: ob1,ob2
   integer               :: i,k
   integer               :: out,res,ver
   logical , allocatable :: keep(:)
   integer , allocatable :: idx0(:)
   integer , allocatable :: idx1(:)
   integer , allocatable :: grid(:,:)
   integer               :: nd(4)
   integer               :: iVert,jVert,iEdg
   integer               :: iRot,nRot
   real(8)               :: dRot
   real(8)               :: theta0
   integer               :: j,j0,j1,n,iT3,iQ4
   integer               :: ed4,nd4
   ! -----------------------------------------------------------------------
   ! vertices

   allocate(keep(ob%nvert)) ; keep=.false.

   do iEdg=1,ob%nL2
     select case(ob%edges(3,iEdg))
     case(4)
       ob%mark(ob%edges(1,iEdg))=4
       ob%mark(ob%edges(2,iEdg))=4
     case(6)
       ob%mark(ob%edges(1,iEdg))=6
       ob%mark(ob%edges(2,iEdg))=6
     end select
     !
     if( ob%edges(3,iEdg)/=4 )then
       keep(ob%edges(1,iEdg))=.true.
       keep(ob%edges(2,iEdg))=.true.
       !
       if( ob%vertx(2,ob%edges(1,iEdg))==0. .and. ob%vertx(2,ob%edges(2,iEdg))==0. )then
         write(*,'("Stop @ mesh_dg_skin3D: Edge",i10," should be marked 4 rather than mark=",i3)')iEdg,ob%edges(3,iEdg)
         stop
       endif
     endif
   enddo

   ob1%nvert=count(keep)
   allocate(ob1%vertx(2,ob1%nvert),ob1%mark(ob1%nvert))
   allocate(idx0(ob%nvert)) ; idx0=0

   n=0
   do iVert=1,ob%nvert
     if( keep(iVert) )then
       n=n+1 ; idx0(iVert)=n
       ob1%vertx(1:2,n)=ob%vertx(1:2,iVert)
       ob1%mark (    n)=ob%mark (    iVert)
     endif
   enddo
   deallocate(keep)

   ! edges
   ob1%nL2=count(ob%edges(3,:)/=4)
   allocate(ob1%edges(3,ob1%nL2))

   n=0
   do iEdg=1,ob%nL2
     if( ob%edges(3,iEdg)/=4 )then
       n=n+1
       ob1%edges(1,n)=idx0(ob%edges(1,iEdg))
       ob1%edges(2,n)=idx0(ob%edges(2,iEdg))
       ob1%edges(3,n)=     ob%edges(3,iEdg)
     endif
   enddo

   deallocate(idx0)

   write(*,'("Keeping ",i10," vertices")')ob1%nvert
   write(*,'("Keeping ",i10," edges")'   )ob1%nL2

   select case( ascii )
   case(.true. ) ; ob2%mesh_name=trim(ob%mesh_name)//'_skin3D.mesh'
   case(.false.) ; ob2%mesh_name=trim(ob%mesh_name)//'_skin3D.meshb'
   end select

   ob2%geo=3
   nRot=180 ; dRot=pi2/real(nRot,kind=8)

   ! Number and list of nodes marked 4
   nd4=count(ob1%mark==4)
   allocate(idx0(nd4))
   idx0=pack([1:ob1%nvert],ob1%mark==4)

   ! Number and list of edges containing 1 node marked 4
   ed4=nd4
   allocate(idx1(ed4))
   !
   ed4=0
   do iEdg=1,ob1%nL2
     if( ob1%mark(ob1%edges(1,iEdg))==4 )then
       ed4=ed4+1
       idx1(ed4)=iEdg
     endif
     if( ob1%mark(ob1%edges(2,iEdg))==4 )then
       ed4=ed4+1
       idx1(ed4)=iEdg
     endif
   enddo

   ! node marked 4 are change to the mark of porting edge
   do iEdg=1,ed4
     if( ob1%mark(ob1%edges(1,idx1(iEdg)))==4 )ob1%mark(ob1%edges(1,idx1(iEdg)))=ob1%edges(3,idx1(iEdg))
     if( ob1%mark(ob1%edges(2,idx1(iEdg)))==4 )ob1%mark(ob1%edges(2,idx1(iEdg)))=ob1%edges(3,idx1(iEdg))
   enddo

   ! Vertices

   ob2%nvert=nRot*(ob1%nvert-nd4)+nd4
   allocate(ob2%vertx(ob2%geo,ob2%nvert),ob2%mark(ob2%nvert))

   n=0
   theta0=0d0
   do iVert=1,ob1%nvert
     n=n+1
     ob2%vertx(1,n)=ob1%vertx(1,iVert)
     ob2%vertx(2,n)=ob1%vertx(2,iVert)
     ob2%vertx(3,n)=0d0
     ob2%mark (  n)=ob1%mark (  iVert)        
   enddo
   ! rotation
   do iRot=1,nRot-1
     theta0=real(iRot,kind=8)*dRot
     k=1
     do iVert=1,ob1%nvert
       if( iVert==idx0(k) .and. .not.k>nd4 )then
         k=k+1
       else
         n=n+1
         ob2%vertx(1,n)=ob1%vertx(1,iVert)
         ob2%vertx(2,n)=ob1%vertx(2,iVert)*cos(theta0)
         ob2%vertx(3,n)=ob1%vertx(2,iVert)*sin(theta0)
         ob2%mark (  n)=ob1%mark (  iVert)
       endif
     enddo
   enddo
   !
   ob2%nQ4=(ob1%nL2-ed4)*nRot
   ob2%nT3=(        ed4)*nRot
   ob2%nL2=0
   allocate(ob2%trian(4,ob2%nT3))
   allocate(ob2%quadr(5,ob2%nQ4))


   allocate(grid(ob1%nvert,0:nRot))
   !
   grid(:,0)=[(i,i=1,ob1%nvert)]    ! iRot=0
   jVert=grid(ob1%nvert,0)
   do iRot=1,nRot-1                 ! iRot=1:nRot-1
     k=1
     do iVert=1,ob1%nvert
       if( iVert==idx0(k) .and. k<=nd4 )then
         grid(iVert,iRot)=idx0(k)
         k=k+1
       else
         jVert=jVert+1
         grid(iVert,iRot)=jVert
       endif
     enddo
   enddo
   grid(:,nRot)=grid(:,0)        ! iRot=nRot


   iT3=0
   iQ4=0
   do iRot=0,nRot-1
     do iEdg=1,ob1%nL2
       nd=[grid(ob1%edges(1,iEdg),iRot  ),&
       &   grid(ob1%edges(2,iEdg),iRot  ),&
       &   grid(ob1%edges(2,iEdg),iRot+1),&
       &   grid(ob1%edges(1,iEdg),iRot+1) ]

       if( nd(1)==nd(4) )then
         !    3
         !    x
         !   /|
         !  / |
         ! x--x
         ! 1  2
         iT3=iT3+1
         ob2%trian(1:4,iT3)=[nd(1),nd(2),nd(3),ob1%edges(3,iEdg)]        
       elseif( nd(2)==nd(3) )then
         ! 4
         ! x
         ! |\
         ! | \
         ! x--x
         ! 1  2
         iT3=iT3+1
         ob2%trian(1:4,iT3)=[nd(1),nd(2),nd(4),ob1%edges(3,iEdg)]
       else
         ! 4       3
         ! x-------x
         ! |       |
         ! |       |
         ! x-------x
         ! 1       2
         iQ4=iQ4+1
         ob2%quadr(1:5,iQ4)=[nd(1),nd(2),nd(3),nd(4),ob1%edges(3,iEdg)]
       endif
     enddo
   enddo


   write(*,'("Number of Vertices       = ",i10)')ob2%nvert
   write(*,'("Number of Quadrilaterals = ",i10)')iQ4
   write(*,'("Number of Triangles      = ",i10)')iT3
   write(*,'("Number of Edges          = ",i10)')ob2%nL2

   deallocate(grid)
   deallocate(idx0)
   deallocate(idx1)

   call mesh_dg_write_mesh(ob=ob2,skin=.true.)

   call mesh_dg_delete(ob1)
   call mesh_dg_delete(ob2)

 end subroutine mesh_dg_skin3D


  subroutine mesh_dg_skin_marked(ob,BiDim)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    logical               :: BiDim
    !------------------------------------------------
    integer, allocatable  :: list    (:)
    logical, allocatable  :: skin    (:)
    integer, allocatable  :: index   (:)
    integer               :: nVert=0
    real(8), allocatable  :: vertx   (:,:)
    integer               :: nQ4=0
    integer, allocatable  :: quadr   (:,:)
    integer               :: nT3=0
    integer, allocatable  :: trian   (:,:)
    integer               :: nL2=0
    integer, allocatable  :: edges   (:,:)
    real(8), allocatable  :: solu    (:,:)
    integer, allocatable  :: mark    (:)
    integer               :: i,j,k,n
    real(8)               :: t0,t1
    logical               :: solution
    integer               :: err
    !------------------------------------------------
    if( ob%nsol==0 )then
      solution=.false.
    else
      solution=.true.
    endif

    call cpu_time(t0)
    write(ob%nlog,'(/"Extracting Marked Skin Cells")')
    write               (*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
    if( ob%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob%nQ4
    if( ob%nT3/=0 )write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
    if( ob%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
    !
    write(*,'(3x,"Number of Mark(s) to extract")')
    write(*,'(3x,"")',advance='no')
    read(*,*)n
    write(*,'(3x,"List of Mark(s)")')
    allocate(list(n))
    do i=1,n
      write(*,'(3x,"")',advance='no')
      read(*,*)j
      list(i)=j
    enddo
    
    allocate(skin(ob%nvert),index(ob%nvert),stat=err)
    if( err/=0 )then
      write(*,'("mesh_dg_skin_marked: memory allocation error ",i3)')err
    endif

    skin=.false.
    !
    select case( ob%geo )
    case(2)
      !
      ob%nT3=0 ; if( allocated(ob%trian) )deallocate(ob%trian)
      ob%nQ4=0 ; if( allocated(ob%quadr) )deallocate(ob%quadr)
      if( ob%nL2==0 )then
        write(ob%nlog,'(3x,a/)')'The mesh doesn''t have any skin'
        stop
      else
        nL2=0
        !omp do
        do i=1,ob%nL2
          do j=1,n
            if( list(j)==ob%edges(3,i) )then
              nL2=nL2+1
              skin(ob%edges(1,i))=.true.
              skin(ob%edges(2,i))=.true.
            endif
          enddo
        enddo
        !omp enddo
      endif
      !
    case(3)
      !
      if( Bidim )then
        ob%nT3=0
        if( ob%nL2==0 )then
          write(ob%nlog,'(3x,a/)')'The mesh doesn''t have any skin'
          stop
        else
          nL2=0
          !omp do
          do i=1,ob%nL2
            do j=1,n
              if( list(j)==ob%edges(3,i) )then
                nL2=nL2+1
                skin(ob%edges(1,i))=.true.
                skin(ob%edges(2,i))=.true.
              endif
            enddo
          enddo
          !omp enddo
        endif
      else
        ob%nT4=0
        if( ob%nT3==0 .and. ob%nQ4==0 )then
          write(ob%nlog,'(3x,a/)')'The mesh doesn''t have any skin'
          stop
        else

          nQ4=0
          !omp do
          do i=1,ob%nQ4
            do j=1,n
              if( list(j)==ob%quadr(5,i) )then
                nQ4=nQ4+1
                skin(ob%quadr(1,i))=.true.
                skin(ob%quadr(2,i))=.true.
                skin(ob%quadr(3,i))=.true.
                skin(ob%quadr(4,i))=.true.
              endif
            enddo
          enddo
          !omp enddo

          nT3=0
          !omp do
          do i=1,ob%nT3
            do j=1,n
              if( list(j)==ob%trian(4,i) )then
                nT3=nT3+1
                skin(ob%trian(1,i))=.true.
                skin(ob%trian(2,i))=.true.
                skin(ob%trian(3,i))=.true.
              endif
            enddo
          enddo
          !omp enddo

          ! This cells are not store because of problems occuring with Nacelles
          nL2=0
!          !omp do
!          do i=1,ob%nL2
!            do j=1,n
!              if( list(j)==ob%edges(3,i) )then
!                nL2=nL2+1
!                skin(ob%edges(1,i))=.true.
!                skin(ob%edges(2,i))=.true.
!              endif
!            enddo
!          enddo
!          !omp enddo
        endif
      endif
    end select
    !
    nvert=count(skin)
    allocate(vertx(size(ob%vertx,1),nvert),mark(nvert))
    if( solution )allocate(solu(size(ob%solu,1),nvert))

    write(ob%nlog,'(6x,a,i10)')'Initial Number of Vertices ',ob%nvert
    write(ob%nlog,'(6x,a,i10)')'Final   Number of Vertices ',   nvert


    j=0
    do i=1,ob%nvert
      if( skin(i) )then
        j=j+1
        vertx(:,j)=ob%vertx(:,i)
        mark (  j)=ob%mark (  i)
        if( solution )solu(:,j)=ob%solu(:,i)
        index(i)=j
      endif
    enddo
    deallocate(skin)
    !
    call move_alloc(vertx,ob%vertx)
    call move_alloc(mark ,ob%mark )
    ob%nvert=nvert
    if( solution )then
      call move_alloc(solu    ,ob%solu    )
      ob%nsol=nvert
    endif


    if( nL2/=0 )then
      allocate(edges(3,nL2))
      k=0
      do i=1,ob%nL2
        do j=1,size(list)
          if( list(j)==ob%edges(3,i) )then
            k=k+1
            edges(:,k)=[index(ob%edges(1,i)),&
            &           index(ob%edges(2,i)),&
            &                 ob%edges(3,i) ]
          endif
        enddo
      enddo
      ob%nL2=nL2
      call move_alloc(edges,ob%edges)
    endif

    if( nT3/=0 )then
      allocate(trian(4,nT3))
      k=0
      do i=1,ob%nT3
        do j=1,size(list)
          if( list(j)==ob%trian(4,i) )then
            k=k+1
            trian(:,k)=[index(ob%trian(1,i)),&
            &           index(ob%trian(2,i)),&
            &           index(ob%trian(3,i)),&
            &                 ob%trian(4,i) ]
          endif
        enddo
      enddo
      ob%nT3=nT3
      call move_alloc(trian,ob%trian)
    endif

    if( nQ4/=0 )then
      allocate(quadr(5,nQ4))
      k=0
      do i=1,ob%nQ4
        do j=1,size(list)
          if( list(j)==ob%quadr(5,i) )then
            k=k+1
            quadr(:,k)=[index(ob%quadr(1,i)),&
            &           index(ob%quadr(2,i)),&
            &           index(ob%quadr(3,i)),&
            &           index(ob%quadr(4,i)),&
            &                 ob%quadr(5,i) ]
          endif
        enddo
      enddo
      ob%nQ4=nQ4
      call move_alloc(quadr,ob%quadr)
    endif


    deallocate(list,index)

    call cpu_time(t1)
    write(ob%nlog,'("End Extracting marked skin - CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_skin_marked


  subroutine mesh_dg_smouth_solu(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    real(8)               :: xyz0(3),xyz1(3),dxyz(3)
    real(8) , allocatable :: solu(:,:)
    integer               :: i,iVert
    integer               :: iCell,iNod,iBoule,iFilter
    integer               :: rMin,rMax
    logical , allocatable :: bool(:)
    integer , allocatable :: adCell   (:)
    integer , allocatable :: sizeCell (:)
    integer , allocatable :: bouleCell(:)
    integer , allocatable :: adVert   (:)
    integer , allocatable :: sizeVert (:)
    integer , allocatable :: bouleVert(:)
    real(8)               :: t0,t1
    real(8)               :: wi,sumWi,sigma
    real(8) , parameter   :: pi=3.141592653589793
    character(256)        :: solu_name
    character(3)          :: index
    !------------------------------------------------
!    do iCell=1,ob%nT3
!      xyz=( ob%vertx(:,ob%trian(1,iCell)) &
!      &    +ob%vertx(:,ob%trian(2,iCell)) &
!      &    +ob%vertx(:,ob%trian(3,iCell)) )/ 3d0
!
!      if( xyz(1)>3d0 .and. ob%trian(4,iCell)/=2)then
!        write(*,'("x=",f12.5," m=",i2)')xyz(1),ob%trian(4,iCell)
!        ob%trian(4,iCell)=2
!      endif
!    enddo
!
!    ob%mesh_name="toto.mesh"
!    call mesh_dg_write_mesh(ob=ob,skin=.false.)
!    return


!stop

    if( allocated(ob%solu) )then
      call cpu_time(t0)
      write(*,'(/"Applying Gaussian Filter to Solu")')
      !
      select case(ob%geo)
      case(2)
      case(3)

        write(*,'(3x,"Building Cell Bubles for each Vertex")')

        allocate(sizeCell(ob%nVert)) ; sizeCell=0
        do iCell=1,ob%nT4
          do iNod=1,4
            iVert=ob%tetra(iNod,iCell)
            sizeCell(iVert)=sizeCell(iVert)+1
          enddo      
        enddo
        !
        !
        allocate(adCell(ob%nVert+1)) ; adCell(1)=1
        do iVert=1,ob%nVert
          adCell(iVert+1)=adCell(iVert)+sizeCell(iVert)
        enddo

        allocate(bouleCell( sum([(sizeCell(iVert), iVert=1,ob%nVert)]) ) )
       !write(*,'(3x,"size=",i12)')size(bouleCell)

        sizeCell=0
        do iCell=1,ob%nT4
          do iNod=1,4
            iVert=ob%tetra(iNod,iCell)
            bouleCell( adCell(iVert)+sizeCell(iVert) )=iCell
            sizeCell(iVert)=sizeCell(iVert)+1
          enddo
        enddo
      
        rMin=minval(sizeCell)
        rMax=maxval(sizeCell)
        write(*,'(3x,"Cell Bubles Builded, rMin=",i3," rMax=",i3)')rMin,rMax

        write(*,'(3x,"Building Vert Bubles for each Vertex")')

        allocate(bool(ob%nVert),sizeVert(ob%nVert))

        do iVert=1,ob%nVert
          bool=.false.
          do iCell=adCell(iVert),adCell(iVert+1)-1
            iBoule=bouleCell(iCell)
           !write(*,'(9x,"Cell=",i12)')iBoule
            do iNod=1,4
              if( ob%tetra(iNod,iBoule)/=iVert )then
               !write(*,'(12x,"iNod=",i12)')ob%tetra(iNod,iBoule)
                bool(ob%tetra(iNod,iBoule))=.true.
              endif
            enddo
          enddo
          sizeVert(iVert)=count(bool==.true.)
         !write(*,'(6x,"iVert=",i12," size(cellBoule)=",i3," size(vertBoule)=",i3)')iVert,sizeCell(iVert),sizeVert(iVert)
         !write(*,'("count(bool=.true.)=",i12)')sizeVert(iVert)
         !write(*,'("idx",15i6)')pack( [(i, i=1,ob%nVert)] ,bool==.true.)
        enddo

        allocate(adVert(ob%nVert+1)) ; adVert(1)=1
        do iVert=1,ob%nVert
          adVert(iVert+1)=adVert(iVert)+sizeVert(iVert)
        enddo

        allocate(bouleVert( sum([(sizeVert(iVert), iVert=1,ob%nVert)]) ) )
        !write(*,'(3x,"size=",i12)')size(bouleVert)

        do iVert=1,ob%nVert
          bool=.false.
          do iCell=adCell(iVert),adCell(iVert+1)-1
            iBoule=bouleCell(iCell)
           !write(*,'(9x,"Cell=",i12)')iBoule
            do iNod=1,4
              if( ob%tetra(iNod,iBoule)/=iVert )then
               !write(*,'(12x,"iNod=",i12)')ob%tetra(iNod,iBoule)
                bool(ob%tetra(iNod,iBoule))=.true.
              endif
            enddo
          enddo
          sizeVert(iVert)=count(bool==.true.)
          bouleVert( adVert(iVert):adVert(iVert+1)-1 )=pack([(i, i=1,ob%nVert)] ,bool==.true.)
         !write(*,'(6x,"iVert=",i12," size(cellBoule)=",i3," size(vertBoule)=",i3)')iVert,sizeCell(iVert),sizeVert(iVert)
        !if( iVert==10 )then
        !  write(*,'("count(bool==.true.)=",i12)')sizeVert(iVert)
        !  write(*,'("idx",15i6)')pack([(i, i=1,ob%nVert)] ,bool==.true.)
        !endif
        enddo

       !write(*,'(/"idx",15i6)')bouleVert( adVert(10):adVert(11)-1 )

        rMin=minval(sizeVert) ; rMax=maxval(sizeVert)
        write(*,'(3x,"Vert Bubles Builded, rMin=",i3," rMax=",i3)')rMin,rMax

        write(*,'(/3x,"BoundingBox")')
        write(*,'(6x,"min/max x=",f12.5,1x,f12.5)')ob%xmin,ob%xmax
        write(*,'(6x,"min/max y=",f12.5,1x,f12.5)')ob%ymin,ob%ymax
        write(*,'(6x,"min/max z=",f12.5,1x,f12.5)')ob%zmin,ob%zmax

        dxyz=[ob%xmax-ob%xmin,ob%ymax-ob%ymin,ob%zmax-ob%zmin]
        sigma=sqrt(dxyz(1)*dxyz(1)+dxyz(2)*dxyz(2)+dxyz(3)*dxyz(3))/real(ob%nVert,kind=8)**(1d0/3d0)
        write(*,'(6x,"sigma=",e22.15)')sigma

        solu_name=trim(ob%solu_name)
        do iFilter=1,10
          write(*,'(3x,"Filtering Data Step ",i1)')iFilter
          allocate(solu(size(ob%solu,1),size(ob%solu,2)))
          do iVert=1,ob%nVert
            !
            xyz0(:)=ob%vertx(:,iVert) ; sumWi=1d0
            solu(:,iVert)=ob%solu(:,iVert) 
            do iBoule=adVert(iVert),adVert(iVert+1)-1        
              iNod=bouleVert(iBoule)
              xyz1(:)=ob%vertx(:,iNod)
              dxyz=xyz1-xyz0 ; wi=exp(-( dxyz(1)*dxyz(1)+dxyz(2)*dxyz(2)+dxyz(3)*dxyz(3))/(sigma*sigma)) ; sumWi=sumWi+wi
              solu(:,iVert)=solu(:,iVert)+wi*ob%solu(:,iNod)
!            if( iVert==10 )then
!              write(*,'("li=",e22.15," wi=",e22.15" sumWi=",e22.15)')sqrt(dxyz(1)*dxyz(1)+dxyz(2)*dxyz(2)+dxyz(3)*dxyz(3)),wi,sumWi
!            endif
            enddo
            solu(:,iVert)=solu(:,iVert)/sumWi
          enddo
          !
          call move_alloc(solu,ob%solu)
          !
          select case(iFilter)
          case(     0:     9) ; write(index,'(a2,i1)')'00',iFilter
          case(    10:    99) ; write(index,'(a1,i2)')'0',iFilter
          case(   100:   999) ; write(index,'(   i3)')   iFilter
          case default
            write(*,'("mpiColor =",i10)')iFilter
            write(*,'("Value is out of Range [1,999]")')
            write(*,'(/"STOP @ couplingCwipiInit"/)')
            stop
          end select
          !
          ob%solu_name=trim(solu_name)//"GaussFiltered"//index//".solb"
          call mesh_dg_write_solu(ob)
        enddo
        !
        deallocate(sizeCell,adCell,bouleCell)
        deallocate(sizeVert,adVert,bouleVert)
      end select
      !
      !
      call cpu_time(t1)
      write(*,'("End Applying Gaussian Filter to Solu - CPU",e12.5," s")')t1-t0
    endif

  end subroutine mesh_dg_smouth_solu



  subroutine mesh_dg_suffix_get(i,sfx)
    ! ------------------------------------------------------
    integer     , intent(in)  :: i
    character(3), intent(out) :: sfx
    ! ------------------------------------------------------
    select case(i)
    case(  0:  9) ; write(sfx,'(i1)')i
    case( 10: 99) ; write(sfx,'(i2)')i
    case(100:999) ; write(sfx,'(i3)')i
    case default
      write(*,'("i =",i10)')i
      write(*,'("Value is out of Range [0,1000]")')
      write(*,'(/"STOP @ mesh_dg_suffix_get"/)')
      stop
    end select
  end subroutine mesh_dg_suffix_get

  subroutine mesh_dg_symetric_mesh(ob,iSym,BiDim)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    integer               :: iSym
    logical               :: BiDim
    !------------------------------------------------
    integer               :: i,i1,i2,i3,i4
    real(8)               :: t0,t1
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Building symetric mesh")')


    if( ob%geo==3 .and. .not.BiDim )then
      write(*,'(3x,a)')'Plane Symmetry'
      write(*,'(3x,"1 -> Symmetry / oxy",1x)')
      write(*,'(3x,"2 -> Symmetry / oxz",1x)')
      write(*,'(3x,"3 -> Symmetry / oyz",1x)')
      write(*,'(3x,"")',advance='no')
      read(*,*)iSym
      !
      select case(iSym)
      case(1) ; ob%vertx(3,:)=-ob%vertx(3,:)
        write(*,*)'Stop Not Implemented'
        stop
      case(2) ; ob%vertx(2,:)=-ob%vertx(2,:)
        write(*,*)'Stop Not Implemented'
        stop

      case(3) ; ob%vertx(1,:)=-ob%vertx(1,:)
        !
        if( ob%nT4/=0 )then
          write(*,*)'Stop Not Implemented'
          stop
        endif
        !
        !omp do
        do i=1,ob%nQ4
          i2=ob%quadr(2,i)
          i3=ob%quadr(3,i)
          i4=ob%quadr(4,i)
          ob%quadr(2:4,i)=[i4,i3,i2]
        enddo
        !omp enddo
        !
        !omp do
        do i=1,ob%nT3
          i2=ob%trian(2,i)
          i3=ob%trian(3,i)
          ob%trian(2:3,i)=[i3,i2]
        enddo
        !omp enddo
        !
        !omp do
        do i=1,ob%nL2
          i1=ob%edges(1,i)
          i2=ob%edges(2,i)
          ob%edges(1:2,i)=[i2,i1]
        enddo
        !omp enddo

      case default

        stop 'Bad Option'

      end select

    else

      write(ob%nlog,'(3x,a)')'Axial Symmetry'
      write(*,'(3x,"1 -> Symmetry / xx''",1x)')
      write(*,'(3x,"2 -> Symmetry / yy''",1x)')
      write(*,'(3x,"")',advance='no')
      read(*,*)iSym
      !
      select case(iSym)
      case(1) ; ob%vertx(2,:)=-ob%vertx(2,:)
      case(2) ; ob%vertx(1,:)=-ob%vertx(1,:)
      case default
        stop 'Bad Option'
      end select
      !
      do i=1,ob%nQ4
        i2=ob%quadr(2,i)
        i3=ob%quadr(3,i)
        i4=ob%quadr(4,i)
        ob%quadr(2:4,i)=[i4,i3,i2]
      enddo
      !
      do i=1,ob%nT3
        i2=ob%trian(2,i)
        i3=ob%trian(3,i)
        ob%trian(2:3,i)=[i3,i2]
      enddo
      !
      do i=1,ob%nL2
        i1=ob%edges(1,i)
        i2=ob%edges(2,i)
        ob%edges(1:2,i)=[i2,i1]
      enddo
    endif

    call cpu_time(t1)
    write(ob%nlog,'("End Building symetric mesh - CPU =",e12.5," s")')t1-t0
  end subroutine mesh_dg_symetric_mesh

  subroutine mesh_dg_symetric_solu(ob,iSym,BiDim)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    integer               :: iSym
    logical               :: BiDim
    !------------------------------------------------
    integer               :: i,ker
    !------------------------------------------------
    ker=0
    do i=1,ob%nfld
      select case(ob%kind(i))
      case(1) ; ker=ker+1
      case(2)
        if( ob%geo==3 .and. .not.BiDim )then
          select case(iSym)
          case(1) ! 1 -> Symmetry / oxy
            ob%solu(ker+3,:)=-ob%solu(ker+3,:)
          case(2) ! 2 -> Symmetry / oxz 
            ob%solu(ker+2,:)=-ob%solu(ker+2,:)
          case(3) ! 3 -> Symmetry / oyz
            ob%solu(ker+1,:)=-ob%solu(ker+1,:)
          end select
        else
          select case(iSym)
          case(1) ! 1 -> Symmetry / xx'
            ob%solu(ker+2,:)=-ob%solu(ker+2,:)
          case(2) ! 2 -> Symmetry / yy'
            ob%solu(ker+1,:)=-ob%solu(ker+1,:)
          end select
        endif
        ker=ker+ob%geo
      end select
    enddo
  end subroutine mesh_dg_symetric_solu


  subroutine mesh_dg_translate_mesh(ob)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    !------------------------------------------------
    integer               :: i
    real(8)               :: dx,dy,dz
    real(8) , parameter   :: pi=3.14159265358979
    real(8) , allocatable :: vertx(:,:)
    real(8)               :: sin_omg,cos_omg
    real(8)               :: t0,t1
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'("Translation of Mesh ",a)')trim(ob%mesh_name)

    select case(ob%geo)
    case(2)
      write(*,'(3x,"Enter translation vector: dx,dy")')
      write(*,'(3x,"")',advance='no')
      read(*,*)dx,dy
      !omp do
      do i=1,ob%nvert
        ob%vertx(1,i)=ob%vertx(1,i)+dx
        ob%vertx(2,i)=ob%vertx(2,i)+dy
      enddo
      !omp enddo
    case(3)
      write(*,'(3x,"Enter translation vector: dx,dy,dz")')
      write(*,'(3x,"")',advance='no')
      read(*,*)dx,dy,dz
      !omp do
      do i=1,ob%nvert
        ob%vertx(1,i)=ob%vertx(1,i)+dx
        ob%vertx(2,i)=ob%vertx(2,i)+dy
        ob%vertx(3,i)=ob%vertx(3,i)+dz
      enddo
      !omp enddo
    end select
    call cpu_time(t1)
    write(ob%nlog,'(a,e12.5,a)')'End Translation - CPU =',t1-t0,' s'
  end subroutine mesh_dg_translate_mesh


  !> Cherche puis supprime les points double ayant les mmes
  !! coordonnŽes. Retourne une liste de point rŽduite et une 
  !! table d'index permettant de rŽaliser l'opration de rŽduction
  !! sur les fichiers solutions correspondant.
  !! @param ob information about mesh_dg
  !! @todo Handle special case
  subroutine mesh_dg_trim_mesh(ob,idx)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    integer, allocatable  :: idx     (:)
    !------------------------------------------------
    integer               :: i,j,k,l,m,n,mem
    real(8)               :: xmin,xmax,ymin,ymax,zmin,zmax  
    real(8)               :: eps
    real(8)               :: tol,dl,dx,dy,dz,d2
    real(8)               :: ux,uy,uz
    integer               :: siz
    integer               :: sizx,nx
    integer               :: sizy,ny
    integer               :: sizz,nz
    integer, allocatable  :: gridHead(:),gridLink(:)
    integer, allocatable  :: dbleHead(:),dbleLink(:)
    integer, allocatable  :: index0   (:)
    integer, allocatable  :: index1   (:)
    integer               :: ii,jj,kk,ll,mm,nn,ic,d
    logical, allocatable  :: alone(:)
    integer               :: nvert
    real(8), allocatable  :: vertx(:,:)
    integer, allocatable  :: hexas(:,:)
    integer, allocatable  :: tetra(:,:)
    integer, allocatable  :: quadr(:,:)
    integer, allocatable  :: trian(:,:)
    integer, allocatable  :: edges(:,:)
    integer, allocatable  :: mark(:)
    integer               :: nod(8)
    real(8)               :: t0,t1
    logical               :: solution
    integer               :: ierr
    character(4)          :: key
    real(8)               :: val
    logical               :: doublePoint
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Supressing Extra Vertices")')
    write(*,'(3x,"Initial Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Initial Number of hexahedra: ",i10 )')ob%nH6
    if( ob%nT4/=0 )then
      write(*,'(3x,"Initial Number of tetrahedra ",i10 )')ob%nT4
      do i=1,100
        n=count(ob%tetra(5,:)==i)
        if( n/=0 )write(*,'(6x,"Tetra marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nQ4/=0 )write(*,'(3x,"Initial Number of quads      ",i10 )')ob%nQ4

    if( ob%nT3/=0 )then
      write(*,'(3x,"Initial Number of triangles: ",i10 )')ob%nT3
      do i=1,100
        n=count(ob%trian(4,:)==i)
        if( n/=0 )write(*,'(6x,"Trian marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nL2/=0 )write(*,'(3x,"Initial Number of edges:     ",i10 )')ob%nL2
    write(*,'()')

    eps=1d-6
    siz=256
    
    open(unit=500,file='./DEFAULT.mesh_dg',action='read',status='old',iostat=ierr)
    if( ierr==0 )then
      write(ob%nlog,'( 3x,"Reading DEFAULT.mesh_dg")')
      ReadingDefault : do
        read(500,*)key
        select case(trim(key))
        case('TOL','Tol','tol') ; read(500,*)eps
        case('SIZ','Siz','siz') ; read(500,*)siz
        case('END','End','end') ; exit ReadingDefault
        end select
      enddo ReadingDefault
      write(ob%nlog,'( 3x,a,e12.5 )')'Epsilon is set to ',eps
      write(ob%nlog,'( 3x,a,i12  /)')'Size of virtual Grid is set to ',siz


    else
      write(ob%nlog,'(3x,"File DEFAULT.mesh_dg not Found")')
      write(ob%nlog,'(3x,"Using default parameters")')
    endif


    select case(ob%geo)
    case(2)

      xmin=minval(ob%vertx(1,:)) ; xmax=maxval(ob%vertx(1,:))
      ymin=minval(ob%vertx(2,:)) ; ymax=maxval(ob%vertx(2,:))
      dx=xmax-xmin
      dy=ymax-ymin
      tol=eps*min(dx,dy)
      !
      write(ob%nlog,'( 3x,a,e12.5 )')'Epsilon              is set to ',eps
      write(ob%nlog,'( 3x,a,e12.5 )')'Tolerance = Epsilon * min(xmax-xmin,ymax-ymin)'
      write(ob%nlog,'( 3x,a,e12.5 )')'Tolerance is set to ',Tol
      write(ob%nlog,'( 3x,a,i12  /)')'Size of virtual Grid is set to ',siz

      d2=max(dx,dy)
      sizx=int(real(siz,kind=8)*dx/d2) ; nx=sizx+1
      sizy=int(real(siz,kind=8)*dy/d2) ; ny=sizy+1
      !
      dx=real(sizx,kind=8)/dx
      dy=real(sizy,kind=8)/dy
      !
      write(ob%nlog,'(3x,a,e12.5)')'Bounding Box'
      write(ob%nlog,'(6x,2(a,e12.5),a,i3)')'xmin=',xmin,' xmax=',xmax,' sizx=',sizx
      write(ob%nlog,'(6x,2(a,e12.5),a,i3)')'ymin=',ymin,' ymax=',ymax,' sizy=',sizy
      !
      write(ob%nlog,'(3x,a,2(i3,a),a)')'Building the Virtual Carthesian Grid (',nx,'x',ny,')'
      !
      allocate(gridHead(ny*nx+1),gridLink(ob%nvert))
      gridHead=0 ; gridLink=0
      !
      do k=1,ob%nvert
        ii=int(real(ob%vertx(1,k)-xmin,kind=8)*dx)
        jj=int(real(ob%vertx(2,k)-ymin,kind=8)*dy)
        ic=jj*nx+ii+1
        if( gridHead(ic)==0 )then
          gridHead(ic)=k
        else
          gridLink(k)=gridHead(ic)
          gridHead(ic)=k
        endif
      enddo

      write(ob%nlog,'(3x,a,e12.5)')'Looking for Extra Vertices using Virtual Carthesian Grid'

      allocate(index0(ob%nvert)) ; index0(:)=[(i, i=1,ob%nvert)]
      allocate(alone (ob%nvert)) ; alone (:)=.true.

      l=0 ; m=0
      do i=1,size(gridHead)
        !
        j=gridHead(i)
        do while(j/=0)
          m=m+1
          !write(ob%nlog,*)'j=',j,alone(j)
          if( alone(j) )then
            k=gridLink(j)
            do while(k/=0)
              !write(ob%nlog,*)'   k=',k,alone(k)
              if( alone(k) )then
                dx=ob%vertx(1,j)-ob%vertx(1,k)
                dy=ob%vertx(2,j)-ob%vertx(2,k)
                d2=dx*dx+dy*dy
                if( d2<=tol )then
                  alone(k)=.false.
                  index0(k)=j
                  l=l+1
                endif
              endif
              k=gridLink(k)
            enddo
          endif
          j=gridLink(j)
        enddo
      enddo

      deallocate(gridHead,gridLink)

      nvert=ob%nvert-l

      ! Vertices and Mark

      allocate(vertx(ob%geo,nvert),mark(nvert),index1(ob%nvert))

      j=0
      do i=1,ob%nvert
        if( alone(i) )then
          j=j+1
          vertx(1:2,j)=ob%vertx(1:2,i)
          mark (    j)=ob%mark    (    i)
          index1(   i)=j
        endif
      enddo

      call move_alloc(vertx, ob%vertx)
      call move_alloc(mark , ob%mark )
      
      allocate(idx(ob%nvert)) ; idx=index1(index0)
      deallocate(index0,index1,alone)      
      
      ob%nvert=nvert

      ! Connectivities

      allocate(quadr(5,ob%nQ4))
      m=0
      do i=1,ob%nQ4
        nod(1)=idx(ob%quadr(1,i))
        nod(2)=idx(ob%quadr(2,i))
        nod(3)=idx(ob%quadr(3,i))
        nod(4)=idx(ob%quadr(4,i))
        if(      nod(1)/=nod(2) .and. nod(1)/=nod(3) .and. nod(1)/=nod(4) &
        &                       .and. nod(2)/=nod(3) .and. nod(2)/=nod(4) &
        &                                        .and. nod(3)/=nod(4) )then
          m=m+1 ; quadr(1:5,m)=[nod(1),nod(2),nod(3),nod(4), ob%quadr(5,i)]
        endif
      enddo
     !if( ob%nQ4-m/=0 )write(ob%nlog,'(3x,a,i10,a)')'Supressing ',ob%nQ4-m,' quadrangles'
      ob%nQ4=m ; call move_alloc(quadr, ob%quadr)

      allocate(trian(4,ob%nT3))
      m=0
      do i=1,ob%nT3
        nod(1)=idx(ob%trian(1,i))
        nod(2)=idx(ob%trian(2,i))
        nod(3)=idx(ob%trian(3,i))
        if( nod(1)/=nod(2) .and. nod(1)/=nod(3) .and. nod(2)/=nod(3) )then
          m=m+1 ; trian(1:4,m)=[nod(1),nod(2),nod(3), ob%trian(4,i)]
        endif
      enddo
     !if( ob%nT3-m/=0 )write(ob%nlog,'(3x,a,i10,a)')'Supressing ',ob%nT3-m,' triangles'
      ob%nT3=m ; call move_alloc(trian, ob%trian)

      allocate(edges(3,ob%nL2))
      m=0
      do i=1,ob%nL2
        nod(1)=idx(ob%edges(1,i))
        nod(2)=idx(ob%edges(2,i))
        if( nod(1)/=nod(2) )then
          m=m+1 ; edges(1:3,m)=[nod(1),nod(2), ob%edges(3,i)]
        endif
      enddo
     !if( ob%nL2-m/=0 )write(ob%nlog,'(3x,a,i10,a)')'Supressing ',ob%nL2-m,' edges'
      ob%nL2=m ; call move_alloc(edges, ob%edges)
    
    case(3)

      xmin=minval(ob%vertx(1,:)) ; xmax=maxval(ob%vertx(1,:))
      ymin=minval(ob%vertx(2,:)) ; ymax=maxval(ob%vertx(2,:))
      zmin=minval(ob%vertx(3,:)) ; zmax=maxval(ob%vertx(3,:))
      dx=xmax-xmin
      dy=ymax-ymin
      dz=zmax-zmin
      tol=eps*min(dx,dy,dz)
      !
      d2=max(dx,dy,dz)
      sizx=int(real(siz,kind=8)*dx/d2) ; nx=sizx+1
      sizy=int(real(siz,kind=8)*dy/d2) ; ny=sizy+1
      sizz=int(real(siz,kind=8)*dz/d2) ; nz=sizz+1
      !
      dx=real(sizx,kind=8)/dx
      dy=real(sizy,kind=8)/dy
      dz=real(sizz,kind=8)/dz
      !
      write(ob%nlog,'(3x,"Bounding Box")')
      write(ob%nlog,'(6x,2(a,e12.5),a,i3)')'xmin=',xmin,' xmax=',xmax,' sizx=',sizx
      write(ob%nlog,'(6x,2(a,e12.5),a,i3)')'ymin=',ymin,' ymax=',ymax,' sizy=',sizy
      write(ob%nlog,'(6x,2(a,e12.5),a,i3)')'zmin=',zmin,' zmax=',zmax,' sizz=',sizz
      write(ob%nlog,'( 3x,a,e12.5 )')'Tolerance = Epsilon * min(xmax-xmin,ymax-ymin,zmax-zmin)=',Tol

      write(ob%nlog,'(3x,a,3(i3,a),a)')'Building the Virtual Carthesian Grid (',nx,'x',ny,'x',nz,')'
      !
      allocate(gridHead(nz*ny*nx+1),gridLink(ob%nvert))
      gridHead=0 ; gridLink=0
      !
      !$omp do private(k,ii,jj,kk,ic)
      do k=1,ob%nvert
        ii=int(real(ob%vertx(1,k)-xmin,kind=8)*dx)
        jj=int(real(ob%vertx(2,k)-ymin,kind=8)*dy)
        kk=int(real(ob%vertx(3,k)-zmin,kind=8)*dz)
        ic=(kk*ny+jj)*nx+ii+1
        if( gridHead(ic)==0 )then
          gridHead(ic)=k
        else
          gridLink(k)=gridHead(ic)
          gridHead(ic)=k
        endif
      enddo
      !$omp enddo

      write(ob%nlog,'(3x,a,e12.5)')'Looking for Extra Vertices using Virtual Carthesian Grid'

      allocate(index0(ob%nvert)) ; index0(:)=[(i, i=1,ob%nvert)]
      allocate(alone (ob%nvert)) ; alone (:)=.true.

      l=0 ; m=0
      do i=1,size(gridHead)
        !
        j=gridHead(i)
        do while(j/=0)
          m=m+1
          !write(ob%nlog,*)'j=',j,alone(j)
          if( alone(j) )then
            k=gridLink(j)
            do while(k/=0)
              !write(ob%nlog,*)'   k=',k,alone(k)
              if( alone(k) )then
                dx=ob%vertx(1,j)-ob%vertx(1,k)
                dy=ob%vertx(2,j)-ob%vertx(2,k)
                dz=ob%vertx(3,j)-ob%vertx(3,k)
                d2=dx*dx+dy*dy+dz*dz
                if( d2<=tol )then
                  alone (k)=.false.
                  index0(k)=j
                  l=l+1
                endif
              endif
              k=gridLink(k)
            enddo
          endif
          j=gridLink(j)
        enddo
      enddo

      deallocate(gridHead,gridLink)

      nvert=ob%nvert-l

      ! Vertices and Mark

      allocate(vertx(ob%geo,nvert),mark(nvert),index1(ob%nvert))

      j=0
      do i=1,ob%nvert
        if( alone(i) )then
          j=j+1
          vertx(1:3,j)=ob%vertx(1:3,i)
          mark  (    j)=ob%mark    (    i)
          index1(    i)=j
        endif
      enddo

      call move_alloc(vertx, ob%vertx)
      call move_alloc(mark , ob%mark )
      
      allocate(idx(ob%nvert)) ; idx=index1(index0)
      deallocate(index0,index1,alone)
      ob%nvert=nvert
      
      ! Connectivities

      if( ob%nH6/=0 )then
        allocate(hexas(9,ob%nH6))
        m=0
        do i=1,ob%nH6
          nod(1)=idx(ob%hexas(1,i))
          nod(2)=idx(ob%hexas(2,i))
          nod(3)=idx(ob%hexas(3,i))
          nod(4)=idx(ob%hexas(4,i))
          nod(5)=idx(ob%hexas(5,i))
          nod(6)=idx(ob%hexas(6,i))
          nod(7)=idx(ob%hexas(7,i))
          nod(8)=idx(ob%hexas(8,i))
          !
          doublePoint=.false.
          do j=1,8
            do k=j+1,8
              if( nod(j)==nod(k) )doublePoint=.true.
            enddo
          enddo
          
          if( doublePoint )then
            write(*,'(6x,"Hexa -> Other polyhedra (developpements required)")')
            do j=1,8
              do k=j+1,8
                if( nod(j)==nod(k) )then
                  write(*,'(9x,"iHexa=",i10,3x,"nod",i1,"=nod",i1)')i,j,k
                endif
              enddo
            enddo
           !m=m+1 ; hexas(1:9,m)=[nod(1),nod(2),nod(3),nod(4),nod(5),nod(6),nod(7),nod(8), ob%hexas(9,i)]
          else
            m=m+1 ; hexas(1:9,m)=[nod(1),nod(2),nod(3),nod(4),nod(5),nod(6),nod(7),nod(8), ob%hexas(9,i)]
          endif
        enddo
       !if( ob%nH6-m/=0 )write(ob%nlog,'(a,i10,a)')'Supressing ',ob%nH6-m,' hexahedra'
        ob%nH6=m ; call move_alloc(hexas, ob%hexas)
      endif

      if( ob%nT4/=0 )then
        allocate(tetra(5,ob%nT4))
        m=0
        do i=1,ob%nT4
          nod(1)=idx(ob%tetra(1,i))
          nod(2)=idx(ob%tetra(2,i))
          nod(3)=idx(ob%tetra(3,i))
          nod(4)=idx(ob%tetra(4,i))
          !
          if( nod(1)/=nod(2) .and. nod(1)/=nod(3) .and. nod(1)/=nod(4) &
          &                  .and. nod(2)/=nod(3) .and. nod(2)/=nod(4) &
          &                                       .and. nod(3)/=nod(4) )then
            m=m+1 ; tetra(1:5,m)=[nod(1),nod(2),nod(3),nod(4), ob%tetra(5,i)]
          endif
        enddo
       !if( ob%nT4-m/=0 )write(ob%nlog,'(a,i10,a)')'Supressing ',ob%nT4-m,' tetrahedra'
        ob%nT4=m ; call move_alloc(tetra, ob%tetra)
      endif

      if( ob%nQ4/=0 )then
        allocate(quadr(5,ob%nQ4))
        m=0
        do i=1,ob%nQ4
          nod(1)=idx(ob%quadr(1,i))
          nod(2)=idx(ob%quadr(2,i))
          nod(3)=idx(ob%quadr(3,i))
          nod(4)=idx(ob%quadr(4,i))
          if(      nod(1)/=nod(2) .and. nod(1)/=nod(3) .and. nod(1)/=nod(4) &
          &               .and. nod(2)/=nod(3) .and. nod(2)/=nod(4) &
          &                            .and. nod(3)/=nod(4) )then
            m=m+1 ; quadr(1:5,m)=[nod(1),nod(2),nod(3),nod(4), ob%quadr(5,i)]
          endif
        enddo
       !if( ob%nQ4-m/=0 )write(ob%nlog,'(a,i10,a)')'Supressing ',ob%nQ4-m,' quadrangles'
        ob%nQ4=m ; call move_alloc(quadr, ob%quadr)
      endif

      if( ob%nT3/=0 )then
        allocate(trian(4,ob%nT3))
        m=0
        do i=1,ob%nT3
          nod(1)=idx(ob%trian(1,i))
          nod(2)=idx(ob%trian(2,i))
          nod(3)=idx(ob%trian(3,i))
          if( nod(1)/=nod(2) .and. nod(1)/=nod(3) .and. nod(2)/=nod(3) )then
            m=m+1 ; trian(1:4,m)=[nod(1),nod(2),nod(3), ob%trian(4,i)]
          endif
        enddo
       !if( ob%nT3-m/=0 )write(ob%nlog,'(a,i10,a)')'Supressing ',ob%nT3-m,' triangles'
        ob%nT3=m ; call move_alloc(trian, ob%trian)
      endif

      if( ob%nL2/=0 )then
        allocate(edges(3,ob%nL2))
        m=0
        do i=1,ob%nL2
          nod(1)=idx(ob%edges(1,i))
          nod(2)=idx(ob%edges(2,i))
          if( nod(1)/=nod(2) )then
            m=m+1 ; edges(1:3,m)=[nod(1),nod(2), ob%edges(3,i)]
          endif
        enddo
       !if( ob%nL2-m/=0 )write(ob%nlog,'(a,i10,a)')'Supressing ',ob%nL2-m,' edges'
        ob%nL2=m ; call move_alloc(edges, ob%edges)
      endif

    end select

    call cpu_time(t1)

    write(*,'(/3x,"Final   Number of vertices:  ",i10 )')ob%nvert
    if( ob%nH6/=0 )write(*,'(3x,"Final   Number of hexahedra: ",i10 )')ob%nH6

    if( ob%nT4/=0 )then
      write(*,'(3x,"Final   Number of tetrahedra ",i10 )')ob%nT4
      do i=1,100
        n=count(ob%tetra(5,:)==i)
        if( n/=0 )write(*,'(6x,"Tetra marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nQ4/=0 )write(*,'(3x,"Final   Number of quads      ",i10 )')ob%nQ4

    if( ob%nT3/=0 )then
      write(*,'(3x,"Final   Number of triangles: ",i10 )')ob%nT3
      do i=1,100
        n=count(ob%trian(4,:)==i)
        if( n/=0 )write(*,'(6x,"Trian marked ",i2,": ",i10)')i,n
      enddo
    endif

    if( ob%nL2/=0 )write(*,'(3x,"Final   Number of edges:     ",i10/)')ob%nL2
    write(ob%nlog,'("End Supressing Extra Vertices - CPU =",e12.5,"s"/)')t1-t0

  end subroutine mesh_dg_trim_mesh


  subroutine mesh_dg_trim_solu(ob,idx)
    !------------------------------------------------
    type(mesh_dg)         :: ob
    integer, allocatable  :: idx(:)
    !------------------------------------------------
    integer               :: i,j,k,l,m,n,mem
    integer               :: nsol
    real(8), allocatable  :: solu(:,:)
    integer, allocatable  :: cmpt(:)
    real(8)               :: t0,t1
    !------------------------------------------------
    call cpu_time(t0)
    write(ob%nlog,'(/"Supressing Extra Solutions")')
    write(ob%nlog,'( 3x,"Initial Number of Fields:    ",i10)')ob%nfld
    write(ob%nlog,'( 3x,"Initial Number of solutions: ",i10)')ob%nSol

    if( ob%nsol/=0 )then

      call cpu_time(t0)
      do i=1,ob%ker
        write(ob%nlog,'( 6x,"min,max( solu(",i1,",:) )=",2(f12.5,1x) )')i,minval(ob%solu(i,:)),maxval(ob%solu(i,:))
      enddo
      allocate(solu(ob%ker,ob%nvert)) ; solu=0.
      allocate(cmpt(ob%nsol)) ; cmpt=0
      do i=1,ob%nsol
        j=idx(i)
        solu(:,j)=solu(:,j)+ob%solu(:,i)
        cmpt(  j)=cmpt(  j)+1
      enddo
      !
      nsol=ob%nvert
      !$omp do
      do i=1,nsol
        solu(:,i)=solu(:,i)/cmpt(i)
      enddo
      !$omp enddo
      !
      deallocate(cmpt)
      call move_alloc(solu, ob%solu)
      ob%nsol=nsol
      !
      write(*,'( 3x,"Final   Number of Fields:    ",i10)')ob%nfld
      write(*,'( 3x,"Final   Number of solutions: ",i10)')ob%nSol
      do i=1,ob%ker
        write(ob%nlog,'( 6x,"min,max( solu(",i1,",:) )=",2(f12.5,1x) )')i,minval(ob%solu(i,:)),maxval(ob%solu(i,:))
      enddo
    endif
    call cpu_time(t1)
    write(ob%nlog,'("End Supressing Extra Solu - CPU =",e12.5,"s"/)')t1-t0
  end subroutine mesh_dg_trim_solu


  subroutine mesh_dg_xy_uv(ob,nod,vertx,vertu)
    ! ---------------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob
    real(8)      , intent(in)  :: vertx(2)
    integer      , intent(in)  :: nod(3)
    real(8)      , intent(out) :: vertu(2)
    ! ---------------------------------------------------------------
    real(8)                    :: det1,det2,bi(2),mat1(2,2),mat2(2,2)
    real(8)                    :: t0,t1
    ! ---------------------------------------------------------------
    ! Coordonnees barycentriques
    ! par resolution d'un systeme cramerien
    !
    mat2(:,1)=ob%vertx(:,nod(2))-ob%vertx(:,nod(1))
    mat2(:,2)=ob%vertx(:,nod(3))-ob%vertx(:,nod(1))
    !
    det2=mat2(1,1)*mat2(2,2)-mat2(2,1)*mat2(1,2)
    bi(1:2)=vertx(1:2)-ob%vertx(1:2,nod(1))

    !
    mat1=mat2 ; mat1(:,1)=bi ;
    det1=mat1(1,1)*mat1(2,2)-mat1(2,1)*mat1(1,2)
    vertu(1)=det1/det2
    !
    mat1=mat2 ; mat1(:,2)=bi
    det1=mat1(1,1)*mat1(2,2)-mat1(2,1)*mat1(1,2)
    vertu(2)=det1/det2
    !
  end subroutine mesh_dg_xy_uv


  subroutine mesh_dg_xyz_uvw(ob,nod,vertx,vertu)
    ! ---------------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob
    integer      , intent(in)  :: nod(4)
    real(8)      , intent(in)  :: vertx(3)
    real(8)      , intent(out) :: vertu(3)
    ! ---------------------------------------------------------------
    real(8)                    :: det1,det2
    real(8)                    :: bi(3),mat1(3,3),mat2(3,3)
    ! ---------------------------------------------------------------
    !
    ! Coordonnees barycentriques
    ! par resolution d'un systeme cramerien
    !
    mat2(:,1)=ob%vertx(:,nod(2))-ob%vertx(:,nod(1))
    mat2(:,2)=ob%vertx(:,nod(3))-ob%vertx(:,nod(1))
    mat2(:,3)=ob%vertx(:,nod(4))-ob%vertx(:,nod(1))
    !
    det2=mesh_dg_T4_det(mat2)
    if( det2==0d0 )then
      write(*,'("det == 0")')
      write(*,'("stop @ mesh_dg_xyz_uvw")')
      stop
    endif
    det2=1d0/det2
    !
    bi(1:3)=vertx(1:3)-ob%vertx(1:3,nod(1))
    !
    mat1=mat2 ; mat1(1:3,1)=bi(1:3) ; vertu(1)=mesh_dg_T4_det(mat1)*det2
    mat1=mat2 ; mat1(1:3,2)=bi(1:3) ; vertu(2)=mesh_dg_T4_det(mat1)*det2
    mat1=mat2 ; mat1(1:3,3)=bi(1:3) ; vertu(3)=mesh_dg_T4_det(mat1)*det2
    !
  end subroutine mesh_dg_xyz_uvw

  function mesh_dg_T4_det(mat) result(d)
    ! ---------------------------------------------------------------
    ! Determinant d'une matrice 3x3 reelle
    ! ---------------------------------------------------------------
    real(8) :: mat(3,3)
    real(8) :: d
    ! ---------------------------------------------------------------
    d= mat(1,1)*(mat(2,2)*mat(3,3)-mat(2,3)*mat(3,2)) &
    & -mat(1,2)*(mat(2,1)*mat(3,3)-mat(3,1)*mat(2,3)) &
    & +mat(1,3)*(mat(2,1)*mat(3,2)-mat(3,1)*mat(2,2))
  end function mesh_dg_T4_det



  subroutine mesh_dg_vert(ob,BiDim)
    !-----------------------------------
    type(mesh_dg), intent(in) :: ob
    logical                   :: BiDim
    !-----------------------------------
    integer                   :: i
    !-----------------------------------
    open(unit=10,file='vertices.txt')
    if( BiDim )then
      do i=1,ob%nvert
        write(10,'(2(e22.15,1x),i2)')ob%vertx(1,i),ob%vertx(2,i),ob%mark(i)
      enddo
    else
      do i=1,ob%nvert
        write(10,'(3(e22.15,1x),i2)')ob%vertx(1,i),ob%vertx(2,i),ob%vertx(3,i),ob%mark(i)
      enddo
    endif
    close(10)
  end subroutine mesh_dg_vert

  subroutine mesh_dg_vertex_inside_Quadrangle(ob,e0,vertx,det,loc)
    !------------------------------------------------------
    !                  II
    ! n4(-1,+1) x--------------x n3(+1,+1)
    !           |              |
    !           |              |
    !           |              |
    !       III |              | I
    !           |              |
    !           |              |
    !           |              |
    ! n1(-1,-1) x--------------x n2(+1,-1)
    !                  IV
    !------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob
    integer      , intent(in)  :: e0
    real(8)      , intent(in)  :: vertx(2)
    real(8)      , intent(out) :: det(4)
    logical      , intent(out) :: loc
    !------------------------------------------------------
    real(8)                    :: v01(2),v02(2),v03(2),v04(2)
    !------------------------------------------------------  
    det=-1d0
    ! Vecteurs
    v01(1:2)=ob%vertx(1:2,ob%quadr(1,e0))-vertx(1:2)    
    v02(1:2)=ob%vertx(1:2,ob%quadr(2,e0))-vertx(1:2)
    v03(1:2)=ob%vertx(1:2,ob%quadr(3,e0))-vertx(1:2)
    v04(1:2)=ob%vertx(1:2,ob%quadr(4,e0))-vertx(1:2)

    ! Determinant
    det(1)=mesh_dg_determinant2D(v02,v03)
    det(2)=mesh_dg_determinant2D(v03,v04)
    det(3)=mesh_dg_determinant2D(v04,v01)
    det(4)=mesh_dg_determinant2D(v01,v02)
    !
    if( det(1)<0..or.det(2)<0..or.det(3)<0..or.det(4)<0. )then
      loc=.false.
    else
      loc=.true.
    endif
  end subroutine mesh_dg_vertex_inside_Quadrangle


  subroutine mesh_dg_vertex_inside_Triangle(ob,e0,vertx,det,loc)
    !------------------------------------------------------
    !   n3(0,1) x
    !           | \
    !           |   \
    !           |     \
    !        II |       \  I
    !           |         \
    !           |           \
    !           |             \
    !   n1(0,0) x--------------x n2(1,0)
    !                 III
    !------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob
    integer      , intent(in)  :: e0
    real(8)      , intent(in)  :: vertx(2)
    real(8)      , intent(out) :: det(4)
    logical      , intent(out) :: loc
    !------------------------------------------------------
    real(8)                   :: v01(2),v02(2),v03(2)
    !------------------------------------------------------  
    ! Vecteurs
    v01(1:2)=ob%vertx(1:2,ob%trian(1,e0))-vertx(1:2)    
    v02(1:2)=ob%vertx(1:2,ob%trian(2,e0))-vertx(1:2)    
    v03(1:2)=ob%vertx(1:2,ob%trian(3,e0))-vertx(1:2)  
    ! Determinant
    det(1)=mesh_dg_determinant2D(v02,v03)
    det(2)=mesh_dg_determinant2D(v03,v01)
    det(3)=mesh_dg_determinant2D(v01,v02)
    det(4)=0d0
    !
    if( det(1)<0d0.or.det(2)<0d0.or.det(3)<0d0 )then
      loc=.false.
    else
      loc=.true.
    endif
  end subroutine mesh_dg_vertex_inside_Triangle

  subroutine mesh_dg_vertex_inside_Tetra(ob,e0,vertx,det,loc)
    !------------------------------------------------------
    type(mesh_dg), intent(in)  :: ob
    integer      , intent(in)  :: e0
    real(8)      , intent(in)  :: vertx(3)
    real(8)      , intent(out) :: det(4)
    logical      , intent(out) :: loc
    !------------------------------------------------------
    real(8)                    :: v01(3),v02(3),v03(3),v04(3)
    !------------------------------------------------------  
    ! Vecteurs
    v01(1:3)=ob%vertx(1:3,ob%tetra(1,e0))-vertx(1:3)
    v02(1:3)=ob%vertx(1:3,ob%tetra(2,e0))-vertx(1:3)
    v03(1:3)=ob%vertx(1:3,ob%tetra(3,e0))-vertx(1:3)
    v04(1:3)=ob%vertx(1:3,ob%tetra(4,e0))-vertx(1:3)
    ! Determinant
    det(1)=mesh_dg_determinant3D(v02,v03,v04)
    det(2)=mesh_dg_determinant3D(v01,v04,v03)
    det(3)=mesh_dg_determinant3D(v01,v02,v04)
    det(4)=mesh_dg_determinant3D(v01,v03,v02)
    !
    if( det(1)<0d0 .or. det(2)<0d0 .or. det(3)<0d0 .or. det(4)<0d0 )then
      loc=.false.
    else
      loc=.true.
    endif
  end subroutine mesh_dg_vertex_inside_Tetra


  function mesh_dg_determinant2D(v1,v2) result(d)
    ! ____________________________________________________________
    ! Determinant d'une matrice 3x3 reelle
    ! ____________________________________________________________
    real(8):: v1(2), v2(2)
    real(8):: d
    ! ____________________________________________________________
    d=v1(1)*v2(2)-v2(1)*V1(2)
  end function mesh_dg_determinant2D

  function mesh_dg_determinant3D(v1,v2,v3) result(d)
    ! ____________________________________________________________
    ! Determinant d'une matrice 3x3 reelle
    ! ____________________________________________________________
    real(8):: v1(3), v2(3), v3(3)
    real(8):: d
    ! ____________________________________________________________
    d= v1(1)*(v2(2)*v3(3)-v3(2)*v2(3)) &
    & -v1(2)*(v2(1)*v3(3)-v3(1)*v2(3)) &
    & +v1(3)*(v2(1)*v3(2)-v3(1)*v2(2))
  end function mesh_dg_determinant3D

  subroutine mesh_dg_write_mesh(ob,skin)
    !-----------------------------------
    use M_libmesh5_api
    !-----------------------------------
    type(mesh_dg), intent(in) :: ob
    logical      , intent(in) :: skin
    !-----------------------------------
    integer                   :: i,out,res,ver
    integer , allocatable     :: TypTab(:)
    integer                   :: n(0:9)
    !-----------------------------------
    write(ob%nlog,'(/"Writing Mesh ",a)')trim(ob%mesh_name)
    if( ob%nVert/=0 )write(ob%nlog,'(3x,a,i10)')'Number of vertices:    ',ob%nVert
    do i=0,9
      n(i)=count(ob%mark==i)
      if( n(i)/=0 )write(ob%nlog,'(6x,"mark",i1,":",14x,i10)')i,n(i)
    enddo
    if( ob%nH6  /=0 )write(ob%nlog,'(3x,a,i10)')'Number of hexa:        ',ob%nH6
    if( ob%nT4  /=0 )write(ob%nlog,'(3x,a,i10)')'Number of tetra:       ',ob%nT4
    if( ob%nQ4  /=0 )write(ob%nlog,'(3x,a,i10)')'Number of quadrangles: ',ob%nQ4
    if( ob%nT3  /=0 )write(ob%nlog,'(3x,a,i10)')'Number of triangles:   ',ob%nT3
    if( ob%nL2  /=0 )write(ob%nlog,'(3x,a,i10)')'Number of edges:       ',ob%nL2
    !
    select case(ob%geo)
    case(2)
      write(ob%nlog,'(3x,"Bounding Box")')
      write(ob%nlog,'(6x,"xmin=",e12.5," - xmax=",e12.5)')minval(ob%vertx(1,1:ob%nvert)),maxval(ob%vertx(1,1:ob%nvert))
      write(ob%nlog,'(6x,"ymin=",e12.5," - ymax=",e12.5)')minval(ob%vertx(2,1:ob%nvert)),maxval(ob%vertx(2,1:ob%nvert))
    case(3)    
      write(ob%nlog,'(3x,"Bounding Box")')
      write(ob%nlog,'(6x,"xmin=",e12.5," - xmax=",e12.5)')minval(ob%vertx(1,1:ob%nvert)),maxval(ob%vertx(1,1:ob%nvert))
      write(ob%nlog,'(6x,"ymin=",e12.5," - ymax=",e12.5)')minval(ob%vertx(2,1:ob%nvert)),maxval(ob%vertx(2,1:ob%nvert))
      write(ob%nlog,'(6x,"zmin=",e12.5," - zmax=",e12.5)')minval(ob%vertx(3,1:ob%nvert)),maxval(ob%vertx(3,1:ob%nvert))
    end select
    !
   !ver=1 ! real are float
    ver=2 ! real are double
    out=GmfOpenMeshF77(trim(ob%mesh_name),GmfWrite,ver,ob%geo)
    if( out==0 )then
      write(*,'("File: ",a," not opened")')trim(ob%mesh_name)
      stop
    endif
    ! Vertices
    res=GmfSetKwdF77(out,GmfVertices,ob%nvert,0,TypTab)
    select case(ob%geo)
    case(2)
      do i=1,ob%nvert
        call GmfSetVertex2Dr8(out,ob%vertx(1,i),ob%vertx(2,i),ob%mark(i))
      enddo
    case(3)
      do i=1,ob%nvert
        call GmfSetVertex3dr8(out,ob%vertx(1,i),ob%vertx(2,i),ob%vertx(3,i),ob%mark(i))
      enddo
    end select
    !

    ! Connectivites
    select case(ob%geo)
    case(2)
      ! Triangles
      if( .not.skin )then
        if( ob%nT3/=0 )then
          res=GmfSetKwdF77(out,GmfTriangles,ob%nT3,0,TypTab)
          do i=1,ob%nT3
            call GmfSetTriangle(out,ob%trian(1,i),ob%trian(2,i),ob%trian(3,i),ob%trian(4,i))
          enddo
        endif
        if( ob%nQ4/=0 )then
          res=GmfSetKwdF77(out,GmfQuadrilaterals,ob%nQ4,0,TypTab)
          do i=1,ob%nQ4
            call GmfSetQuadrilateral(out,ob%quadr(1,i),ob%quadr(2,i),ob%quadr(3,i),ob%quadr(4,i),ob%quadr(5,i))
          enddo
        endif
      endif
      if( ob%nL2/=0 )then
        res=GmfSetKwdF77(out,GmfEdges,ob%nL2,0,TypTab)
        do i=1,ob%nL2
          call GmfSetEdge(out,ob%edges(1,i),ob%edges(2,i),ob%edges(3,i))
        enddo
      endif
    case(3)
      if( .not.skin )then 
        if( ob%nH6/=0 )then
          res=GmfSetKwdF77(out,GmfHexahedra,ob%nH6,0,TypTab)
          do i=1,ob%nH6
            call GmfSetHexahedron(   &
            &   out                   ,&
            &   ob%hexas(1,i)         ,&
            &   ob%hexas(2,i)         ,&
            &   ob%hexas(3,i)         ,&
            &   ob%hexas(4,i)         ,&
            &   ob%hexas(5,i)         ,&
            &   ob%hexas(6,i)         ,&
            &   ob%hexas(7,i)         ,&
            &   ob%hexas(8,i)         ,&
            &   ob%hexas(9,i)          )
          enddo
        endif
        !
        if( ob%nT4/=0 )then
          res=GmfSetKwdF77(out,GmfTetrahedra,ob%nT4,0,TypTab)
          do i=1,ob%nT4
            call GmfSetTetrahedron(out,ob%tetra(1,i),ob%tetra(2,i),ob%tetra(3,i),ob%tetra(4,i),ob%tetra(5,i))
          enddo
        endif
      endif
      !
      if( ob%nQ4/=0 )then
        res=GmfSetKwdF77(out,GmfQuadrilaterals,ob%nQ4,0,TypTab)
        do i=1,ob%nQ4
          call GmfSetQuadrilateral(out,ob%quadr(1,i),ob%quadr(2,i),ob%quadr(3,i),ob%quadr(4,i),ob%quadr(5,i))
        enddo
      endif
      !
      if( ob%nT3/=0 )then
        res=GmfSetKwdF77(out,GmfTriangles,ob%nT3,0,TypTab)
        do i=1,ob%nT3
          call GmfSetTriangle(out,ob%trian(1,i),ob%trian(2,i),ob%trian(3,i),ob%trian(4,i))
        enddo
      endif
      !
      if( ob%nL2/=0 )then
        res=GmfSetKwdF77(out,GmfEdges,ob%nL2,0,TypTab)
        do i=1,ob%nL2
          call GmfSetEdge(out,ob%edges(1,i),ob%edges(2,i),ob%edges(3,i))
        enddo
      endif
    end select
    !
    res=GmfCloseMeshf77(out)

    write(ob%nlog,'("End Writing Mesh")')
  end subroutine mesh_dg_write_mesh

  subroutine mesh_dg_write_solu(ob)
    !-----------------------------------
   !use m_libmesh5
    use M_libmesh5_api
    !-----------------------------------
    type(mesh_dg), intent(in) :: ob
    !-----------------------------------
    integer                   :: i,out,res,ver
    !-----------------------------------
    if( ob%nfld/=0 .and. ob%nsol/=0 )then
      write(ob%nlog,'(/"Writing Solu ",a)')trim(ob%solu_name)
      !
      ver=2
      select case(ver)
      case(1) ; write(ob%nlog,'(3x,"Single Precision Solu File: ",a)')trim(ob%solu_name)
      case(2) ; write(ob%nlog,'(3x,"Double Precision Solu File: ",a)')trim(ob%solu_name)
      end select
      !
      if( ob%nsol/=0 )write(ob%nlog,'(3x,a,i10)')'Number of sol@vertx:   ',ob%nsol
      !
      if( ob%nfld/=0 )then
        write(ob%nlog,'(3x,a,i10)')'Number of fields:      ',ob%nfld
        do i=1,ob%nfld
          select case(ob%kind(i))
          case(1) ; write(ob%nlog,'(6x,"Field ",i2," is scalar")')i
          case(2) ; write(ob%nlog,'(6x,"Field ",i2," is vector")')i
          case default
            write(ob%nlog,'(6x,"Field ",i2," is of unknown kind: ",i10)')i,ob%kind(i)
          end select
        enddo
      endif
      !
      ! >>> libmesh5 >>>
      out=GmfOpenMeshF77(trim(ob%solu_name),GmfWrite,ver,ob%geo)
      res=GmfSetKwdF77(out,GmfSolAtVertices,ob%nsol,ob%nfld,ob%kind)
      do i=1,ob%nSol
        call gmfSetSolAtVertexR8(out,ob%solu(:,i))
      enddo
      res=GmfCloseMeshf77(out)
      ! <<< libmesh5 <<<

      write(ob%nlog,'(3x,"Bounding Box")')
      do i=1,ob%ker
        write(ob%nlog,'( 6x,"min,max( solu(",i1,",:) )=",2(f12.5,1x) )')i,minval(ob%solu(i,:)),maxval(ob%solu(i,:))
      enddo

      write(ob%nlog,'("End Writing Solu")')
    endif
  end subroutine mesh_dg_write_solu


  subroutine mesh_v3d_init(ob,input_mesh,input_solu,output_mesh,nfields)
    !-----------------------------------
    type(mesh_v3d)              :: ob
    character(256) , intent(in) :: input_mesh
    character(256) , intent(in) :: input_solu
    character(256) , intent(in) :: output_mesh
    integer        , intent(in) :: nfields
    !-----------------------------------
    ob%input_mesh =input_mesh
    ob%input_solu =input_solu
    ob%output_mesh=output_mesh
    ob%nfields    = nfields
  end subroutine mesh_v3d_init 

end module moduleMesh
